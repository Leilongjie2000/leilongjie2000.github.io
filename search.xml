<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/03/30/llvm-wei-yi-you-pass-tian-jia-yi-ge-bian-yi-xuan-xiang/"/>
      <url>/2025/03/30/llvm-wei-yi-you-pass-tian-jia-yi-ge-bian-yi-xuan-xiang/</url>
      
        <content type="html"><![CDATA[<p>LLVM：为已有pass添加一个编译选项</p><p>摘要：</p><p>本文以LLVM19.1.0为基础，阐述了如何为LLVM的pass添加一个编译选项，并解释其原理，进而帮助我们在进行性能分析时更好的判断影响因素。</p><p>动机：</p><p>在进行程序性能分析时，我们经常需要判断排除一些因素的影响，比如我想排除向量化的影响，llvm的clang端提供了禁用向量化的pass以此来排除向量化的印象，但是有一些pass并没有提供这类的选项，因此，基于这个痛点出来，我们以向量化为例自制一个编译选项(llvm 的flang-new并不支持禁用向量化的选项)以此来满足我们的目的。</p><p>实现：</p><p>前置准备：</p><p>我们先用deepseek帮我们写一个kernel，这个kernel是一个矩阵乘的实现。</p><p>kernel：</p><figure class="highlight fortran"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">program</span></span> matrix_multiply</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span>, <span class="keyword">parameter</span> :: N = <span class="number">1024</span></span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">allocatable</span> :: A(:,:), B(:,:), C1(:,:), C2(:,:)</span><br><span class="line">  <span class="keyword">integer</span> :: i, j, k</span><br><span class="line">  <span class="keyword">real</span>(<span class="number">8</span>) :: start_time, end_time</span><br><span class="line">  </span><br><span class="line">  <span class="comment">! 分配矩阵内存</span></span><br><span class="line">  <span class="built_in">allocate</span>(A(N, N), B(N, N), C1(N, N), C2(N, N))</span><br><span class="line">  </span><br><span class="line">  <span class="comment">! 初始化矩阵 (示例用简单数值)</span></span><br><span class="line">  <span class="keyword">do</span> j = <span class="number">1</span>, N</span><br><span class="line">    <span class="keyword">do</span> i = <span class="number">1</span>, N</span><br><span class="line">      A(i, j) = <span class="keyword">real</span>(i + j, <span class="number">8</span>)</span><br><span class="line">      B(i, j) = <span class="keyword">real</span>(i - j, <span class="number">8</span>)</span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">! 基础三重循环实现</span></span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">cpu_time</span>(start_time)</span><br><span class="line">  <span class="keyword">call</span> matmul_naive(A, B, C1, N)</span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">cpu_time</span>(end_time)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">'(A, F6.3, A)'</span>, <span class="string">"Naive implementation:  "</span>, end_time - start_time, <span class="string">" seconds"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">! 使用Fortran内置函数验证</span></span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">cpu_time</span>(start_time)</span><br><span class="line">  C2 = <span class="built_in">matmul</span>(A, B)</span><br><span class="line">  <span class="keyword">call</span> <span class="built_in">cpu_time</span>(end_time)</span><br><span class="line">  <span class="built_in">print</span> <span class="string">'(A, F6.3, A)'</span>, <span class="string">"Built-in matmul:       "</span>, end_time - start_time, <span class="string">" seconds"</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">! 验证结果正确性</span></span><br><span class="line">  <span class="built_in">print</span> <span class="string">'(A, ES10.2)'</span>, <span class="string">"Max error: "</span>, <span class="built_in">maxval</span>(<span class="built_in">abs</span>(C1 - C2))</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">deallocate</span>(A, B, C1, C2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">contains</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">! 基础三重循环实现</span></span><br><span class="line">  <span class="function"><span class="keyword">subroutine</span></span> matmul_naive(A, B, C, n)</span><br><span class="line">    <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">in</span>)  :: A(n,n), B(n,n)</span><br><span class="line">    <span class="keyword">real</span>(<span class="number">8</span>), <span class="keyword">intent</span>(<span class="keyword">out</span>) :: C(n,n)</span><br><span class="line">    <span class="keyword">integer</span>, <span class="keyword">intent</span>(<span class="keyword">in</span>)  :: n</span><br><span class="line">    <span class="keyword">integer</span> :: i, j, k</span><br><span class="line">    </span><br><span class="line">    C = <span class="number">0.0d0</span></span><br><span class="line">    <span class="keyword">do</span> j = <span class="number">1</span>, n</span><br><span class="line">      <span class="keyword">do</span> k = <span class="number">1</span>, n</span><br><span class="line">        <span class="keyword">do</span> i = <span class="number">1</span>, n</span><br><span class="line">          C(i,j) = C(i,j) + A(i,k) * B(k,j)</span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span> matmul_naive</span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">program</span></span> matrix_multiply</span><br></pre></td></tr></tbody></table></figure><p>编译选项：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">flang-new -S -emit-llvm test.f90 -o test.ll -O3 -g</span><br></pre></td></tr></tbody></table></figure><p>通过如上编译选项生成ir</p><p>根据-g 打开调试信息，以此来定位到继续矩阵乘的实现位置</p><p><img src="https://blogofllj-1314043656.cos.ap-beijing.myqcloud.com/typora/image-20250329213625387.png" alt="image-20250329213625387"></p><p>从ir中可以可以看到，编译器进行了宽度为2的simd操作</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">.LBB0_7:</span><br><span class="line">.loc1 49 11</span><br><span class="line">movupd-48(%rdx,%rdi,8), %xmm1</span><br><span class="line">movupd-32(%rdx,%rdi,8), %xmm2</span><br><span class="line">mulpd%xmm0, %xmm1</span><br><span class="line">mulpd%xmm0, %xmm2</span><br><span class="line">movupd-48(%rbx,%rdi,8), %xmm3</span><br><span class="line">addpd%xmm1, %xmm3</span><br><span class="line">movupd-32(%rbx,%rdi,8), %xmm1</span><br><span class="line">addpd%xmm2, %xmm1</span><br><span class="line">movupd-16(%rbx,%rdi,8), %xmm2</span><br><span class="line">movupd(%rbx,%rdi,8), %xmm4</span><br><span class="line">movupd%xmm3, -48(%rbx,%rdi,8)</span><br><span class="line">movupd%xmm1, -32(%rbx,%rdi,8)</span><br><span class="line">movupd-16(%rdx,%rdi,8), %xmm1</span><br><span class="line">movupd(%rdx,%rdi,8), %xmm3</span><br><span class="line">mulpd%xmm0, %xmm1</span><br><span class="line">addpd%xmm2, %xmm1</span><br><span class="line">mulpd%xmm0, %xmm3</span><br><span class="line">addpd%xmm4, %xmm3</span><br><span class="line">movupd%xmm1, -16(%rbx,%rdi,8)</span><br><span class="line">movupd%xmm3, (%rbx,%rdi,8)</span><br><span class="line">addq$8, %rdi</span><br><span class="line">cmpq$1024, %rdi</span><br><span class="line">jne.LBB0_7</span><br></pre></td></tr></tbody></table></figure><p>从汇编中也可以看到，LLVM进行了向量化的操作。</p><p>定位到相关的pass:</p><p>我们可以知道进行向量化相关的pass主要是有两个：1.LoopVectorize.cpp 2.SLPVectorizer.cpp。这两个文件位于llvm/lib/Transforms/Vectorize目录下</p><p>这里我们就以LoopVectorize.cpp为例,SLP同理</p><p>在这个文件夹下我们可以看到很多如下的内容：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;<span class="type">bool</span>&gt; <span class="title">EnableEpilogueVectorization</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="string">"enable-epilogue-vectorization"</span>, cl::init(<span class="literal">true</span>), cl::Hidden,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">  cl::desc(<span class="string">"Enable vectorization of epilogue loops."</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>这部分就是编译选项声明的地方，简单读一下上述内容，可以发现这是与尾部向量化有关， cl::desc(“Enable vectorization of epilogue loops.”)介绍了这个选项的含义，cl::init(true)说明初始值为true 说明默认是打开的， 这里的true指的就是 EnableEpilogueVectorization，这是一个bool类型的变量。同样，我们可以通过声明一个变量来实现开关pass的效果。</p><p>我们仿造上述的实现写如下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> cl::opt&lt;<span class="type">bool</span>&gt; <span class="title">DisableLoopvec</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="string">"disable-loop-vec"</span>, cl::init(<span class="literal">false</span>), cl::Hidden,</span></span></span><br><span class="line"><span class="params"><span class="function">  cl::desc(<span class="string">"Disable loop vec"</span>))</span></span>;</span><br></pre></td></tr></tbody></table></figure><p>非常简单易懂 这是个禁用向量化的选项，默认是关闭的，选项名称叫disable-loop-vec。</p><p>好了，现在我们已经定义了一个开关pass的选项，那如何来使用呢？</p><p><img src="https://blogofllj-1314043656.cos.ap-beijing.myqcloud.com/typora/image-20250329215257974.png" alt="image-20250329215257974"></p><p>绝大多数的pass实现都是在当前pass的run函数下实现的，我们找到该函数，通过观察函数的return可以发现，当他会return PreservedAnalyses::all();或者 return PA,其中PreservedAnalyses::all()说明，声明当前 Pass <strong>未修改任何程序状态</strong>，因此所有之前的分析结果（如支配树、别名分析等）仍然有效。</p><p>因此我们秩序在已进入run函数的入口，添加如下代码：</p><p><img src="https://blogofllj-1314043656.cos.ap-beijing.myqcloud.com/typora/image-20250329215722808.png" alt="image-20250329215722808"></p><p>当我们的命令行出现我们定义的编译选项-disable-loop-vec时，DisableLoopvec的值就会设置为true，则会进去if判断内，直接不进行任何修改返回当前的ir状态。</p><p>当我们添加完上述两部分代码后，在你的build目录下 </p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">make -j 16 &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure><p>来使我们的修改生效。</p><p>对于SLP及其他的pass同理</p><p>验证：</p><p>编译选项：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">flang-new -S -emit-llvm test.f90 -o test.ll -O3 -g -mllvm -disable-loop-vec -mllvm -disable-loop-slp</span><br></pre></td></tr></tbody></table></figure><p>查看汇编可以发现</p><p>矩阵乘的实现部分没有了之前的simd操作，说明选项生成并成立了。</p><p><img src="https://blogofllj-1314043656.cos.ap-beijing.myqcloud.com/typora/image-20250329220132466.png" alt="image-20250329220132466"></p><p>总结：这篇文章主要时为LLVM Pass（以<code>LoopVectorize</code>为例）添加自定义编译选项，实现对特定优化步骤的动态控制，便于性能分析时隔离不同优化因素的影响。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>LLVM后端-理解指令选择的的DAG图以及dump输出</title>
      <link href="/2025/03/10/llvm-hou-duan-li-jie-zhi-ling-xuan-ze-de-dump-shu-chu/"/>
      <url>/2025/03/10/llvm-hou-duan-li-jie-zhi-ling-xuan-ze-de-dump-shu-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="LLVM后端-理解指令选择的的DAG图以及dump输出"><a href="#LLVM后端-理解指令选择的的DAG图以及dump输出" class="headerlink" title="LLVM后端-理解指令选择的的DAG图以及dump输出"></a>LLVM后端-理解指令选择的的DAG图以及dump输出</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文以release/19.1.0版本的LLVM源码为基础，阐述了指令选择的整体流程以及llc里常用SelectionDAG命令选项和各流程间的对应关系。另外，借助一个简单的示例呈现了指令选择的dump输出及其意义。进而，掌握指令选择的常见调试分析方法，且有助于深入探究指令选择的内部原理 。</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在进行性能调优时发现了一个非常有意思的现象，两条相似的赋值语句最终产生的汇编却截然不同，在进行分析时学到了指令选择的一些相关知识，写下此文进一步加深理解与思考。</p><blockquote><p>目标平台: AMD Ryzen 9 7950X 16-Core Processor</p><p>编译器：LLVM19.1.0</p></blockquote><p>kernel1:</p><figure class="highlight fortran"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> solve(n, l, u, i, j)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: row, col, row1, col1, x</span><br><span class="line">  <span class="keyword">integer</span> ,<span class="keyword">intent</span>(<span class="keyword">in</span>):: n</span><br><span class="line">  <span class="keyword">integer</span> :: <span class="keyword">block</span>(n, n) </span><br><span class="line">  <span class="keyword">integer</span> ,<span class="keyword">intent</span>(<span class="keyword">in</span>):: l(n), u(n), i, j</span><br><span class="line"></span><br><span class="line">  <span class="keyword">do</span> row = l(i), u(i)</span><br><span class="line">    <span class="keyword">do</span> col = l(j), u(j)</span><br><span class="line">      <span class="keyword">block</span>(col,row) = <span class="keyword">block</span>(col,row) - <span class="number">10</span>  </span><br><span class="line">      <span class="keyword">block</span>(col,row+<span class="number">1</span>) = <span class="keyword">block</span>(col,row+<span class="number">1</span>) - <span class="number">20</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></tbody></table></figure><p>kernel1生成的汇编：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">movslq%r8d, %r8</span><br><span class="line">addl$-10, -4(%rcx,%r8,4)</span><br><span class="line">addl$-20, -4(%rdx,%r8,4)</span><br><span class="line">incl%r8d</span><br><span class="line">decq%rax</span><br><span class="line">cmpq$1, %rax</span><br><span class="line">ja.LBB0_13</span><br></pre></td></tr></tbody></table></figure><p>kernel2:</p><figure class="highlight fortran"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">subroutine</span></span> solve(n, l, u, i, j)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">none</span></span><br><span class="line">  <span class="keyword">integer</span> :: row, col, row1, col1</span><br><span class="line">  <span class="keyword">integer</span> ,<span class="keyword">intent</span>(<span class="keyword">in</span>):: n</span><br><span class="line">  <span class="keyword">integer</span> :: <span class="keyword">block</span>(n, n) </span><br><span class="line">  <span class="keyword">integer</span> ,<span class="keyword">intent</span>(<span class="keyword">in</span>):: l(n), u(n), i, j</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">do</span> row = l(i), u(i)</span><br><span class="line">    <span class="keyword">do</span> col = l(j), u(j)</span><br><span class="line">      <span class="keyword">block</span>(col,row) = <span class="keyword">block</span>(col,row) - <span class="number">10</span>  </span><br><span class="line">      <span class="keyword">block</span>(col+<span class="number">1</span>,row) = <span class="keyword">block</span>(col+<span class="number">1</span>,row) - <span class="number">20</span> </span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">return</span>  </span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">end</span> <span class="function"><span class="keyword">subroutine</span></span></span><br></pre></td></tr></tbody></table></figure><p>kernel2生成的部分汇编：</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">decq%r10</span><br><span class="line">imulq%rdi, %r10</span><br><span class="line">leaq(%r9,%r10,4), %rdx</span><br><span class="line">movl-4(%rdx,%rsi,4), %esi</span><br><span class="line">addq$2, %rcx</span><br><span class="line">.p2align4, 0x90</span><br><span class="line">.LBB0_3:</span><br><span class="line">cltq</span><br><span class="line">addl$-10, %esi</span><br><span class="line">movl%esi, -4(%rdx,%rax,4)</span><br><span class="line">incl%eax</span><br><span class="line">movslq%eax, %rdi</span><br><span class="line">movl-4(%rdx,%rdi,4), %esi</span><br><span class="line">addl$-20, %esi</span><br><span class="line">movl%esi, -4(%rdx,%rdi,4)</span><br><span class="line">decq%rcx</span><br><span class="line">cmpq$1, %rcx</span><br><span class="line">ja.LBB0_3</span><br></pre></td></tr></tbody></table></figure><p>重点对block赋值语句生成的汇编可以发现kernel1生成的汇编是一条addl的形式，而kernel2生成汇编的是mov-addl-mov的形式，并且关注kernel2生成的这一部分可以发现这三条指令是完全可以写成addl的形式的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">movl-4(%rdx,%rdi,4), %esi</span><br><span class="line">addl$-20, %esi</span><br><span class="line">movl%esi, -4(%rdx,%rdi,4)</span><br></pre></td></tr></tbody></table></figure><p>因此对llvm指令选择的机制产生了怀疑，其实最终的解释原因非常简单，甚至和指令选择并无太大的关系，归根结底，是寄存器复用优化与折叠优化的矛盾所致。感兴趣的同学可以分析一下。</p><p>好了，由于本篇的重点在于指令选择的整体流程以及llc里常用SelectionDAG命令选项和各流程间的对应关系，因此不会在上述例子进行过多的阐述，那么我们正片开始！</p><h2 id="指令选择的整体输出"><a href="#指令选择的整体输出" class="headerlink" title="指令选择的整体输出"></a>指令选择的整体输出</h2><p>指令选择是将LLVM IR转换为代表目标指令的SelectDAG节点-SDNode.它是由一些较小的阶段组成，这些阶段如下图所示：</p><p><img src="https://blogofllj-1314043656.cos.ap-beijing.myqcloud.com/typora/image-20250330135337155.png" alt="image-20250307223609552"></p><p>为了直观地展示<code>llc</code>中常用 SelectionDAG 命令选项与各阶段之间的对应关系，图中除了指令选择阶段<code>(1)~(10)</code>以外，还包括了指令调度阶段<code>(11)</code>。</p><p>查看各阶段输出结果的常见方式有以下两种：</p><ul><li>通过<code>-debug-only=isel</code>命令选项查看所有阶段的文本输出（对应图中绿色字体）。比如：<code>Initial selection DAG:</code>后面的 SelectionDAG 对应阶段<code>(1)</code>的文本输出结果。</li><li>通过<code>-view-dag-combine1-dags</code>、<code>-view-legalize-dags</code>等命令选项（对应图中紫色字体）查看指定阶段的可视化输出。比如：<code>-view-dag-combine1-dags</code>用于查看阶段<code>(1)</code>的可视化输出结果。另外，可以通过<code>-filter-view-dags</code>命令选项指定允许可视化的基本块。比如：<code>-filter-view-dags=if_else -view-sched-dags</code>表示只可视化基本块<code>if_else</code>在阶段<code>(10)</code>的输出结果。</li></ul><p><strong>需要注意的是：</strong></p><ul><li>如果阶段<code>(3)</code>——<code>Type Legalization</code>未修改 SelectionDAG，那么<code>-view-dag-combine-lt-dags</code>命令选项不会输出其可视化结果。并且，阶段<code>(4)</code>——<code>DAG Combining</code>也不会执行。相应地，<code>Optimized type-legalized selection DAG:</code>不会出现在文本输出结果中。</li><li>如果阶段<code>(5)</code>——<code>Vector Legalization</code>未修改 SelectionDAG，那么阶段<code>(6)</code>——<code>Type Legalization 2</code>和阶段<code>(7)</code>——<code>DAG Combining</code>都不会执行。并且，<code>Vector-legalized selection DAG:</code>、<code>Vector/type-legalized selection DAG:</code>、<code>Optimized vector-legalized selection DAG:</code>都不会出现在文本输出结果中。除此之外，<code>-view-dag-combine-lt-dags</code>命令选项也不会输出阶段<code>(6)</code>的可视化结果。然而，<code>-view-legalize-dags</code>命令选项总是可用的。</li><li><code>-filter-view-dags</code>命令选项指定允许可视化的基本块,这里的基本块指的是IR的基本块的名称，并且在大型程序中受编译选项如：内联的影响，部分基本块的名称是无法通过<code>-filter-view-dags</code>所识别的,遇到一个复杂的工程问题，最好抽象成一个小例子来进行解决，否则DAG将会异常复杂难懂。</li></ul><p><em>注：</em></p><ul><li><p>指令选择的整体流程见<code>SelectionDAGISel::CodeGenAndEmitDAG()</code>函数的实现（定义在 llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp 文件中）。</p></li><li><p><code>llc</code>中所有的 SelectionDAG 命令选项可以通过<code>llc --help-list-hidden | grep dags</code>命令进行查看。其输出结果如下：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">--help-list-hidden | grep dags</span><br><span class="line"> --filter-view-dags=&lt;string&gt;                                                - Only display the basic block whose name matches this for all view-*-dags options</span><br><span class="line"> --misched-print-dags                                                       - Print schedule DAGs</span><br><span class="line"> --view-block-freq-propagation-dags=&lt;value&gt;                                 - Pop up a window to show a dag displaying how block frequencies propagation through the CFG.</span><br><span class="line"> --view-dag-combine-lt-dags                                                 - Pop up a window to show dags before the post legalize types dag combine pass</span><br><span class="line"> --view-dag-combine1-dags                                                   - Pop up a window to show dags before the first dag combine pass</span><br><span class="line"> --view-dag-combine2-dags                                                   - Pop up a window to show dags before the second dag combine pass</span><br><span class="line"> --view-isel-dags                                                           - Pop up a window to show isel dags as they are selected</span><br><span class="line"> --view-legalize-dags                                                       - Pop up a window to show dags before legalize</span><br><span class="line"> --view-legalize-types-dags                                                 - Pop up a window to show dags before legalize types</span><br><span class="line"> --view-machine-block-freq-propagation-dags=&lt;value&gt;                         - Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.</span><br><span class="line"> --view-misched-dags                                                        - Pop up a window to show MISched dags after they are processed</span><br><span class="line"> --view-sched-dags                                                          - Pop up a window to show sched dags as they are processed</span><br><span class="line"> --view-sunit-dags                                                          - Pop up a window to show SUnit dags after they are processed</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="查看指令选择的输出结果"><a href="#查看指令选择的输出结果" class="headerlink" title="查看指令选择的输出结果"></a>查看指令选择的输出结果</h2><h3 id="以一段IR作为示例程序："><a href="#以一段IR作为示例程序：" class="headerlink" title="以一段IR作为示例程序："></a>以一段IR作为示例程序：</h3><p>test.ll</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">; ModuleID = 'FIRModule'</span><br><span class="line">source_filename = "FIRModule"</span><br><span class="line">target datalayout = "e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"</span><br><span class="line">target triple = "x86_64-unknown-linux-gnu"</span><br><span class="line"></span><br><span class="line">; Function Attrs: nofree norecurse nosync nounwind memory(argmem: read)</span><br><span class="line">define void @solve_(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2, ptr nocapture readonly %3, ptr nocapture readonly %4) local_unnamed_addr #0 {</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">6 = load i32, ptr %0, align 4, !tbaa !3</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">7 = <span class="built_in">tail</span> call i32 @llvm.smax.i32(i32 %6, i32 0)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">8 = zext nneg i32 %7 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">9 = mul nuw nsw i64 %8, %8</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">10 = alloca i32, i64 %9, align 4</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">11 = load i32, ptr %3, align 4, !tbaa !9</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">12 = sext i32 %11 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">13 = add nsw i64 %12, -1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">14 = getelementptr i32, ptr %1, i64 %13</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">15 = load i32, ptr %14, align 4, !tbaa !11</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">16 = sext i32 %15 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">17 = getelementptr i32, ptr %2, i64 %13</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">18 = load i32, ptr %17, align 4, !tbaa !13</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">19 = sext i32 %18 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">reass.sub = sub nsw i64 %19, %16</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">20 = icmp sgt i64 %reass.sub, -1</span></span><br><span class="line">  br i1 %20, label %.lr.ph56, label %._crit_edge57</span><br><span class="line"></span><br><span class="line">.lr.ph56:                                         ; preds = %5</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">21 = load i32, ptr %4, align 4, !tbaa !15</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">22 = sext i32 %21 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">23 = add nsw i64 %22, -1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">24 = getelementptr i32, ptr %1, i64 %23</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">25 = load i32, ptr %24, align 4, !tbaa !11</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">26 = sext i32 %25 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">27 = getelementptr i32, ptr %2, i64 %23</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">28 = load i32, ptr %27, align 4, !tbaa !13</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">29 = sext i32 %28 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">reass.sub58 = sub nsw i64 %29, %26</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">30 = add nsw i64 %reass.sub58, 1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">31 = icmp sgt i64 %reass.sub58, -1</span></span><br><span class="line">  br i1 %31, label %.lr.ph.us.preheader, label %._crit_edge57</span><br><span class="line"></span><br><span class="line">.lr.ph.us.preheader:                              ; preds = %.lr.ph56</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">32 = add nuw nsw i64 %reass.sub, 1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">invariant.gep = getelementptr i8, ptr %10, i64 -4</span></span><br><span class="line">  br label %.lr.ph.us</span><br><span class="line"></span><br><span class="line">.lr.ph.us:                                        ; preds = %.lr.ph.us.preheader, %._crit_edge.us</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">33 = phi i64 [ %51, %._crit_edge.us ], [ %32, %.lr.ph.us.preheader ]</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">34 = phi i32 [ %50, %._crit_edge.us ], [ %15, %.lr.ph.us.preheader ]</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">35 = sext i32 %34 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">36 = add nsw i64 %35, -1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">37 = mul nsw i64 %36, %8</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">gep = getelementptr i32, ptr %invariant.gep, i64 %37</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">gep.us.phi.trans.insert = getelementptr i32, ptr %gep, i64 %26</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">.pre = load i32, ptr %gep.us.phi.trans.insert, align 4, !tbaa !17</span></span><br><span class="line">  br label %38</span><br><span class="line"></span><br><span class="line">38:                                               ; preds = %.lr.ph.us, %38</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">39 = phi i32 [ %.pre, %.lr.ph.us ], [ %47, %38 ]</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">40 = phi i64 [ %30, %.lr.ph.us ], [ %48, %38 ]</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">41 = phi i32 [ %25, %.lr.ph.us ], [ %44, %38 ]</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">42 = sext i32 %41 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">gep.us = getelementptr i32, ptr %gep, i64 %42</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">43 = add i32 %39, -10</span></span><br><span class="line">  store i32 %43, ptr %gep.us, align 4, !tbaa !17</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">44 = add i32 %41, 1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">45 = sext i32 %44 to i64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">gep54.us = getelementptr i32, ptr %gep, i64 %45</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">46 = load i32, ptr %gep54.us, align 4, !tbaa !21</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">47 = add i32 %46, -20</span></span><br><span class="line">  store i32 %47, ptr %gep54.us, align 4, !tbaa !21</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">48 = add nsw i64 %40, -1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">49 = icmp sgt i64 %40, 1</span></span><br><span class="line">  br i1 %49, label %38, label %._crit_edge.us</span><br><span class="line"></span><br><span class="line">._crit_edge.us:                                   ; preds = %38</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">50 = add i32 %34, 1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">51 = add nsw i64 %33, -1</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">52 = icmp sgt i64 %33, 1</span></span><br><span class="line">  br i1 %52, label %.lr.ph.us, label %._crit_edge57</span><br><span class="line"></span><br><span class="line">._crit_edge57:                                    ; preds = %._crit_edge.us, %.lr.ph56, %5</span><br><span class="line">  ret void</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)</span><br><span class="line">declare i32 @llvm.smax.i32(i32, i32) #1</span><br><span class="line"></span><br><span class="line">attributes #0 = { nofree norecurse nosync nounwind memory(argmem: read) "target-cpu"="x86-64" }</span><br><span class="line">attributes #1 = { nocallback nofree nosync nounwind speculatable willreturn memory(none) }</span><br><span class="line"></span><br><span class="line">!llvm.module.flags = !{!0, !1, !2}</span><br><span class="line"></span><br><span class="line">!0 = !{i32 2, !"Debug Info Version", i32 3}</span><br><span class="line">!1 = !{i32 8, !"PIC Level", i32 2}</span><br><span class="line">!2 = !{i32 7, !"PIE Level", i32 2}</span><br><span class="line">!3 = !{!4, !4, i64 0}</span><br><span class="line">!4 = !{!"dummy arg data/_QFsolveEn", !5, i64 0}</span><br><span class="line">!5 = !{!"dummy arg data", !6, i64 0}</span><br><span class="line">!6 = !{!"any data access", !7, i64 0}</span><br><span class="line">!7 = !{!"any access", !8, i64 0}</span><br><span class="line">!8 = !{!"Flang function root _QPsolve"}</span><br><span class="line">!9 = !{!10, !10, i64 0}</span><br><span class="line">!10 = !{!"dummy arg data/_QFsolveEi", !5, i64 0}</span><br><span class="line">!11 = !{!12, !12, i64 0}</span><br><span class="line">!12 = !{!"dummy arg data/_QFsolveEl", !5, i64 0}</span><br><span class="line">!13 = !{!14, !14, i64 0}</span><br><span class="line">!14 = !{!"dummy arg data/_QFsolveEu", !5, i64 0}</span><br><span class="line">!15 = !{!16, !16, i64 0}</span><br><span class="line">!16 = !{!"dummy arg data/_QFsolveEj", !5, i64 0}</span><br><span class="line">!17 = !{!18, !18, i64 0}</span><br><span class="line">!18 = !{!"any data access", !19, i64 0}</span><br><span class="line">!19 = !{!"any access", !20, i64 0}</span><br><span class="line">!20 = !{!"Flang function root _QFsolvePfunc_current"}</span><br><span class="line">!21 = !{!22, !22, i64 0}</span><br><span class="line">!22 = !{!"any data access", !23, i64 0}</span><br><span class="line">!23 = !{!"any access", !24, i64 0}</span><br><span class="line">!24 = !{!"Flang function root _QFsolvePfunc_next"}</span><br></pre></td></tr></tbody></table></figure><h3 id="查看指令选择的文本输出："><a href="#查看指令选择的文本输出：" class="headerlink" title="查看指令选择的文本输出："></a>查看指令选择的文本输出：</h3><p>执行如下命令，将指令选择输出到指定文件里：</p><p><code>llc  test.ll --debug-only=isel &gt; test.log 2&gt;&amp;1</code></p><p>我这里的是x86架构，针对不同的架构你可以添加选项-march-x86/riscv32等</p><p>输出结果详见附录.</p><h3 id="查看指令选择的可视化输出："><a href="#查看指令选择的可视化输出：" class="headerlink" title="查看指令选择的可视化输出："></a>查看指令选择的可视化输出：</h3><p>1.z准备可视化数据，比如打印指令选择前的DAG图</p><p><code>llc -view-dag-isel-dags  test.ll -o test.s</code></p><p>输出结果如下所示：</p><p><img src="https://blogofllj-1314043656.cos.ap-beijing.myqcloud.com/typora/image-20250310210733379.png" alt="image-20250310210733379"></p><p>可以发现，可视化数据保存在/tep/dagxxx文件中</p><p>2.可视化输出结果</p><p>可以使用dot命令，dot支持多种可视化格式（需安装graphviz）</p><p>dot -Tpng /tep/dagxxx.dot -o test.png</p><p>当然也可以写个py脚本来直接生成：</p><figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">render_dot_with_system</span>(<span class="params">dot_file, output_file, <span class="built_in">format</span>=<span class="string">'png'</span></span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    使用系统安装的 Graphviz 渲染</span></span><br><span class="line"><span class="string">    需要提前安装 Graphviz (apt install graphviz / brew install graphviz)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(dot_file):</span><br><span class="line">        <span class="keyword">raise</span> FileNotFoundError(<span class="string">f"DOT 文件不存在: <span class="subst">{dot_file}</span>"</span>)</span><br><span class="line">    </span><br><span class="line">    cmd = [<span class="string">'dot'</span>, <span class="string">'-T'</span>, <span class="built_in">format</span>, dot_file, <span class="string">'-o'</span>, output_file]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        subprocess.run(cmd, check=<span class="literal">True</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"成功生成: <span class="subst">{output_file}</span>"</span>)</span><br><span class="line">    <span class="keyword">except</span> subprocess.CalledProcessError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f"渲染失败: <span class="subst">{e}</span>"</span>)</span><br><span class="line">    <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"未找到 'dot' 命令，请先安装 Graphviz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    dot_path = <span class="string">"/nosche.dot"</span>    <span class="comment"># 输入 .dot 文件路径</span></span><br><span class="line">    output_path = <span class="string">"nosche.png"</span> <span class="comment"># 输出图片路径</span></span><br><span class="line">    render_dot_with_system(dot_path, output_path, <span class="built_in">format</span>=<span class="string">'png'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="理解指令选择的文本输出"><a href="#理解指令选择的文本输出" class="headerlink" title="理解指令选择的文本输出"></a>理解指令选择的文本输出</h2><p>指令选择中各阶段的文本输出都是由<code>llvm::SelectionDAG::dump()</code>函数打印的。该函数的声明位于 llvm/include/llvm/CodeGen/SelectionDAG.h 文件，其定义位于 llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp 文件。</p><p>类<code>llvm::SelectionDAG</code>是一个有向无环图（Directed-Acyclic-Graph，DAG），用于表示每个基本块。DAG 的节点为<code>llvm::SDNode</code>类（定义在 llvm/include/llvm/CodeGen/SelectionDAGNodes.h 文件中）的实例，每个节点对应一条指令或一个操作数。DAG 的边为<code>llvm::SDValue</code>类的实例，作为节点的操作数（即节点的每个操作数都是一条指向其它节点的边）；每条边由一个<code>&lt;SDNode, unsigned&gt;</code>键值对构成，Key 表示所指向的节点（即定义操作数的节点，不妨称为<code>Def-SDNode</code>），Value 是一个索引（从 0 开始）表示使用<code>Def-SDNode</code>所定义的哪个值；每条边决定了两个节点在指令调度后必须满足何种（在基本块内的）先后出现顺序。</p><p>DAG 的节点既可以同时定义多个值，也可以同时包含多个操作数。DAG 节点所定义的每个值都关联一个<code>MVT</code>（Machine Value Type），用于表示该值的类型。常见的类型有如下三种（定义在 llvm/include/llvm/Support/MachineValueType.h 文件中）：</p><ul><li><code>Concrete Value</code>类型，表示具体的数据类型。比如：<code>llvm::MVT::i8</code>、<code>llvm::MVT::f16</code>、<code>llvm::MVT::v1i1</code>等，对应文本输出和 DAG 中的<code>i8</code>、<code>f16</code>等。</li><li><code>Other</code>类型，对应的枚举值为<code>llvm::MVT::Other</code>，对应文本输出和 DAG 中的<code>ch</code>。</li><li><code>Glue</code>类型，对应的枚举值为<code>llvm::MVT::Glue</code>，对应文本输出和 DAG 中的<code>glue</code>。</li></ul><p>DAG 的边用于表示两个节点之间的依赖关系：数据依赖或控制依赖。如果节点<code>A</code>依赖于节点<code>B</code>记作<code>A-&gt;B</code>（意味着节点<code>B</code>必须位于节点<code>A</code>的前面）；那么边的含义可以分为如下三种：</p><ul><li>表示数据依赖，称为<code>regular-edge</code>。对应 DAG 中的<code>从节点A指向节点B的黑色实线</code>。并且，箭头所指向的值（由节点<code>B</code>定义）的<code>MVT</code>类型一定是<code>Concrete Value</code>。</li><li>表示控制依赖并且节点<code>A</code>与<code>B</code>之间允许插入其它节点，称为<code>chain-edge</code>。对应 DAG 中的<code>从节点A指向节点B的蓝色虚线</code>。并且，箭头所指向的值（由节点<code>B</code>定义）的<code>MVT</code>类型一定是<code>Other</code>。</li><li>表示控制依赖并且节点<code>A</code>与<code>B</code>之间不允许插入其它节点（即节点<code>B</code>后面的第一个节点必须是<code>A</code>），称为<code>glue-edge</code>。对应 DAG 中的<code>从节点A指向节点B的红色实线</code>。并且，箭头所指向的值（由节点<code>B</code>定义）的<code>MVT</code>类型一定是<code>Glue</code>。</li></ul><p>接下来，以阶段<code>(10)</code>——<code>Instruction Selection</code>为例，说明指令选择的文本输出所表示的含义。</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">114 Selected selection DAG: %bb.0 'test:'</span><br><span class="line">115 SelectionDAG has 9 nodes:</span><br><span class="line">116   t0: ch = EntryToken</span><br><span class="line">117       t2: i32,ch = CopyFromReg t0, Register:i32 %0</span><br><span class="line">118       t4: i32,ch = CopyFromReg t0, Register:i32 %1</span><br><span class="line">119     t5: i32 = ADD t2, t4</span><br><span class="line">120   t7: ch,glue = CopyToReg t0, Register:i32 $x10, t5</span><br><span class="line">121   t8: ch = PseudoRET Register:i32 $x10, t7, t7:1</span><br></pre></td></tr></tbody></table></figure><ul><li><p>第 114 行，<code>%bb.0</code>是由 LLVM 内部为该基本块定义的标签名。<code>'test:'</code>表示该基本块对应的<code>函数名:标签名</code>，这里的函数名和标签名都是在 IR 代码中定义的。</p></li><li><p>第 115 行，表示该基本块所对应的 DAG 中包含<code>t0~t8</code> 9 个节点。这些节点的节点 ID（即<code>llvm::SDNode::PersistentId</code>字段）值为<code>0~8</code>。比如：<code>t0</code>表示节点 ID 为 0 的节点。</p></li><li><p>第 116 行，<code>t0:</code>表示该节点的节点 ID 为 0 （这里的节点 ID 对应源代码中的<code>SDNode::PersistentId</code>）。</p><ul><li>等号左侧的<code>ch</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::Other</code>，该值的索引为 0。</li><li>等号右侧的<code>EntryToken</code>表示该节点是一个特殊的标记节点（对应的操作码为<code>llvm::ISD::EntryToken</code>）。</li></ul></li><li><p>第 117 行， <code>t2:</code>表示该节点的节点 ID 为 2 。</p><ul><li><p>等号左侧的<code>i32,ch</code>表示该节点定义了两个值，索引为 0 的值的<code>MVT</code>类型为<code>llvm::MVT::i32</code>；索引为 1 的值的<code>MVT</code>类型为<code>llvm::MVT::Other</code>。</p></li><li><p>等号右侧的<code>CopyFromReg</code>表示该节点是读寄存器操作（对应的操作码为<code>llvm::ISD::CopyFromReg</code>）。</p></li><li><p>等号右侧的<code>t0, Register:i32 %0</code>表示该节点包含两个操作数，索引为 0 的操作数表示一条指向<code>t0</code>节点所定义的索引为 0 的值的<code>chain-edge</code>（即省略了<code>t0:0</code>中的<code>:0</code>）；索引为 1 的操作数表示一条指向<code>t1</code>节点所定义的索引为 0 的值的<code>regular-edge</code>。</p><p>实际上，<code>Register:i32 %0</code>是 DAG 中的<code>t1</code>节点，其中冒号左侧的<code>Register</code>表示该节点是寄存器（对应的操作码为<code>llvm::ISD::Register</code>）；冒号右侧的<code>i32</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::i32</code>；<code>%0</code>以<code>%</code>开头表示虚拟寄存器<code>%0</code>，该节点在文本输出时被折叠打印了。如果不折叠打印，那么该行的输出结果应该为<code>t2: i32,ch = CopyFromReg t0, t1</code>。</p></li><li><p>相比于节点<code>t5</code>，节点<code>t2</code>缩进了两个空格，表示节点<code>t2</code>仅被节点<code>t5</code>使用了（即节点<code>t2</code>的使用者只有节点<code>t5</code>，意味着节点<code>t2</code>必须位于节点<code>t5</code>的前面）。<strong>如果节点<code>t2</code>的使用者有多个，那么该节点不会进行缩进打印</strong>。</p></li></ul></li><li><p>第 118 行，<code>t4:</code>表示该节点的节点 ID 为 4 。同样地，节点<code>t4</code>也仅被节点<code>t5</code>使用了。</p></li><li><p>第 119 行，<code>t5:</code>表示该节点的节点 ID 为 5 。</p><ul><li>等号左侧的<code>i32</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::i32</code>，该值的索引为 0。</li><li>等号右侧的<code>ADD</code>表示该节点是机器指令<code>add</code>（对应的操作码为<code>llvm::RISCV::ADD</code>）。</li><li>等号右侧的<code>t2, t4</code>表示该节点包含两个操作数，索引为 0 的操作数表示一条指向<code>t2</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（省略了<code>t2:0</code>中的<code>:0</code>）；索引为 1 的操作数表示一条指向<code>t4</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（省略了<code>t4:0</code>中的<code>:0</code>）。</li><li>同样地，节点<code>t5</code>仅被节点<code>t7</code>使用了。</li></ul></li><li><p>第 120 行，<code>t7:</code>表示该节点的节点 ID 为 7 。</p><ul><li><p>等号左侧的<code>ch,glue</code>表示该节点定义了两个值，索引为 0 的值的<code>MVT</code>类型为<code>llvm::MVT::Other</code>；索引为 1 的值的<code>MVT</code>类型为<code>llvm::MVT::Glue</code>。</p></li><li><p>等号右侧的<code>CopyToReg</code>表示该节点是写寄存器操作（对应的操作码为<code>llvm::ISD::CopyToReg</code>）。</p></li><li><p>等号右侧的<code>t0, Register:i32 $x10, t5</code>表示该节点包含三个操作数，索引为 0 的操作数表示一条指向<code>t0</code>节点所定义的索引为 0 的值的<code>chain-edge</code>（省略了<code>t0:0</code>中的<code>:0</code>）；索引为 1 的操作数表示一条指向<code>t6</code>节点所定义的索引为 0 的值的<code>regular-edge</code>；索引为 2 的操作数表示一条指向<code>t5</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（省略了<code>t5:0</code>中的<code>:0</code>）。</p><p>实际上，<code>Register:i32 $x10</code>是 DAG 中的<code>t6</code>节点，其中冒号左侧的<code>Register</code>表示该节点是寄存器（对应的操作码为<code>llvm::ISD::Register</code>）；冒号右侧的<code>i32</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::i32</code>；<script type="math/tex">x10`以`</script>开头表示物理寄存器<code>x10</code>，该节点在文本输出时被折叠打印了。如果不折叠打印，那么该行的输出结果应该为<code>t7: ch,glue = CopyToReg t0, t6, t5</code>。</p></li></ul></li><li><p>第 121 行，<code>t8:</code>表示该节点的节点 ID 为 8 。</p><ul><li>等号左侧的<code>ch</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::Other</code>，该值的索引为 0。</li><li>等号右侧的<code>PseudoRET</code>表示该节点是伪机器指令<code>ret</code>（对应的操作码为<code>llvm::RISCV::PseudoRET</code>）。</li><li>等号右侧的<code>Register:i32 $x10, t7, t7:1</code>表示该节点包含三个操作数，索引为 0 的操作数表示一条指向<code>t6</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（被折叠打印了）；索引为 1 的操作数表示一条指向<code>t7</code>节点所定义的索引为 0 的值的<code>chain-edge</code>（省略了<code>t7:0</code>中的<code>:0</code>）；索引为 2 的操作数表示一条指向<code>t7</code>节点所定义的索引为 1 的值的<code>glue-edge</code>。</li></ul></li></ul><h2 id="理解指令选择的可视化输出"><a href="#理解指令选择的可视化输出" class="headerlink" title="理解指令选择的可视化输出"></a>理解指令选择的可视化输出</h2><p>指令选择中各阶段的可视化输出都是由<code>llvm::SelectionDAG::viewGraph()</code>函数打印的。该函数的声明位于 llvm/include/llvm/CodeGen/SelectionDAG.h 文件，其定义位于 llvm/lib/CodeGen/SelectionDAG/SelectionDAGPrinter.cpp 文件。</p><p>接下来，以阶段<code>(10)</code>——<code>Instruction Selection</code>为例，说明指令选择的可视化输出所表示的含义。</p><p><img src="D:\Desktop\after\yessche.png" alt="yessche"></p><ul><li>根节点<code>GraphRoot</code>，实际上 DAG 中不存在该节点（用椭圆形表示）。该节点与节点<code>t8</code>之间有一条<code>chain-edge</code>，表示节点<code>t40</code>必须作为基本块内的最后一条指令。</li><li>节点<code>t40</code>，DAG 中实际存在该节点（用圆角矩形表示）。该节点分为四部分，从上到下依次为：操作数的索引、操作码、节点 ID、节点所定义值的<code>MVT</code>类型。每部分的含义大家顺下来文本输出这里应该更加直观的理解，这里不在叙述</li></ul><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p>执行debug-only=isel的输出文件：</p><figure class="highlight shell"><table><tbody><tr><td class="code"><pre><span class="line">FastISel is disabled</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">=== solve_</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 55 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t10: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">    t15: i32 = smax t13, Constant:i32&lt;0&gt;</span><br><span class="line">  t16: i64 = zero_extend nneg t15</span><br><span class="line">          t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">        t21: i64 = mul t19, Constant:i64&lt;4&gt;</span><br><span class="line">      t23: i64 = add nuw t21, Constant:i64&lt;15&gt;</span><br><span class="line">    t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;</span><br><span class="line">          t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">        t29: i32,ch = load&lt;(load (s32) from %ir.3, !tbaa !9)&gt; t26:1, t8, undef:i64</span><br><span class="line">      t30: i64 = sign_extend t29</span><br><span class="line">    t32: i64 = add nsw t30, Constant:i64&lt;-1&gt;</span><br><span class="line">  t34: i64 = shl t32, Constant:i64&lt;2&gt;</span><br><span class="line">      t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t35: i64 = add t4, t34</span><br><span class="line">  t36: i32,ch = load&lt;(load (s32) from %ir.14, !tbaa !11)&gt; t26:1, t35, undef:i64</span><br><span class="line">          t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">        t40: i64 = add t6, t34</span><br><span class="line">      t41: i32,ch = load&lt;(load (s32) from %ir.17, !tbaa !13)&gt; t26:1, t40, undef:i64</span><br><span class="line">    t42: i64 = sign_extend t41</span><br><span class="line">    t39: i64 = sign_extend t36</span><br><span class="line">  t43: i64 = sub nsw t42, t39</span><br><span class="line">        t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">        t28: ch = CopyToReg t0, Register:i64 %1, t26</span><br><span class="line">        t38: ch = CopyToReg t0, Register:i32 %2, t36</span><br><span class="line">        t45: ch = CopyToReg t0, Register:i64 %3, t43</span><br><span class="line">      t51: ch = TokenFactor t18, t28, t38, t45, t26:1</span><br><span class="line">        t47: i1 = setcc t43, Constant:i64&lt;-1&gt;, setgt:ch</span><br><span class="line">      t49: i1 = xor t47, Constant:i1&lt;-1&gt;</span><br><span class="line">    t52: ch = brcond t51, t49, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t54: ch = br t52, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 49 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">    t15: i32 = smax t13, Constant:i32&lt;0&gt;</span><br><span class="line">  t16: i64 = zero_extend nneg t15</span><br><span class="line">          t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">        t68: i64 = shl t19, Constant:i8&lt;2&gt;</span><br><span class="line">      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;</span><br><span class="line">    t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;</span><br><span class="line">        t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">      t40: i64 = add t6, t65</span><br><span class="line">    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t26:1, t40, undef:i64</span><br><span class="line">  t43: i64 = sub nsw t60, t61</span><br><span class="line">      t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t35: i64 = add t4, t65</span><br><span class="line">  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t26:1, t35, undef:i64</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t26:1, t8, undef:i64</span><br><span class="line">    t64: i64 = shl t66, Constant:i64&lt;2&gt;</span><br><span class="line">  t65: i64 = add t64, Constant:i64&lt;-4&gt;</span><br><span class="line">        t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">        t28: ch = CopyToReg t0, Register:i64 %1, t26</span><br><span class="line">          t62: i32 = truncate t61</span><br><span class="line">        t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line">        t45: ch = CopyToReg t0, Register:i64 %3, t43</span><br><span class="line">      t51: ch = TokenFactor t18, t28, t38, t45, t26:1</span><br><span class="line">      t59: i1 = setcc t43, Constant:i64&lt;0&gt;, setlt:ch</span><br><span class="line">    t57: ch = brcond t51, t59, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t54: ch = br t57, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 51 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">    t15: i32 = smax t13, Constant:i32&lt;0&gt;</span><br><span class="line">  t16: i64 = zero_extend nneg t15</span><br><span class="line">          t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">        t68: i64 = shl t19, Constant:i8&lt;2&gt;</span><br><span class="line">      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;</span><br><span class="line">    t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;</span><br><span class="line">        t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">      t40: i64 = add t6, t65</span><br><span class="line">    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t26:1, t40, undef:i64</span><br><span class="line">  t43: i64 = sub nsw t60, t61</span><br><span class="line">      t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t35: i64 = add t4, t65</span><br><span class="line">  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t26:1, t35, undef:i64</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t26:1, t8, undef:i64</span><br><span class="line">    t64: i64 = shl t66, Constant:i64&lt;2&gt;</span><br><span class="line">  t65: i64 = add t64, Constant:i64&lt;-4&gt;</span><br><span class="line">        t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">        t28: ch = CopyToReg t0, Register:i64 %1, t26</span><br><span class="line">          t62: i32 = truncate t61</span><br><span class="line">        t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line">        t45: ch = CopyToReg t0, Register:i64 %3, t43</span><br><span class="line">      t51: ch = TokenFactor t18, t28, t38, t45, t26:1</span><br><span class="line">        t69: i8 = setcc t43, Constant:i64&lt;0&gt;, setlt:ch</span><br><span class="line">      t72: i8 = and t69, Constant:i8&lt;1&gt;</span><br><span class="line">    t57: ch = brcond t51, t72, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t54: ch = br t57, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized type-legalized selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 49 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">    t15: i32 = smax t13, Constant:i32&lt;0&gt;</span><br><span class="line">  t16: i64 = zero_extend nneg t15</span><br><span class="line">          t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">        t68: i64 = shl t19, Constant:i8&lt;2&gt;</span><br><span class="line">      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;</span><br><span class="line">    t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;</span><br><span class="line">        t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">      t40: i64 = add t6, t65</span><br><span class="line">    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t26:1, t40, undef:i64</span><br><span class="line">  t43: i64 = sub nsw t60, t61</span><br><span class="line">      t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t35: i64 = add t4, t65</span><br><span class="line">  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t26:1, t35, undef:i64</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t26:1, t8, undef:i64</span><br><span class="line">    t64: i64 = shl t66, Constant:i64&lt;2&gt;</span><br><span class="line">  t65: i64 = add t64, Constant:i64&lt;-4&gt;</span><br><span class="line">        t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">        t28: ch = CopyToReg t0, Register:i64 %1, t26</span><br><span class="line">          t62: i32 = truncate t61</span><br><span class="line">        t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line">        t45: ch = CopyToReg t0, Register:i64 %3, t43</span><br><span class="line">      t51: ch = TokenFactor t18, t28, t38, t45, t26:1</span><br><span class="line">      t69: i8 = setcc t43, Constant:i64&lt;0&gt;, setlt:ch</span><br><span class="line">    t57: ch = brcond t51, t69, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t54: ch = br t57, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 54 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">      t88: i32 = X86ISD::CMP t13, Constant:i32&lt;0&gt;</span><br><span class="line">    t91: i32 = X86ISD::CMOV Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t88</span><br><span class="line">  t16: i64 = zero_extend nneg t91</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t82, t8, undef:i64</span><br><span class="line">    t64: i64 = shl t66, Constant:i8&lt;2&gt;</span><br><span class="line">  t65: i64 = add t64, Constant:i64&lt;-4&gt;</span><br><span class="line">      t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t35: i64 = add t4, t65</span><br><span class="line">  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t82, t35, undef:i64</span><br><span class="line">        t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">      t40: i64 = add t6, t65</span><br><span class="line">    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t82, t40, undef:i64</span><br><span class="line">  t73: i64,i32 = X86ISD::SUB t60, t61</span><br><span class="line">    t77: ch,glue = callseq_start t13:1, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;</span><br><span class="line">  t79: i64,ch = CopyFromReg t77, Register:i64 $rsp</span><br><span class="line">          t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">        t68: i64 = shl t19, Constant:i8&lt;2&gt;</span><br><span class="line">      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;</span><br><span class="line">    t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">  t80: i64 = sub t79, t25</span><br><span class="line">    t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80</span><br><span class="line">  t82: ch,glue = callseq_end t81, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;</span><br><span class="line">        t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">        t28: ch = CopyToReg t0, Register:i64 %1, t80</span><br><span class="line">          t62: i32 = truncate t61</span><br><span class="line">        t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line">        t45: ch = CopyToReg t0, Register:i64 %3, t73</span><br><span class="line">      t51: ch = TokenFactor t18, t28, t38, t45, t82</span><br><span class="line">    t75: ch = X86ISD::BRCOND t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t73:1</span><br><span class="line">  t54: ch = br t75, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 54 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">      t88: i32 = X86ISD::CMP t13, Constant:i32&lt;0&gt;</span><br><span class="line">    t91: i32 = X86ISD::CMOV Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t88</span><br><span class="line">  t16: i64 = zero_extend nneg t91</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t82, t8, undef:i64</span><br><span class="line">    t64: i64 = shl t66, Constant:i8&lt;2&gt;</span><br><span class="line">  t65: i64 = add t64, Constant:i64&lt;-4&gt;</span><br><span class="line">      t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t35: i64 = add t4, t65</span><br><span class="line">  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t82, t35, undef:i64</span><br><span class="line">        t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">      t40: i64 = add t6, t65</span><br><span class="line">    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t82, t40, undef:i64</span><br><span class="line">  t73: i64,i32 = X86ISD::SUB t60, t61</span><br><span class="line">    t77: ch,glue = callseq_start t13:1, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;</span><br><span class="line">  t79: i64,ch = CopyFromReg t77, Register:i64 $rsp</span><br><span class="line">          t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">        t68: i64 = shl t19, Constant:i8&lt;2&gt;</span><br><span class="line">      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;</span><br><span class="line">    t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">  t80: i64 = sub t79, t25</span><br><span class="line">    t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80</span><br><span class="line">  t82: ch,glue = callseq_end t81, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;</span><br><span class="line">        t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">        t28: ch = CopyToReg t0, Register:i64 %1, t80</span><br><span class="line">          t62: i32 = truncate t61</span><br><span class="line">        t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line">        t45: ch = CopyToReg t0, Register:i64 %3, t73</span><br><span class="line">      t51: ch = TokenFactor t18, t28, t38, t45, t82</span><br><span class="line">    t75: ch = X86ISD::BRCOND t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t73:1</span><br><span class="line">  t54: ch = br t75, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.0 ''</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t54: ch = br t75, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Morphed node: t54: ch = JMP_1 BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;, t75</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t75: ch = X86ISD::BRCOND t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t73:1</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135091</span><br><span class="line">  Morphed node: t75: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t93, t93:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t51: ch = TokenFactor t18, t28, t38, t45, t82</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t45: ch = CopyToReg t0, Register:i64 %3, t73</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t73: i64,i32 = X86ISD::SUB t60, t61</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 114065</span><br><span class="line">  Match failed at index 114078</span><br><span class="line">  Continuing at 114269</span><br><span class="line">  Match failed at index 114270</span><br><span class="line">  Continuing at 114372</span><br><span class="line">  Match failed at index 114373</span><br><span class="line">  Continuing at 114475</span><br><span class="line">  Continuing at 114476</span><br><span class="line">  Match failed at index 114477</span><br><span class="line">  Continuing at 114578</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 114589, continuing at 114720</span><br><span class="line">  Match failed at index 114724</span><br><span class="line">  Continuing at 114738</span><br><span class="line">  Match failed at index 114742</span><br><span class="line">  Continuing at 114756</span><br><span class="line">  Match failed at index 114760</span><br><span class="line">  Continuing at 114773</span><br><span class="line">  Match failed at index 114774</span><br><span class="line">  Continuing at 114792</span><br><span class="line">  Match failed at index 114796</span><br><span class="line">  Continuing at 114810</span><br><span class="line">  Match failed at index 114814</span><br><span class="line">  Continuing at 114828</span><br><span class="line">  Match failed at index 114832</span><br><span class="line">  Continuing at 114845</span><br><span class="line">  Match failed at index 114846</span><br><span class="line">  Continuing at 114864</span><br><span class="line">  Continuing at 114865</span><br><span class="line">  Match failed at index 114866</span><br><span class="line">  Continuing at 114892</span><br><span class="line">  Match failed at index 114893</span><br><span class="line">  Continuing at 114919</span><br><span class="line">  Match failed at index 114920</span><br><span class="line">  Continuing at 114945</span><br><span class="line">  Morphed node: t73: i64,i32 = SUB64rr t60, t61</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t62: i32 = truncate t61</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 131882</span><br><span class="line">  Match failed at index 131885</span><br><span class="line">  Continuing at 131993</span><br><span class="line">  TypeSwitch[i32] from 131996 to 132025</span><br><span class="line">  Morphed node: t62: i32 = EXTRACT_SUBREG t61, TargetConstant:i32&lt;6&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t82, t40, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218</span><br><span class="line">  Match failed at index 122221</span><br><span class="line">  Continuing at 122258</span><br><span class="line">  Match failed at index 122259</span><br><span class="line">  Continuing at 122298</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337</span><br><span class="line">  Morphed node: t60: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.17, !tbaa !13)&gt; t6, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t82, t35, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218</span><br><span class="line">  Match failed at index 122221</span><br><span class="line">  Continuing at 122258</span><br><span class="line">  Match failed at index 122259</span><br><span class="line">  Continuing at 122298</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337</span><br><span class="line">  Morphed node: t61: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.14, !tbaa !11)&gt; t4, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t82, t8, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218</span><br><span class="line">  Match failed at index 122221</span><br><span class="line">  Continuing at 122258</span><br><span class="line">  Match failed at index 122259</span><br><span class="line">  Continuing at 122298</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337</span><br><span class="line">  Morphed node: t66: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.3, !tbaa !9)&gt; t8, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t82</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t82: ch,glue = callseq_end t81, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 134948</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 134963, continuing at 134974</span><br><span class="line">  Morphed node: t82: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, t81</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t28: ch = CopyToReg t0, Register:i64 %1, t80</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t80: i64 = sub t79, t25</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 56806</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 56808, continuing at 56910</span><br><span class="line">  Match failed at index 56913</span><br><span class="line">  Continuing at 57259</span><br><span class="line">  Match failed at index 57263</span><br><span class="line">  Continuing at 57459</span><br><span class="line">  TypeSwitch[i64] from 57461 to 57498</span><br><span class="line">  Match failed at index 57498</span><br><span class="line">  Continuing at 57511</span><br><span class="line">  Match failed at index 57513</span><br><span class="line">  Continuing at 57654</span><br><span class="line">  Match failed at index 57664</span><br><span class="line">  Continuing at 57788</span><br><span class="line">  Match failed at index 57789</span><br><span class="line">  Continuing at 57815</span><br><span class="line">  Match failed at index 57816</span><br><span class="line">  Continuing at 57842</span><br><span class="line">  Match failed at index 57843</span><br><span class="line">  Continuing at 57868</span><br><span class="line">  Morphed node: t80: i64,i32 = SUB64rr t79, t25</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t25: i64 = and t23, Constant:i64&lt;-16&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 64496</span><br><span class="line">  Match failed at index 64500</span><br><span class="line">  Continuing at 64964</span><br><span class="line">  Match failed at index 64973</span><br><span class="line">  Continuing at 65005</span><br><span class="line">  Match failed at index 65009</span><br><span class="line">  Continuing at 65041</span><br><span class="line">  Match failed at index 65045</span><br><span class="line">  Continuing at 65076</span><br><span class="line">  Match failed at index 65077</span><br><span class="line">  Continuing at 65113</span><br><span class="line">  Continuing at 65114</span><br><span class="line">  Match failed at index 65117</span><br><span class="line">  Continuing at 65354</span><br><span class="line">  Match failed at index 65358</span><br><span class="line">  Continuing at 65554</span><br><span class="line">  OpcodeSwitch from 65557 to 65836</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 65839, continuing at 65874</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 65875, continuing at 65910</span><br><span class="line">  Match failed at index 65837</span><br><span class="line">  Continuing at 65912</span><br><span class="line">  Match failed at index 65915</span><br><span class="line">  Continuing at 66022</span><br><span class="line">  Match failed at index 66024</span><br><span class="line">  Continuing at 66134</span><br><span class="line">  Match failed at index 66135</span><br><span class="line">  Continuing at 66198</span><br><span class="line">  Match failed at index 66201</span><br><span class="line">  Continuing at 66323</span><br><span class="line">  Match failed at index 66324</span><br><span class="line">  Continuing at 66354</span><br><span class="line">  OpcodeSwitch from 66356 to 66360</span><br><span class="line">  Match failed at index 66361</span><br><span class="line">  Continuing at 66480</span><br><span class="line">  Match failed at index 66483</span><br><span class="line">  Continuing at 66515</span><br><span class="line">  Match failed at index 66521</span><br><span class="line">  Continuing at 66550</span><br><span class="line">  Match failed at index 66553</span><br><span class="line">  Continuing at 66639</span><br><span class="line">  Match failed at index 66641</span><br><span class="line">  Continuing at 66728</span><br><span class="line">  Match failed at index 66729</span><br><span class="line">  Continuing at 66750</span><br><span class="line">  Match failed at index 66751</span><br><span class="line">  Continuing at 66800</span><br><span class="line">  Match failed at index 66801</span><br><span class="line">  Continuing at 66836</span><br><span class="line">  Match failed at index 66837</span><br><span class="line">  Continuing at 66870</span><br><span class="line">  Match failed at index 66871</span><br><span class="line">  Continuing at 66903</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 66913, continuing at 66931</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 66932, continuing at 67010</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 67011, continuing at 67029</span><br><span class="line">  Morphed node: t25: i64,i32 = AND64ri32 t23, TargetConstant:i64&lt;-16&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t23: i64 = add nuw t68, Constant:i64&lt;15&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Morphed node: t23: i64 = LEA64r nuw Register:i64 $noreg, TargetConstant:i8&lt;4&gt;, t19, TargetConstant:i32&lt;15&gt;, Register:i16 $noreg</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t19: i64 = mul nuw nsw t16, t16</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 95377</span><br><span class="line">  Match failed at index 95380</span><br><span class="line">  Continuing at 95473</span><br><span class="line">  Match failed at index 95477</span><br><span class="line">  Continuing at 95648</span><br><span class="line">  Match failed at index 95651</span><br><span class="line">  Continuing at 95805</span><br><span class="line">  TypeSwitch[i64] from 95807 to 95844</span><br><span class="line">  Match failed at index 95844</span><br><span class="line">  Continuing at 95857</span><br><span class="line">  Match failed at index 95867</span><br><span class="line">  Continuing at 95912</span><br><span class="line">  Match failed at index 95913</span><br><span class="line">  Continuing at 95924</span><br><span class="line">  Match failed at index 95925</span><br><span class="line">  Continuing at 95951</span><br><span class="line">  Match failed at index 95952</span><br><span class="line">  Continuing at 95977</span><br><span class="line">  Morphed node: t19: i64,i32 = IMUL64rr nuw nsw t16, t16</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t16: i64 = zero_extend nneg t91</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 133343</span><br><span class="line">  Match failed at index 133347</span><br><span class="line">  Continuing at 133490</span><br><span class="line">  Morphed node: t16: i64 = SUBREG_TO_REG nneg TargetConstant:i64&lt;0&gt;, t91, TargetConstant:i32&lt;6&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t79: i64,ch = CopyFromReg t77, Register:i64 $rsp</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t91: i32 = X86ISD::CMOV Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t88</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 97695</span><br><span class="line">  Match failed at index 97705</span><br><span class="line">  Continuing at 97896</span><br><span class="line">  Match failed at index 97899</span><br><span class="line">  Continuing at 98125</span><br><span class="line">  TypeSwitch[i32] from 98136 to 98152</span><br><span class="line">  Match failed at index 98152</span><br><span class="line">  Continuing at 98177</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 98182, continuing at 98241</span><br><span class="line">  TypeSwitch[i32] from 98254 to 98300</span><br><span class="line">  Morphed node: t91: i32 = CMOV32rr Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t104:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t77: ch,glue = callseq_start t13:1, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 134990</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135004, continuing at 135018</span><br><span class="line">  Morphed node: t77: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t13:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t88: i32 = X86ISD::CMP t13, Constant:i32&lt;0&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 21254</span><br><span class="line">  OpcodeSwitch from 21258 to 21707</span><br><span class="line">  Match failed at index 21709</span><br><span class="line">  Continuing at 21932</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 21936, continuing at 21965</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 21966, continuing at 21995</span><br><span class="line">  Match failed at index 21998</span><br><span class="line">  Continuing at 22024</span><br><span class="line">  Match failed at index 22025</span><br><span class="line">  Continuing at 22052</span><br><span class="line">  Continuing at 22053</span><br><span class="line">  OpcodeSwitch from 22056 to 22060</span><br><span class="line">  Match failed at index 22062</span><br><span class="line">  Continuing at 22405</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 22410, continuing at 22468</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 22469, continuing at 22527</span><br><span class="line">  Morphed node: t88: i32 = TEST32rr t13, t13</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Match failed at index 122148</span><br><span class="line">  Continuing at 122164</span><br><span class="line">  Match failed at index 122167</span><br><span class="line">  Continuing at 122183</span><br><span class="line">  Morphed node: t13: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.0, !tbaa !3)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t89: i8 = TargetConstant&lt;15&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t78: i64 = Register $rsp</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t76: i64 = TargetConstant&lt;0&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t74: i8 = TargetConstant&lt;8&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t53: ch = BasicBlock&lt;.lr.ph56 0x60c587dbab30&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t50: ch = BasicBlock&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t44: i64 = Register %3</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t37: i32 = Register %2</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t27: i64 = Register %1</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t17: i64 = Register %0</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t14: i32 = Constant&lt;0&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 131651</span><br><span class="line">  TypeSwitch[i32] from 131655 to 131658</span><br><span class="line">  Morphed node: t14: i32,i32 = MOV32r0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t7: i64 = Register %25</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t5: i64 = Register %24</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t3: i64 = Register %23</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i64 = Register %22</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.0 'solve_:'</span><br><span class="line">SelectionDAG has 57 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %22</span><br><span class="line">  t13: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.0, !tbaa !3)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0</span><br><span class="line">    t77: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t13:1</span><br><span class="line">  t79: i64,ch = CopyFromReg t77:1, Register:i64 $rsp</span><br><span class="line">        t88: i32 = TEST32rr t13, t13</span><br><span class="line">      t104: ch,glue = CopyToReg t0, Register:i32 $eflags, t88</span><br><span class="line">    t91: i32 = CMOV32rr MOV32r0:i32,i32, t13, TargetConstant:i8&lt;15&gt;, t104:1</span><br><span class="line">  t16: i64 = SUBREG_TO_REG nneg TargetConstant:i64&lt;0&gt;, t91, TargetConstant:i32&lt;6&gt;</span><br><span class="line">        t19: i64,i32 = IMUL64rr nuw nsw t16, t16</span><br><span class="line">      t23: i64 = LEA64r nuw Register:i64 $noreg, TargetConstant:i8&lt;4&gt;, t19, TargetConstant:i32&lt;15&gt;, Register:i16 $noreg</span><br><span class="line">    t25: i64,i32 = AND64ri32 t23, TargetConstant:i64&lt;-16&gt;</span><br><span class="line">  t80: i64,i32 = SUB64rr t79, t25</span><br><span class="line">    t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80</span><br><span class="line">  t82: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, t81</span><br><span class="line">    t8: i64,ch = CopyFromReg t0, Register:i64 %25</span><br><span class="line">  t66: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.3, !tbaa !9)&gt; t8, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t82:1</span><br><span class="line">    t4: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">  t61: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.14, !tbaa !11)&gt; t4, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82:1</span><br><span class="line">      t6: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">    t60: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.17, !tbaa !13)&gt; t6, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82:1</span><br><span class="line">  t73: i64,i32 = SUB64rr t60, t61</span><br><span class="line">      t18: ch = CopyToReg t0, Register:i64 %0, t16</span><br><span class="line">      t28: ch = CopyToReg t0, Register:i64 %1, t80</span><br><span class="line">        t62: i32 = EXTRACT_SUBREG t61, TargetConstant:i32&lt;6&gt;</span><br><span class="line">      t38: ch = CopyToReg t0, Register:i32 %2, t62</span><br><span class="line">      t45: ch = CopyToReg t0, Register:i64 %3, t73</span><br><span class="line">    t51: ch = TokenFactor t18, t28, t38, t45, t82:1</span><br><span class="line">  t93: ch,glue = CopyToReg t51, Register:i32 $eflags, t73:1</span><br><span class="line">  t101: i32 = Register $noreg</span><br><span class="line">    t75: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t93, t93:1</span><br><span class="line">  t54: ch = JMP_1 BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;, t75</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 0</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 37 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t3: i64 = Constant&lt;0&gt;</span><br><span class="line">          t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">        t5: i32,ch = load&lt;(load (s32) from %ir.4, !tbaa !15)&gt; t0, t2, undef:i64</span><br><span class="line">      t6: i64 = sign_extend t5</span><br><span class="line">    t8: i64 = add nsw t6, Constant:i64&lt;-1&gt;</span><br><span class="line">  t12: i64 = shl t8, Constant:i64&lt;2&gt;</span><br><span class="line">      t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t13: i64 = add t10, t12</span><br><span class="line">  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">  t17: i64 = sign_extend t14</span><br><span class="line">        t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">      t22: i64 = add t21, t12</span><br><span class="line">    t23: i32,ch = load&lt;(load (s32) from %ir.27, !tbaa !13)&gt; t0, t22, undef:i64</span><br><span class="line">  t24: i64 = sign_extend t23</span><br><span class="line">        t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">        t26: ch = CopyToReg t0, Register:i64 %6, t24</span><br><span class="line">      t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">          t27: i64 = sub nsw t24, t17</span><br><span class="line">        t29: i1 = setcc t27, Constant:i64&lt;-1&gt;, setgt:ch</span><br><span class="line">      t31: i1 = xor t29, Constant:i1&lt;-1&gt;</span><br><span class="line">    t34: ch = brcond t33, t31, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t36: ch = br t34, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 33 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">      t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t13: i64 = add t10, t46</span><br><span class="line">  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">  t17: i64 = sign_extend t14</span><br><span class="line">      t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">    t22: i64 = add t21, t46</span><br><span class="line">  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64</span><br><span class="line">    t45: i64 = shl t47, Constant:i64&lt;2&gt;</span><br><span class="line">  t46: i64 = add t45, Constant:i64&lt;-4&gt;</span><br><span class="line">        t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">        t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line">      t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">        t27: i64 = sub nsw t43, t17</span><br><span class="line">      t42: i1 = setcc t27, Constant:i64&lt;0&gt;, setlt:ch</span><br><span class="line">    t39: ch = brcond t33, t42, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t36: ch = br t39, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 35 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">      t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t13: i64 = add t10, t46</span><br><span class="line">  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">  t17: i64 = sign_extend t14</span><br><span class="line">      t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">    t22: i64 = add t21, t46</span><br><span class="line">  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64</span><br><span class="line">    t45: i64 = shl t47, Constant:i64&lt;2&gt;</span><br><span class="line">  t46: i64 = add t45, Constant:i64&lt;-4&gt;</span><br><span class="line">        t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">        t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line">      t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">          t27: i64 = sub nsw t43, t17</span><br><span class="line">        t48: i8 = setcc t27, Constant:i64&lt;0&gt;, setlt:ch</span><br><span class="line">      t51: i8 = and t48, Constant:i8&lt;1&gt;</span><br><span class="line">    t39: ch = brcond t33, t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t36: ch = br t39, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized type-legalized selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 33 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">      t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t13: i64 = add t10, t46</span><br><span class="line">  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">  t17: i64 = sign_extend t14</span><br><span class="line">      t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">    t22: i64 = add t21, t46</span><br><span class="line">  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64</span><br><span class="line">    t45: i64 = shl t47, Constant:i64&lt;2&gt;</span><br><span class="line">  t46: i64 = add t45, Constant:i64&lt;-4&gt;</span><br><span class="line">        t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">        t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line">      t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">        t27: i64 = sub nsw t43, t17</span><br><span class="line">      t48: i8 = setcc t27, Constant:i64&lt;0&gt;, setlt:ch</span><br><span class="line">    t39: ch = brcond t33, t48, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">  t36: ch = br t39, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 31 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64</span><br><span class="line">    t45: i64 = shl t47, Constant:i8&lt;2&gt;</span><br><span class="line">  t46: i64 = add t45, Constant:i64&lt;-4&gt;</span><br><span class="line">      t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t13: i64 = add t10, t46</span><br><span class="line">  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">      t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">    t22: i64 = add t21, t46</span><br><span class="line">  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64</span><br><span class="line">  t17: i64 = sign_extend t14</span><br><span class="line">        t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">        t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line">      t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">      t52: i64,i32 = X86ISD::SUB t43, t17</span><br><span class="line">    t54: ch = X86ISD::BRCOND t33, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t52:1</span><br><span class="line">  t36: ch = br t54, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 31 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64</span><br><span class="line">    t45: i64 = shl t47, Constant:i8&lt;2&gt;</span><br><span class="line">  t46: i64 = add t45, Constant:i64&lt;-4&gt;</span><br><span class="line">      t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">    t13: i64 = add t10, t46</span><br><span class="line">  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">      t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">    t22: i64 = add t21, t46</span><br><span class="line">  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64</span><br><span class="line">  t17: i64 = sign_extend t14</span><br><span class="line">        t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">        t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line">      t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">      t52: i64,i32 = X86ISD::SUB t43, t17</span><br><span class="line">    t54: ch = X86ISD::BRCOND t33, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t52:1</span><br><span class="line">  t36: ch = br t54, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.1 '.lr.ph56'</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t36: ch = br t54, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 136351</span><br><span class="line">  Morphed node: t36: ch = JMP_1 BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;, t54</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t54: ch = X86ISD::BRCOND t33, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t52:1</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135091</span><br><span class="line">  Morphed node: t54: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t57, t57:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t33: ch = TokenFactor t16, t19, t26</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t52: i64,i32 = X86ISD::SUB t43, t17</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 114065</span><br><span class="line">  Match failed at index 114073</span><br><span class="line">  Continuing at 114269</span><br><span class="line">  Match failed at index 114270</span><br><span class="line">  Continuing at 114372</span><br><span class="line">  Match failed at index 114373</span><br><span class="line">  Continuing at 114475</span><br><span class="line">  Continuing at 114476</span><br><span class="line">  Match failed at index 114477</span><br><span class="line">  Continuing at 114578</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 114589, continuing at 114720</span><br><span class="line">  Match failed at index 114724</span><br><span class="line">  Continuing at 114738</span><br><span class="line">  Match failed at index 114742</span><br><span class="line">  Continuing at 114756</span><br><span class="line">  Match failed at index 114760</span><br><span class="line">  Continuing at 114773</span><br><span class="line">  Match failed at index 114774</span><br><span class="line">  Continuing at 114792</span><br><span class="line">  Match failed at index 114796</span><br><span class="line">  Continuing at 114810</span><br><span class="line">  Match failed at index 114814</span><br><span class="line">  Continuing at 114828</span><br><span class="line">  Match failed at index 114832</span><br><span class="line">  Continuing at 114845</span><br><span class="line">  Match failed at index 114846</span><br><span class="line">  Continuing at 114864</span><br><span class="line">  Continuing at 114865</span><br><span class="line">  Match failed at index 114866</span><br><span class="line">  Continuing at 114892</span><br><span class="line">  Match failed at index 114893</span><br><span class="line">  Continuing at 114919</span><br><span class="line">  Match failed at index 114920</span><br><span class="line">  Continuing at 114945</span><br><span class="line">  Morphed node: t52: i64,i32 = SUB64rr t43, t17</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t17: i64 = sign_extend t14</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135712</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758</span><br><span class="line">  Morphed node: t17: i64 = MOVSX64rr32 t14</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218</span><br><span class="line">  Match failed at index 122221</span><br><span class="line">  Continuing at 122258</span><br><span class="line">  Match failed at index 122259</span><br><span class="line">  Continuing at 122298</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337</span><br><span class="line">  Morphed node: t43: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.27, !tbaa !13)&gt; t21, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Match failed at index 122148</span><br><span class="line">  Continuing at 122164</span><br><span class="line">  Match failed at index 122167</span><br><span class="line">  Continuing at 122183</span><br><span class="line">  Morphed node: t14: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.24, !tbaa !11)&gt; t10, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218</span><br><span class="line">  Match failed at index 122221</span><br><span class="line">  Continuing at 122258</span><br><span class="line">  Match failed at index 122259</span><br><span class="line">  Continuing at 122298</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337</span><br><span class="line">  Morphed node: t47: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.4, !tbaa !15)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t53: i8 = TargetConstant&lt;8&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t35: ch = BasicBlock&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t32: ch = BasicBlock&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t25: i64 = Register %6</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t20: i64 = Register %24</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t18: i64 = Register %5</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t15: i32 = Register %4</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t9: i64 = Register %23</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i64 = Register %26</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.1 'solve_:.lr.ph56'</span><br><span class="line">SelectionDAG has 32 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t2: i64,ch = CopyFromReg t0, Register:i64 %26</span><br><span class="line">  t47: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.4, !tbaa !15)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0</span><br><span class="line">    t10: i64,ch = CopyFromReg t0, Register:i64 %23</span><br><span class="line">  t14: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.24, !tbaa !11)&gt; t10, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0</span><br><span class="line">    t21: i64,ch = CopyFromReg t0, Register:i64 %24</span><br><span class="line">  t43: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.27, !tbaa !13)&gt; t21, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0</span><br><span class="line">  t17: i64 = MOVSX64rr32 t14</span><br><span class="line">      t16: ch = CopyToReg t0, Register:i32 %4, t14</span><br><span class="line">      t19: ch = CopyToReg t0, Register:i64 %5, t17</span><br><span class="line">      t26: ch = CopyToReg t0, Register:i64 %6, t43</span><br><span class="line">    t33: ch = TokenFactor t16, t19, t26</span><br><span class="line">    t52: i64,i32 = SUB64rr t43, t17</span><br><span class="line">  t57: ch,glue = CopyToReg t33, Register:i32 $eflags, t52:1</span><br><span class="line">    t54: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t57, t57:1</span><br><span class="line">  t36: ch = JMP_1 BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;, t54</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 0</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.2 'solve_:.lr.ph.us.preheader'</span><br><span class="line">SelectionDAG has 26 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line">      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;</span><br><span class="line">    t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line">      t10: i64 = add t8, Constant:i64&lt;-4&gt;</span><br><span class="line">    t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line">            t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line">          t16: i64 = AssertSext t14, ValueType:ch:i32</span><br><span class="line">        t18: i64 = add t16, Constant:i64&lt;2&gt;</span><br><span class="line">          t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">        t21: i64 = AssertSext t20, ValueType:ch:i32</span><br><span class="line">      t22: i64 = sub t18, t21</span><br><span class="line">    t24: ch = CopyToReg t0, Register:i64 %9, t22</span><br><span class="line">  t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.2 'solve_:.lr.ph.us.preheader'</span><br><span class="line">SelectionDAG has 26 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line">      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;</span><br><span class="line">    t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line">      t10: i64 = add t8, Constant:i64&lt;-4&gt;</span><br><span class="line">    t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line">            t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line">          t16: i64 = AssertSext t14, ValueType:ch:i32</span><br><span class="line">            t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">          t21: i64 = AssertSext t20, ValueType:ch:i32</span><br><span class="line">        t26: i64 = sub t16, t21</span><br><span class="line">      t27: i64 = add t26, Constant:i64&lt;2&gt;</span><br><span class="line">    t24: ch = CopyToReg t0, Register:i64 %9, t27</span><br><span class="line">  t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.2 'solve_:.lr.ph.us.preheader'</span><br><span class="line">SelectionDAG has 26 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line">      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;</span><br><span class="line">    t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line">      t10: i64 = add t8, Constant:i64&lt;-4&gt;</span><br><span class="line">    t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line">            t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line">          t16: i64 = AssertSext t14, ValueType:ch:i32</span><br><span class="line">            t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">          t21: i64 = AssertSext t20, ValueType:ch:i32</span><br><span class="line">        t26: i64 = sub t16, t21</span><br><span class="line">      t27: i64 = add t26, Constant:i64&lt;2&gt;</span><br><span class="line">    t24: ch = CopyToReg t0, Register:i64 %9, t27</span><br><span class="line">  t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.2 'solve_:.lr.ph.us.preheader'</span><br><span class="line">SelectionDAG has 26 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line">      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;</span><br><span class="line">    t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line">      t10: i64 = add t8, Constant:i64&lt;-4&gt;</span><br><span class="line">    t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line">            t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line">          t16: i64 = AssertSext t14, ValueType:ch:i32</span><br><span class="line">            t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">          t21: i64 = AssertSext t20, ValueType:ch:i32</span><br><span class="line">        t26: i64 = sub t16, t21</span><br><span class="line">      t27: i64 = add t26, Constant:i64&lt;2&gt;</span><br><span class="line">    t24: ch = CopyToReg t0, Register:i64 %9, t27</span><br><span class="line">  t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.2 'solve_:.lr.ph.us.preheader'</span><br><span class="line">SelectionDAG has 26 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line">      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;</span><br><span class="line">    t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line">      t10: i64 = add t8, Constant:i64&lt;-4&gt;</span><br><span class="line">    t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line">            t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line">          t16: i64 = AssertSext t14, ValueType:ch:i32</span><br><span class="line">            t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">          t21: i64 = AssertSext t20, ValueType:ch:i32</span><br><span class="line">        t26: i64 = sub t16, t21</span><br><span class="line">      t27: i64 = add t26, Constant:i64&lt;2&gt;</span><br><span class="line">    t24: ch = CopyToReg t0, Register:i64 %9, t27</span><br><span class="line">  t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.2 '.lr.ph.us.preheader'</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t24: ch = CopyToReg t0, Register:i64 %9, t27</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t27: i64 = add t26, Constant:i64&lt;2&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Match failed at index 53496</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905</span><br><span class="line">  Morphed node: t27: i64,i32 = ADD64ri32 t26, TargetConstant:i64&lt;2&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t26: i64 = sub t16, t21</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 56806</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 56808, continuing at 56910</span><br><span class="line">  Match failed at index 56913</span><br><span class="line">  Continuing at 57259</span><br><span class="line">  Match failed at index 57263</span><br><span class="line">  Continuing at 57459</span><br><span class="line">  TypeSwitch[i64] from 57461 to 57498</span><br><span class="line">  Match failed at index 57498</span><br><span class="line">  Continuing at 57511</span><br><span class="line">  Match failed at index 57513</span><br><span class="line">  Continuing at 57654</span><br><span class="line">  Match failed at index 57664</span><br><span class="line">  Continuing at 57788</span><br><span class="line">  Match failed at index 57789</span><br><span class="line">  Continuing at 57815</span><br><span class="line">  Match failed at index 57816</span><br><span class="line">  Continuing at 57842</span><br><span class="line">  Match failed at index 57843</span><br><span class="line">  Continuing at 57868</span><br><span class="line">  Morphed node: t26: i64,i32 = SUB64rr t16, t21</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t21: i64 = AssertSext t20, ValueType:ch:i32</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t16: i64 = AssertSext t14, ValueType:ch:i32</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t10: i64 = add t8, Constant:i64&lt;-4&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Match failed at index 53496</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905</span><br><span class="line">  Morphed node: t10: i64,i32 = ADD64ri32 t8, TargetConstant:i64&lt;-4&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Match failed at index 53496</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  TypeSwitch[i64] from 53706 to 53781</span><br><span class="line">  Morphed node: t4: i64,i32 = INC64r nuw nsw t2</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t23: i64 = Register %9</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t19: i64 = Register %5</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t13: i64 = Register %6</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t11: i64 = Register %8</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t7: i64 = Register %1</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t5: i64 = Register %7</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i64 = Register %3</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.2 'solve_:.lr.ph.us.preheader'</span><br><span class="line">SelectionDAG has 23 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t28: i32 = Register $noreg</span><br><span class="line">        t2: i64,ch = CopyFromReg t0, Register:i64 %3</span><br><span class="line">      t4: i64,i32 = INC64r nuw nsw t2</span><br><span class="line">    t6: ch = CopyToReg t0, Register:i64 %7, t4</span><br><span class="line">        t8: i64,ch = CopyFromReg t0, Register:i64 %1</span><br><span class="line">      t10: i64,i32 = ADD64ri32 t8, TargetConstant:i64&lt;-4&gt;</span><br><span class="line">    t12: ch = CopyToReg t0, Register:i64 %8, t10</span><br><span class="line">          t14: i64,ch = CopyFromReg t0, Register:i64 %6</span><br><span class="line">          t20: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">        t26: i64,i32 = SUB64rr t14, t20</span><br><span class="line">      t27: i64,i32 = ADD64ri32 t26, TargetConstant:i64&lt;2&gt;</span><br><span class="line">    t24: ch = CopyToReg t0, Register:i64 %9, t27</span><br><span class="line">  t25: ch = TokenFactor t6, t12, t24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 2</span><br><span class="line">Node 0 : (0x60c587dbae30, 2147483655)</span><br><span class="line">Node 1 : (0x60c587dbae98, 2147483650)</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.3 'solve_:.lr.ph.us'</span><br><span class="line">SelectionDAG has 29 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;</span><br><span class="line">          t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line">        t9: i64 = AssertZext t7, ValueType:ch:i32</span><br><span class="line">      t10: i64 = mul nsw t5, t9</span><br><span class="line">    t14: i64 = shl t10, Constant:i64&lt;2&gt;</span><br><span class="line">  t15: i64 = add t12, t14</span><br><span class="line">  t23: i64 = Constant&lt;0&gt;</span><br><span class="line">    t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line">              t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">            t20: i64 = AssertSext t19, ValueType:ch:i32</span><br><span class="line">          t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">        t22: i64 = add t15, t21</span><br><span class="line">      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64</span><br><span class="line">    t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line">  t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.3 'solve_:.lr.ph.us'</span><br><span class="line">SelectionDAG has 28 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;</span><br><span class="line">          t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line">        t9: i64 = AssertZext t7, ValueType:ch:i32</span><br><span class="line">      t10: i64 = mul nsw t5, t9</span><br><span class="line">    t14: i64 = shl t10, Constant:i64&lt;2&gt;</span><br><span class="line">  t15: i64 = add t12, t14</span><br><span class="line">    t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line">              t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">            t20: i64 = AssertSext t19, ValueType:ch:i32</span><br><span class="line">          t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">        t22: i64 = add t15, t21</span><br><span class="line">      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64</span><br><span class="line">    t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line">  t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.3 'solve_:.lr.ph.us'</span><br><span class="line">SelectionDAG has 28 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;</span><br><span class="line">          t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line">        t9: i64 = AssertZext t7, ValueType:ch:i32</span><br><span class="line">      t10: i64 = mul nsw t5, t9</span><br><span class="line">    t14: i64 = shl t10, Constant:i64&lt;2&gt;</span><br><span class="line">  t15: i64 = add t12, t14</span><br><span class="line">    t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line">              t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">            t20: i64 = AssertSext t19, ValueType:ch:i32</span><br><span class="line">          t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">        t22: i64 = add t15, t21</span><br><span class="line">      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64</span><br><span class="line">    t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line">  t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.3 'solve_:.lr.ph.us'</span><br><span class="line">SelectionDAG has 28 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;</span><br><span class="line">          t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line">        t9: i64 = AssertZext t7, ValueType:ch:i32</span><br><span class="line">      t10: i64 = mul nsw t5, t9</span><br><span class="line">    t14: i64 = shl t10, Constant:i8&lt;2&gt;</span><br><span class="line">  t15: i64 = add t12, t14</span><br><span class="line">    t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line">              t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">            t20: i64 = AssertSext t19, ValueType:ch:i32</span><br><span class="line">          t21: i64 = shl t20, Constant:i8&lt;2&gt;</span><br><span class="line">        t22: i64 = add t15, t21</span><br><span class="line">      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64</span><br><span class="line">    t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line">  t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.3 'solve_:.lr.ph.us'</span><br><span class="line">SelectionDAG has 28 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;</span><br><span class="line">          t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line">        t9: i64 = AssertZext t7, ValueType:ch:i32</span><br><span class="line">      t10: i64 = mul nsw t5, t9</span><br><span class="line">    t14: i64 = shl t10, Constant:i8&lt;2&gt;</span><br><span class="line">  t15: i64 = add t12, t14</span><br><span class="line">    t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line">              t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">            t20: i64 = AssertSext t19, ValueType:ch:i32</span><br><span class="line">          t21: i64 = shl t20, Constant:i8&lt;2&gt;</span><br><span class="line">        t22: i64 = add t15, t21</span><br><span class="line">      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64</span><br><span class="line">    t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line">  t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.3 '.lr.ph.us'</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Match failed at index 122148</span><br><span class="line">  Continuing at 122164</span><br><span class="line">  Match failed at index 122167</span><br><span class="line">  Continuing at 122183</span><br><span class="line">  Morphed node: t25: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t15, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t15: i64 = add t12, t14</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Morphed node: t15: i64 = LEA64r t12, TargetConstant:i8&lt;4&gt;, t10, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t10: i64 = mul nsw t5, t9</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 95377</span><br><span class="line">  Match failed at index 95380</span><br><span class="line">  Continuing at 95473</span><br><span class="line">  Match failed at index 95477</span><br><span class="line">  Continuing at 95648</span><br><span class="line">  Match failed at index 95651</span><br><span class="line">  Continuing at 95805</span><br><span class="line">  TypeSwitch[i64] from 95807 to 95844</span><br><span class="line">  Match failed at index 95844</span><br><span class="line">  Continuing at 95857</span><br><span class="line">  Match failed at index 95867</span><br><span class="line">  Continuing at 95912</span><br><span class="line">  Match failed at index 95913</span><br><span class="line">  Continuing at 95924</span><br><span class="line">  Match failed at index 95925</span><br><span class="line">  Continuing at 95951</span><br><span class="line">  Match failed at index 95952</span><br><span class="line">  Continuing at 95977</span><br><span class="line">  Morphed node: t10: i64,i32 = IMUL64rr nsw t5, t9</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Match failed at index 53496</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  TypeSwitch[i64] from 53807 to 53882</span><br><span class="line">  Morphed node: t5: i64,i32 = DEC64r nsw t3</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t20: i64 = AssertSext t19, ValueType:ch:i32</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t9: i64 = AssertZext t7, ValueType:ch:i32</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t3: i64 = sign_extend t2</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135712</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758</span><br><span class="line">  Morphed node: t3: i64 = MOVSX64rr32 t2</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t26: i32 = Register %13</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t18: i64 = Register %5</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t16: i64 = Register %12</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t11: i64 = Register %8</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t6: i64 = Register %0</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i32 = Register %11</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.3 'solve_:.lr.ph.us'</span><br><span class="line">SelectionDAG has 23 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">    t12: i64,ch = CopyFromReg t0, Register:i64 %8</span><br><span class="line">          t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">        t3: i64 = MOVSX64rr32 t2</span><br><span class="line">      t5: i64,i32 = DEC64r nsw t3</span><br><span class="line">      t7: i64,ch = CopyFromReg t0, Register:i64 %0</span><br><span class="line">    t10: i64,i32 = IMUL64rr nsw t5, t7</span><br><span class="line">  t15: i64 = LEA64r t12, TargetConstant:i8&lt;4&gt;, t10, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg</span><br><span class="line">  t33: i32 = Register $noreg</span><br><span class="line">    t17: ch = CopyToReg t0, Register:i64 %12, t15</span><br><span class="line">        t19: i64,ch = CopyFromReg t0, Register:i64 %5</span><br><span class="line">      t25: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t15, TargetConstant:i8&lt;4&gt;, t19, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0</span><br><span class="line">    t27: ch = CopyToReg t0, Register:i32 %13, t25</span><br><span class="line">  t28: ch = TokenFactor t17, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 3</span><br><span class="line">Node 0 : (0x60c587dbb000, 2147483657)</span><br><span class="line">Node 1 : (0x60c587dbb068, 2147483661)</span><br><span class="line">Node 2 : (0x60c587dbb0d0, 2147483652)</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 43 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t13: i64 = Constant&lt;0&gt;</span><br><span class="line">  t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">      t20: i64 = sign_extend t17</span><br><span class="line">    t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">  t22: i64 = add t5, t21</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t7: i64 = shl t3, Constant:i64&lt;2&gt;</span><br><span class="line">      t8: i64 = add t5, t7</span><br><span class="line">    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">  t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">        t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">        t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">      t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">      t37: i1 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">    t40: ch = brcond t39, t37, BasicBlock:ch&lt; 0x60c587dbaf00&gt;</span><br><span class="line">  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 42 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">      t20: i64 = sign_extend t17</span><br><span class="line">    t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">  t22: i64 = add t5, t21</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t7: i64 = shl t3, Constant:i64&lt;2&gt;</span><br><span class="line">      t8: i64 = add t5, t7</span><br><span class="line">    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">  t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">        t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">        t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">      t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">      t37: i1 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">    t40: ch = brcond t39, t37, BasicBlock:ch&lt; 0x60c587dbaf00&gt;</span><br><span class="line">  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 44 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">      t20: i64 = sign_extend t17</span><br><span class="line">    t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">  t22: i64 = add t5, t21</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t7: i64 = shl t3, Constant:i64&lt;2&gt;</span><br><span class="line">      t8: i64 = add t5, t7</span><br><span class="line">    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">  t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">        t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">        t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">      t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">        t43: i8 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">      t46: i8 = and t43, Constant:i8&lt;1&gt;</span><br><span class="line">    t40: ch = brcond t39, t46, BasicBlock:ch&lt; 0x60c587dbaf00&gt;</span><br><span class="line">  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized type-legalized selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 42 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">      t20: i64 = sign_extend t17</span><br><span class="line">    t21: i64 = shl t20, Constant:i64&lt;2&gt;</span><br><span class="line">  t22: i64 = add t5, t21</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t7: i64 = shl t3, Constant:i64&lt;2&gt;</span><br><span class="line">      t8: i64 = add t5, t7</span><br><span class="line">    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">  t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">        t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">        t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">      t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">      t43: i8 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">    t40: ch = brcond t39, t43, BasicBlock:ch&lt; 0x60c587dbaf00&gt;</span><br><span class="line">  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 42 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">      t20: i64 = sign_extend t17</span><br><span class="line">    t21: i64 = shl t20, Constant:i8&lt;2&gt;</span><br><span class="line">  t22: i64 = add t5, t21</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t7: i64 = shl t3, Constant:i8&lt;2&gt;</span><br><span class="line">      t8: i64 = add t5, t7</span><br><span class="line">    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">  t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">        t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">        t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">      t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">      t47: i64,i32 = X86ISD::SUB t32, Constant:i64&lt;1&gt;</span><br><span class="line">    t49: ch = X86ISD::BRCOND t39, BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t47:1</span><br><span class="line">  t42: ch = br t49, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 42 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">      t20: i64 = sign_extend t17</span><br><span class="line">    t21: i64 = shl t20, Constant:i8&lt;2&gt;</span><br><span class="line">  t22: i64 = add t5, t21</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">          t3: i64 = sign_extend t2</span><br><span class="line">        t7: i64 = shl t3, Constant:i8&lt;2&gt;</span><br><span class="line">      t8: i64 = add t5, t7</span><br><span class="line">    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">  t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">        t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">        t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">        t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">      t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">      t47: i64,i32 = X86ISD::SUB t32, Constant:i64&lt;1&gt;</span><br><span class="line">    t49: ch = X86ISD::BRCOND t39, BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t47:1</span><br><span class="line">  t42: ch = br t49, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.4 ''</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t42: ch = br t49, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 136351</span><br><span class="line">  Morphed node: t42: ch = JMP_1 BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;, t49</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t49: ch = X86ISD::BRCOND t39, BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t47:1</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135091</span><br><span class="line">  Morphed node: t49: ch = JCC_1 BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t52, t52:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 5</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 13, continuing at 73</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 74, continuing at 134</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135, continuing at 178</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 179, continuing at 222</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 223, continuing at 283</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 284, continuing at 327</span><br><span class="line">  Match failed at index 332</span><br><span class="line">  Continuing at 350</span><br><span class="line">  Match failed at index 351</span><br><span class="line">  Continuing at 373</span><br><span class="line">  Match failed at index 374</span><br><span class="line">  Continuing at 417</span><br><span class="line">  Match failed at index 418</span><br><span class="line">  Continuing at 461</span><br><span class="line">  Match failed at index 462</span><br><span class="line">  Continuing at 486</span><br><span class="line">  Match failed at index 487</span><br><span class="line">  Continuing at 530</span><br><span class="line">  Match failed at index 531</span><br><span class="line">  Continuing at 591</span><br><span class="line">  Match failed at index 592</span><br><span class="line">  Continuing at 652</span><br><span class="line">  Match failed at index 653</span><br><span class="line">  Continuing at 697</span><br><span class="line">  Match failed at index 698</span><br><span class="line">  Continuing at 758</span><br><span class="line">  Match failed at index 759</span><br><span class="line">  Continuing at 783</span><br><span class="line">  Match failed at index 784</span><br><span class="line">  Continuing at 808</span><br><span class="line">  Match failed at index 809</span><br><span class="line">  Continuing at 833</span><br><span class="line">  Match failed at index 834</span><br><span class="line">  Continuing at 858</span><br><span class="line">  Match failed at index 859</span><br><span class="line">  Continuing at 883</span><br><span class="line">  Match failed at index 884</span><br><span class="line">  Continuing at 908</span><br><span class="line">  Match failed at index 909</span><br><span class="line">  Continuing at 942</span><br><span class="line">  Match failed at index 943</span><br><span class="line">  Continuing at 976</span><br><span class="line">  Continuing at 977</span><br><span class="line">  OpcodeSwitch from 980 to 3569</span><br><span class="line">  Match failed at index 3578</span><br><span class="line">  Continuing at 4244</span><br><span class="line">  Match failed at index 4253</span><br><span class="line">  Continuing at 4292</span><br><span class="line">  Match failed at index 4296</span><br><span class="line">  Continuing at 4335</span><br><span class="line">  Match failed at index 4339</span><br><span class="line">  Continuing at 4377</span><br><span class="line">  Match failed at index 4378</span><br><span class="line">  Continuing at 4421</span><br><span class="line">  Continuing at 4422</span><br><span class="line">  Match failed at index 4429</span><br><span class="line">  Continuing at 4537</span><br><span class="line">  Match failed at index 4540</span><br><span class="line">  Continuing at 4652</span><br><span class="line">  Continuing at 10391</span><br><span class="line">  Match failed at index 10395</span><br><span class="line">  Continuing at 11659</span><br><span class="line">  Match failed at index 11662</span><br><span class="line">  Continuing at 12194</span><br><span class="line">  Match failed at index 12195</span><br><span class="line">  Continuing at 12278</span><br><span class="line">  Match failed at index 12279</span><br><span class="line">  Continuing at 12362</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 12368, continuing at 12468</span><br><span class="line">  Match failed at index 12471</span><br><span class="line">  Continuing at 12493</span><br><span class="line">  Match failed at index 12496</span><br><span class="line">  Continuing at 12518</span><br><span class="line">  Match failed at index 12526</span><br><span class="line">  Continuing at 12542</span><br><span class="line">  Match failed at index 12543</span><br><span class="line">  Continuing at 12568</span><br><span class="line">  Continuing at 12569</span><br><span class="line">  Match failed at index 12572</span><br><span class="line">  Continuing at 12704</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 12709, continuing at 12728</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 12729, continuing at 12748</span><br><span class="line">  Morphed node: t28: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t25, t23:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t25: i32 = add t23, Constant:i32&lt;-20&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52338</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53258</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i32] from 53459 to 53462</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478</span><br><span class="line">  Match failed at index 53481</span><br><span class="line">  Continuing at 53493</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905</span><br><span class="line">  Match failed at index 53919</span><br><span class="line">  Continuing at 53946</span><br><span class="line">  TypeSwitch[i32] from 53948 to 54007</span><br><span class="line">  Morphed node: t25: i32,i32 = ADD32ri t23, TargetConstant:i32&lt;-20&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 122140</span><br><span class="line">  Match failed at index 122148</span><br><span class="line">  Continuing at 122164</span><br><span class="line">  Match failed at index 122167</span><br><span class="line">  Continuing at 122183</span><br><span class="line">  Morphed node: t23: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t15</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 5</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 13, continuing at 73</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 74, continuing at 134</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135, continuing at 178</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 179, continuing at 222</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 223, continuing at 283</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 284, continuing at 327</span><br><span class="line">  Match failed at index 332</span><br><span class="line">  Continuing at 350</span><br><span class="line">  Match failed at index 351</span><br><span class="line">  Continuing at 373</span><br><span class="line">  Match failed at index 374</span><br><span class="line">  Continuing at 417</span><br><span class="line">  Match failed at index 418</span><br><span class="line">  Continuing at 461</span><br><span class="line">  Match failed at index 462</span><br><span class="line">  Continuing at 486</span><br><span class="line">  Match failed at index 487</span><br><span class="line">  Continuing at 530</span><br><span class="line">  Match failed at index 531</span><br><span class="line">  Continuing at 591</span><br><span class="line">  Match failed at index 592</span><br><span class="line">  Continuing at 652</span><br><span class="line">  Match failed at index 653</span><br><span class="line">  Continuing at 697</span><br><span class="line">  Match failed at index 698</span><br><span class="line">  Continuing at 758</span><br><span class="line">  Match failed at index 759</span><br><span class="line">  Continuing at 783</span><br><span class="line">  Match failed at index 784</span><br><span class="line">  Continuing at 808</span><br><span class="line">  Match failed at index 809</span><br><span class="line">  Continuing at 833</span><br><span class="line">  Match failed at index 834</span><br><span class="line">  Continuing at 858</span><br><span class="line">  Match failed at index 859</span><br><span class="line">  Continuing at 883</span><br><span class="line">  Match failed at index 884</span><br><span class="line">  Continuing at 908</span><br><span class="line">  Match failed at index 909</span><br><span class="line">  Continuing at 942</span><br><span class="line">  Match failed at index 943</span><br><span class="line">  Continuing at 976</span><br><span class="line">  Continuing at 977</span><br><span class="line">  OpcodeSwitch from 980 to 3569</span><br><span class="line">  Match failed at index 3573</span><br><span class="line">  Continuing at 4244</span><br><span class="line">  Match failed at index 4253</span><br><span class="line">  Continuing at 4292</span><br><span class="line">  Match failed at index 4296</span><br><span class="line">  Continuing at 4335</span><br><span class="line">  Match failed at index 4339</span><br><span class="line">  Continuing at 4377</span><br><span class="line">  Match failed at index 4378</span><br><span class="line">  Continuing at 4421</span><br><span class="line">  Continuing at 4422</span><br><span class="line">  Match failed at index 4424</span><br><span class="line">  Continuing at 4537</span><br><span class="line">  Match failed at index 4540</span><br><span class="line">  Continuing at 4652</span><br><span class="line">  Continuing at 10391</span><br><span class="line">  Match failed at index 10395</span><br><span class="line">  Continuing at 11659</span><br><span class="line">  Match failed at index 11662</span><br><span class="line">  Continuing at 12194</span><br><span class="line">  Match failed at index 12195</span><br><span class="line">  Continuing at 12278</span><br><span class="line">  Match failed at index 12279</span><br><span class="line">  Continuing at 12362</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 12368, continuing at 12468</span><br><span class="line">  Match failed at index 12471</span><br><span class="line">  Continuing at 12493</span><br><span class="line">  Match failed at index 12496</span><br><span class="line">  Continuing at 12518</span><br><span class="line">  Match failed at index 12526</span><br><span class="line">  Continuing at 12542</span><br><span class="line">  Match failed at index 12543</span><br><span class="line">  Continuing at 12568</span><br><span class="line">  Continuing at 12569</span><br><span class="line">  Match failed at index 12572</span><br><span class="line">  Continuing at 12704</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 12709, continuing at 12728</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 12729, continuing at 12748</span><br><span class="line">  Morphed node: t15: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep.us, !tbaa !17)&gt; t5, TargetConstant:i8&lt;4&gt;, t3, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t12, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t47: i64,i32 = X86ISD::SUB t32, Constant:i64&lt;1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 114065</span><br><span class="line">  Match failed at index 114073</span><br><span class="line">  Continuing at 114269</span><br><span class="line">  Match failed at index 114272</span><br><span class="line">  Continuing at 114372</span><br><span class="line">  Match failed at index 114373</span><br><span class="line">  Continuing at 114475</span><br><span class="line">  Continuing at 114476</span><br><span class="line">  Match failed at index 114477</span><br><span class="line">  Continuing at 114578</span><br><span class="line">  Match failed at index 114597</span><br><span class="line">  Continuing at 114638</span><br><span class="line">  Morphed node: t47: i64,i32 = SUB64ri32 t32, TargetConstant:i64&lt;1&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t20: i64 = sign_extend t17</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135712</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758</span><br><span class="line">  Morphed node: t20: i64 = MOVSX64rr32 t17</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t32: i64 = add t30, Constant:i64&lt;-1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Match failed at index 53496</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  TypeSwitch[i64] from 53807 to 53882</span><br><span class="line">  Morphed node: t32: i64,i32 = DEC64r t30</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t12: i32 = add t10, Constant:i32&lt;-10&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i32] from 53459 to 53462</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478</span><br><span class="line">  Match failed at index 53481</span><br><span class="line">  Continuing at 53493</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905</span><br><span class="line">  Match failed at index 53919</span><br><span class="line">  Continuing at 53946</span><br><span class="line">  TypeSwitch[i32] from 53948 to 54007</span><br><span class="line">  Morphed node: t12: i32,i32 = ADD32ri t10, TargetConstant:i32&lt;-10&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t3: i64 = sign_extend t2</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135712</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758</span><br><span class="line">  Morphed node: t3: i64 = MOVSX64rr32 t2</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t17: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i32] from 53459 to 53462</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478</span><br><span class="line">  Match failed at index 53481</span><br><span class="line">  Continuing at 53493</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  TypeSwitch[i32] from 53706 to 53757</span><br><span class="line">  Morphed node: t17: i32,i32 = INC32r t2</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t48: i8 = TargetConstant&lt;15&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t41: ch = BasicBlock&lt;._crit_edge.us 0x60c587dbb138&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t38: ch = BasicBlock&lt; 0x60c587dbaf00&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t33: i64 = Register %19</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t29: i64 = Register %14</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t26: i32 = Register %18</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t18: i32 = Register %17</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t9: i32 = Register %15</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t4: i64 = Register %12</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i32 = Register %16</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.4 'solve_:'</span><br><span class="line">SelectionDAG has 40 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t2: i32,ch = CopyFromReg t0, Register:i32 %16</span><br><span class="line">  t5: i64,ch = CopyFromReg t0, Register:i64 %12</span><br><span class="line">  t17: i32,i32 = INC32r t2</span><br><span class="line">    t30: i64,ch = CopyFromReg t0, Register:i64 %14</span><br><span class="line">  t32: i64,i32 = DEC64r t30</span><br><span class="line">  t20: i64 = MOVSX64rr32 t17</span><br><span class="line">      t3: i64 = MOVSX64rr32 t2</span><br><span class="line">        t10: i32,ch = CopyFromReg t0, Register:i32 %15</span><br><span class="line">      t12: i32,i32 = ADD32ri t10, TargetConstant:i32&lt;-10&gt;</span><br><span class="line">    t15: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep.us, !tbaa !17)&gt; t5, TargetConstant:i8&lt;4&gt;, t3, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t12, t0</span><br><span class="line">  t23: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t15</span><br><span class="line">  t25: i32,i32 = ADD32ri t23, TargetConstant:i32&lt;-20&gt;</span><br><span class="line">      t19: ch = CopyToReg t0, Register:i32 %17, t17</span><br><span class="line">      t27: ch = CopyToReg t0, Register:i32 %18, t25</span><br><span class="line">      t34: ch = CopyToReg t0, Register:i64 %19, t32</span><br><span class="line">      t28: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t25, t23:1</span><br><span class="line">    t39: ch = TokenFactor t19, t27, t34, t28</span><br><span class="line">    t47: i64,i32 = SUB64ri32 t32, TargetConstant:i64&lt;1&gt;</span><br><span class="line">  t52: ch,glue = CopyToReg t39, Register:i32 $eflags, t47:1</span><br><span class="line">  t56: i32 = Register $noreg</span><br><span class="line">    t49: ch = JCC_1 BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t52, t52:1</span><br><span class="line">  t42: ch = JMP_1 BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;, t49</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 3</span><br><span class="line">Node 0 : (0x60c587dbb000, 2147483667)</span><br><span class="line">Node 1 : (0x60c587dbb068, 2147483666)</span><br><span class="line">Node 2 : (0x60c587dbb0d0, 2147483665)</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 21 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">        t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">        t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">      t17: ch = TokenFactor t6, t12</span><br><span class="line">      t15: i1 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">    t18: ch = brcond t17, t15, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;</span><br><span class="line">  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 21 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">        t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">        t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">      t17: ch = TokenFactor t6, t12</span><br><span class="line">      t15: i1 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">    t18: ch = brcond t17, t15, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;</span><br><span class="line">  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 23 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">        t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">        t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">      t17: ch = TokenFactor t6, t12</span><br><span class="line">        t21: i8 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">      t24: i8 = and t21, Constant:i8&lt;1&gt;</span><br><span class="line">    t18: ch = brcond t17, t24, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;</span><br><span class="line">  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized type-legalized selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 21 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">        t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">        t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">      t17: ch = TokenFactor t6, t12</span><br><span class="line">      t21: i8 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch</span><br><span class="line">    t18: ch = brcond t17, t21, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;</span><br><span class="line">  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 21 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">        t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">        t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">      t17: ch = TokenFactor t6, t12</span><br><span class="line">      t25: i64,i32 = X86ISD::SUB t8, Constant:i64&lt;1&gt;</span><br><span class="line">    t27: ch = X86ISD::BRCOND t17, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t25:1</span><br><span class="line">  t20: ch = br t27, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 21 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">            t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">          t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">        t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">        t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">      t17: ch = TokenFactor t6, t12</span><br><span class="line">      t25: i64,i32 = X86ISD::SUB t8, Constant:i64&lt;1&gt;</span><br><span class="line">    t27: ch = X86ISD::BRCOND t17, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t25:1</span><br><span class="line">  t20: ch = br t27, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.5 '._crit_edge.us'</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t20: ch = br t27, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 136351</span><br><span class="line">  Morphed node: t20: ch = JMP_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, t27</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t27: ch = X86ISD::BRCOND t17, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t25:1</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135091</span><br><span class="line">  Morphed node: t27: ch = JCC_1 BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t29, t29:1</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t17: ch = TokenFactor t6, t12</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i64] from 53459 to 53496</span><br><span class="line">  Match failed at index 53496</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804</span><br><span class="line">  TypeSwitch[i64] from 53807 to 53882</span><br><span class="line">  Morphed node: t10: i64,i32 = DEC64r nsw t8</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t25: i64,i32 = X86ISD::SUB t8, Constant:i64&lt;1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 114065</span><br><span class="line">  Match failed at index 114073</span><br><span class="line">  Continuing at 114269</span><br><span class="line">  Match failed at index 114272</span><br><span class="line">  Continuing at 114372</span><br><span class="line">  Match failed at index 114373</span><br><span class="line">  Continuing at 114475</span><br><span class="line">  Continuing at 114476</span><br><span class="line">  Match failed at index 114477</span><br><span class="line">  Continuing at 114578</span><br><span class="line">  Match failed at index 114597</span><br><span class="line">  Continuing at 114638</span><br><span class="line">  Morphed node: t25: i64,i32 = SUB64ri32 t8, TargetConstant:i64&lt;1&gt;</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t4: i32 = add t2, Constant:i32&lt;1&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 52329</span><br><span class="line">  Match failed at index 52333</span><br><span class="line">  Continuing at 52897</span><br><span class="line">  Match failed at index 52909</span><br><span class="line">  Continuing at 52941</span><br><span class="line">  Match failed at index 52945</span><br><span class="line">  Continuing at 52977</span><br><span class="line">  Match failed at index 52981</span><br><span class="line">  Continuing at 53012</span><br><span class="line">  Match failed at index 53013</span><br><span class="line">  Continuing at 53049</span><br><span class="line">  Continuing at 53050</span><br><span class="line">  Match failed at index 53053</span><br><span class="line">  Continuing at 53249</span><br><span class="line">  Continuing at 53250</span><br><span class="line">  Match failed at index 53253</span><br><span class="line">  Continuing at 53457</span><br><span class="line">  TypeSwitch[i32] from 53459 to 53462</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478</span><br><span class="line">  Match failed at index 53481</span><br><span class="line">  Continuing at 53493</span><br><span class="line">  Continuing at 53509</span><br><span class="line">  Match failed at index 53512</span><br><span class="line">  Continuing at 53531</span><br><span class="line">  Match failed at index 53533</span><br><span class="line">  Continuing at 53553</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659</span><br><span class="line">  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703</span><br><span class="line">  TypeSwitch[i32] from 53706 to 53757</span><br><span class="line">  Morphed node: t4: i32,i32 = INC32r t2</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t26: i8 = TargetConstant&lt;15&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t19: ch = BasicBlock&lt;._crit_edge57 0x60c587dbb238&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t16: ch = BasicBlock&lt;.lr.ph.us 0x60c587dbad30&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t11: i64 = Register %21</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t7: i64 = Register %10</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t5: i32 = Register %20</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i32 = Register %11</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.5 'solve_:._crit_edge.us'</span><br><span class="line">SelectionDAG has 22 nodes:</span><br><span class="line">  t0: ch,glue = EntryToken</span><br><span class="line">  t8: i64,ch = CopyFromReg t0, Register:i64 %10</span><br><span class="line">          t2: i32,ch = CopyFromReg t0, Register:i32 %11</span><br><span class="line">        t4: i32,i32 = INC32r t2</span><br><span class="line">      t6: ch = CopyToReg t0, Register:i32 %20, t4</span><br><span class="line">        t10: i64,i32 = DEC64r nsw t8</span><br><span class="line">      t12: ch = CopyToReg t0, Register:i64 %21, t10</span><br><span class="line">    t17: ch = TokenFactor t6, t12</span><br><span class="line">    t25: i64,i32 = SUB64ri32 t8, TargetConstant:i64&lt;1&gt;</span><br><span class="line">  t29: ch,glue = CopyToReg t17, Register:i32 $eflags, t25:1</span><br><span class="line">  t30: i32 = Register $noreg</span><br><span class="line">    t27: ch = JCC_1 BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t29, t29:1</span><br><span class="line">  t20: ch = JMP_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, t27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 2</span><br><span class="line">Node 0 : (0x60c587dbae30, 2147483669)</span><br><span class="line">Node 1 : (0x60c587dbae98, 2147483668)</span><br><span class="line"></span><br><span class="line">Initial selection DAG: %bb.6 'solve_:._crit_edge57'</span><br><span class="line">SelectionDAG has 3 nodes:</span><br><span class="line">    t0: ch,glue = EntryToken</span><br><span class="line">  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized lowered selection DAG: %bb.6 'solve_:._crit_edge57'</span><br><span class="line">SelectionDAG has 3 nodes:</span><br><span class="line">    t0: ch,glue = EntryToken</span><br><span class="line">  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Type-legalized selection DAG: %bb.6 'solve_:._crit_edge57'</span><br><span class="line">SelectionDAG has 3 nodes:</span><br><span class="line">    t0: ch,glue = EntryToken</span><br><span class="line">  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Legalized selection DAG: %bb.6 'solve_:._crit_edge57'</span><br><span class="line">SelectionDAG has 3 nodes:</span><br><span class="line">    t0: ch,glue = EntryToken</span><br><span class="line">  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Optimized legalized selection DAG: %bb.6 'solve_:._crit_edge57'</span><br><span class="line">SelectionDAG has 3 nodes:</span><br><span class="line">    t0: ch,glue = EntryToken</span><br><span class="line">  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">===== Instruction selection begins: %bb.6 '._crit_edge57'</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;</span><br><span class="line">ISEL: Starting pattern match</span><br><span class="line">  Initial Opcode index to 135073</span><br><span class="line">  Morphed node: t2: ch = RET TargetConstant:i32&lt;0&gt;, t0</span><br><span class="line">ISEL: Match complete!</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t1: i32 = TargetConstant&lt;0&gt;</span><br><span class="line"></span><br><span class="line">ISEL: Starting selection on root node: t0: ch,glue = EntryToken</span><br><span class="line"></span><br><span class="line">===== Instruction selection ends:</span><br><span class="line"></span><br><span class="line">Selected selection DAG: %bb.6 'solve_:._crit_edge57'</span><br><span class="line">SelectionDAG has 3 nodes:</span><br><span class="line">    t0: ch,glue = EntryToken</span><br><span class="line">  t2: ch = RET TargetConstant:i32&lt;0&gt;, t0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Total amount of phi nodes to update: 0</span><br><span class="line">*** MachineFunction at end of ISel ***</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Machine code <span class="keyword">for</span> <span class="keyword">function</span> solve_: IsSSA, TracksLiveness</span></span><br><span class="line">Frame Objects:</span><br><span class="line"><span class="meta prompt_">  fi#</span><span class="language-bash">0: variable sized, align=1, at location [SP+8]</span></span><br><span class="line">Function Live Ins: $rdi in %22, $rsi in %23, $rdx in %24, $rcx in %25, $r8 in %26</span><br><span class="line"></span><br><span class="line">bb.0 (%ir-block.5):</span><br><span class="line">  successors: %bb.1(0x50000000), %bb.6(0x30000000); %bb.1(62.50%), %bb.6(37.50%)</span><br><span class="line">  liveins: $rdi, $rsi, $rdx, $rcx, $r8</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">26:gr64 = COPY <span class="variable">$r8</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">25:gr64 = COPY <span class="variable">$rcx</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">24:gr64 = COPY <span class="variable">$rdx</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">23:gr64 = COPY <span class="variable">$rsi</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">22:gr64 = COPY <span class="variable">$rdi</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">27:gr32 = MOV32rm %22:gr64, 1, <span class="variable">$noreg</span>, 0, <span class="variable">$noreg</span> :: (load (s32) from %ir.0, !tbaa !3)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">28:gr32 = MOV32r0 implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line">  TEST32rr %27:gr32, %27:gr32, implicit-def $eflags</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">29:gr32 = CMOV32rr %28:gr32(tied-def 0), %27:gr32, 15, implicit <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">0:gr64 = SUBREG_TO_REG 0, killed %29:gr32, %subreg.sub_32bit</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">30:gr64_nosp = nuw nsw IMUL64rr %0:gr64(tied-def 0), %0:gr64, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">31:gr64 = nuw LEA64r <span class="variable">$noreg</span>, 4, killed %30:gr64_nosp, 15, <span class="variable">$noreg</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">32:gr64 = AND64ri32 %31:gr64(tied-def 0), -16, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line">  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">33:gr64 = COPY <span class="variable">$rsp</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">1:gr64 = SUB64rr %33:gr64(tied-def 0), killed %32:gr64, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  $</span><span class="language-bash">rsp = COPY %1:gr64</span></span><br><span class="line">  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">34:gr64_nosp = MOVSX64rm32 %25:gr64, 1, <span class="variable">$noreg</span>, 0, <span class="variable">$noreg</span> :: (load (s32) from %ir.3, !tbaa !9)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">35:gr64 = MOVSX64rm32 %23:gr64, 4, %34:gr64_nosp, -4, <span class="variable">$noreg</span> :: (load (s32) from %ir.14, !tbaa !11)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">2:gr32 = COPY %35.sub_32bit:gr64</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">36:gr64 = MOVSX64rm32 %24:gr64, 4, %34:gr64_nosp, -4, <span class="variable">$noreg</span> :: (load (s32) from %ir.17, !tbaa !13)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">3:gr64 = SUB64rr %36:gr64(tied-def 0), %35:gr64, implicit-def <span class="variable">$eflags</span></span></span><br><span class="line">  JCC_1 %bb.6, 8, implicit $eflags</span><br><span class="line">  JMP_1 %bb.1</span><br><span class="line"></span><br><span class="line">bb.1..lr.ph56:</span><br><span class="line">; predecessors: %bb.0</span><br><span class="line">  successors: %bb.2(0x50000000), %bb.6(0x30000000); %bb.2(62.50%), %bb.6(37.50%)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">37:gr64_nosp = MOVSX64rm32 %26:gr64, 1, <span class="variable">$noreg</span>, 0, <span class="variable">$noreg</span> :: (load (s32) from %ir.4, !tbaa !15)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">4:gr32 = MOV32rm %23:gr64, 4, %37:gr64_nosp, -4, <span class="variable">$noreg</span> :: (load (s32) from %ir.24, !tbaa !11)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">5:gr64_nosp = MOVSX64rr32 %4:gr32</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">6:gr64 = MOVSX64rm32 %24:gr64, 4, %37:gr64_nosp, -4, <span class="variable">$noreg</span> :: (load (s32) from %ir.27, !tbaa !13)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">38:gr64 = SUB64rr %6:gr64(tied-def 0), %5:gr64_nosp, implicit-def <span class="variable">$eflags</span></span></span><br><span class="line">  JCC_1 %bb.6, 8, implicit $eflags</span><br><span class="line">  JMP_1 %bb.2</span><br><span class="line"></span><br><span class="line">bb.2..lr.ph.us.preheader:</span><br><span class="line">; predecessors: %bb.1</span><br><span class="line">  successors: %bb.3(0x80000000); %bb.3(100.00%)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">7:gr64 = nuw nsw INC64r %3:gr64(tied-def 0), implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">8:gr64 = ADD64ri32 %1:gr64(tied-def 0), -4, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">39:gr64 = SUB64rr %6:gr64(tied-def 0), %5:gr64_nosp, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">9:gr64 = ADD64ri32 %39:gr64(tied-def 0), 2, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"></span><br><span class="line">bb.3..lr.ph.us:</span><br><span class="line">; predecessors: %bb.2, %bb.5</span><br><span class="line">  successors: %bb.4(0x80000000); %bb.4(100.00%)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">10:gr64 = PHI %7:gr64, %bb.2, %21:gr64, %bb.5</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">11:gr32 = PHI %2:gr32, %bb.2, %20:gr32, %bb.5</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">40:gr64 = MOVSX64rr32 %11:gr32</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">41:gr64 = nsw DEC64r %40:gr64(tied-def 0), implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">42:gr64_nosp = nsw IMUL64rr %41:gr64(tied-def 0), %0:gr64, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">12:gr64 = LEA64r %8:gr64, 4, killed %42:gr64_nosp, 0, <span class="variable">$noreg</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">13:gr32 = MOV32rm %12:gr64, 4, %5:gr64_nosp, 0, <span class="variable">$noreg</span> :: (load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)</span></span><br><span class="line"></span><br><span class="line">bb.4 (%ir-block.39):</span><br><span class="line">; predecessors: %bb.3, %bb.4</span><br><span class="line">  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">14:gr64 = PHI %9:gr64, %bb.3, %19:gr64, %bb.4</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">15:gr32 = PHI %13:gr32, %bb.3, %18:gr32, %bb.4</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">16:gr32 = PHI %4:gr32, %bb.3, %17:gr32, %bb.4</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">43:gr64_nosp = MOVSX64rr32 %16:gr32</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">44:gr32 = ADD32ri %15:gr32(tied-def 0), -10, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line">  MOV32mr %12:gr64, 4, killed %43:gr64_nosp, 0, $noreg, killed %44:gr32 :: (store (s32) into %ir.gep.us, !tbaa !17)</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">17:gr32 = INC32r %16:gr32(tied-def 0), implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">45:gr64_nosp = MOVSX64rr32 %17:gr32</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">46:gr32 = MOV32rm %12:gr64, 4, %45:gr64_nosp, 0, <span class="variable">$noreg</span> :: (load (s32) from %ir.gep54.us, !tbaa !21)</span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">18:gr32 = ADD32ri %46:gr32(tied-def 0), -20, implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line">  MOV32mr %12:gr64, 4, %45:gr64_nosp, 0, $noreg, %18:gr32 :: (store (s32) into %ir.gep54.us, !tbaa !21)</span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">19:gr64 = DEC64r %14:gr64(tied-def 0), implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">47:gr64 = SUB64ri32 %19:gr64(tied-def 0), 1, implicit-def <span class="variable">$eflags</span></span></span><br><span class="line">  JCC_1 %bb.4, 15, implicit $eflags</span><br><span class="line">  JMP_1 %bb.5</span><br><span class="line"></span><br><span class="line">bb.5.._crit_edge.us:</span><br><span class="line">; predecessors: %bb.4</span><br><span class="line">  successors: %bb.3(0x7c000000), %bb.6(0x04000000); %bb.3(96.88%), %bb.6(3.12%)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">20:gr32 = INC32r %11:gr32(tied-def 0), implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">21:gr64 = nsw DEC64r %10:gr64(tied-def 0), implicit-def dead <span class="variable">$eflags</span></span></span><br><span class="line"><span class="meta prompt_">  %</span><span class="language-bash">48:gr64 = SUB64ri32 %10:gr64(tied-def 0), 1, implicit-def <span class="variable">$eflags</span></span></span><br><span class="line">  JCC_1 %bb.3, 15, implicit $eflags</span><br><span class="line">  JMP_1 %bb.6</span><br><span class="line"></span><br><span class="line">bb.6.._crit_edge57:</span><br><span class="line">; predecessors: %bb.0, %bb.1, %bb.5</span><br><span class="line"></span><br><span class="line">  RET 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">End machine code <span class="keyword">for</span> <span class="keyword">function</span> solve_.</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> LLVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> 后端 </tag>
            
            <tag> 指令选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构篇：设计链表</title>
      <link href="/2024/12/30/shu-ju-jie-gou-pian-she-ji-lian-biao/"/>
      <url>/2024/12/30/shu-ju-jie-gou-pian-she-ji-lian-biao/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构篇：设计链表："><a href="#数据结构篇：设计链表：" class="headerlink" title="数据结构篇：设计链表："></a>数据结构篇：设计链表：</h1><p><strong><a href="https://leetcode.cn/problems/design-linked-list/">707. 设计链表</a></strong>(中等)</p><p>你可以选择使用单链表或者双链表，设计并实现自己的链表。</p><p>单链表中的节点应该具备两个属性：<code>val</code> 和 <code>next</code> 。<code>val</code> 是当前节点的值，<code>next</code> 是指向下一个节点的指针/引用。</p><p>如果是双向链表，则还需要属性 <code>prev</code> 以指示链表中的上一个节点。假设链表中的所有节点下标从 <strong>0</strong> 开始。</p><p>实现 <code>MyLinkedList</code> 类：</p><ul><li><code>MyLinkedList()</code> 初始化 <code>MyLinkedList</code> 对象。</li><li><code>int get(int index)</code> 获取链表中下标为 <code>index</code> 的节点的值。如果下标无效，则返回 <code>-1</code> 。</li><li><code>void addAtHead(int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。</li><li><code>void addAtTail(int val)</code> 将一个值为 <code>val</code> 的节点追加到链表中作为链表的最后一个元素。</li><li><code>void addAtIndex(int index, int val)</code> 将一个值为 <code>val</code> 的节点插入到链表中下标为 <code>index</code> 的节点之前。如果 <code>index</code> 等于链表的长度，那么该节点会被追加到链表的末尾。如果 <code>index</code> 比长度更大，该节点将 <strong>不会插入</strong> 到链表中。</li><li><code>void deleteAtIndex(int index)</code> 如果下标有效，则删除链表中下标为 <code>index</code> 的节点。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListedNode</span>{</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListedNode * next;</span><br><span class="line">        <span class="built_in">ListedNode</span>(<span class="type">int</span> val):<span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">NULL</span>){}</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() {</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">ListedNode</span>(<span class="number">0</span>);</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index &gt; (_size - <span class="number">1</span>)||index&lt;<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }</span><br><span class="line">        ListedNode * cur = _dummyHead -&gt; next;</span><br><span class="line">        <span class="keyword">while</span>(index){</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            index--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListedNode * newNode = <span class="keyword">new</span> <span class="built_in">ListedNode</span>(val);</span><br><span class="line">        newNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListedNode * newNode = <span class="keyword">new</span> <span class="built_in">ListedNode</span>(val);</span><br><span class="line">        ListedNode * cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">NULL</span>){</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index &gt; _size) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span>) index = <span class="number">0</span>;</span><br><span class="line">        ListedNode * newNode = <span class="keyword">new</span> <span class="built_in">ListedNode</span>(val);</span><br><span class="line">        ListedNode * cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--){</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        newNode-&gt;next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = newNode;</span><br><span class="line">        _size++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=_size || index &lt; <span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        ListedNode * cur = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--){</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListedNode * tmp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tmp;</span><br><span class="line">        tmp = <span class="literal">NULL</span>;</span><br><span class="line">        _size--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">    ListedNode* _dummyHead;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构篇：链表</title>
      <link href="/2024/12/29/shu-ju-jie-gou-pian-lian-biao/"/>
      <url>/2024/12/29/shu-ju-jie-gou-pian-lian-biao/</url>
      
        <content type="html"><![CDATA[<h3 id="数据结构篇：-链表"><a href="#数据结构篇：-链表" class="headerlink" title="数据结构篇： 链表"></a>数据结构篇： 链表</h3><p>本文记录刷力扣题的过程</p><p><strong><a href="https://leetcode.cn/problems/remove-linked-list-elements/">203. 移除链表元素</a></strong></p><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> </p><p>注意while循环里判断条件是<code>cur-&gt;next!= NULL</code>只有这是因为你从上一个节点进行判断才能删除值为<code>val</code>的节点</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>{</span><br><span class="line">        ListNode * dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode * cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!= <span class="literal">NULL</span>){</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val ==val ){</span><br><span class="line">                ListNode * tmp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> tmp;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span>{</span><br><span class="line">                cur=cur-&gt;next;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></strong></p><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode * temp;</span><br><span class="line">        ListNode * pre = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode * cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur){</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></strong>(中等)</p><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>{</span><br><span class="line">        ListNode * dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode * cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next!=<span class="literal">NULL</span> &amp;&amp; cur-&gt;next-&gt;next!=<span class="literal">NULL</span>){</span><br><span class="line">            ListNode * temp1 = cur-&gt;next;</span><br><span class="line">            ListNode * temp2 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = temp1;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = temp2;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        ListNode * result = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></strong>(中等)</p><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><p>这里需要注意的是为什么有个格外的<code>p = p-&gt;next;</code>这是因为，while循环里判断条件是p，我们需要让pre少走一步，走到他的前驱节点才能进行删除</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>{</span><br><span class="line">ListNode * dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode * pre = dummyHead;</span><br><span class="line">        ListNode * p = pre;</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; p!=<span class="literal">NULL</span>){</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            n--;</span><br><span class="line">        }</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>){</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">面试题 02.07. 链表相交</a></strong></p><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p><p>图示两个链表在节点 <code>c1</code> 开始相交<strong>：</strong></p><p><img src="C:\Users\llj\AppData\Roaming\Typora\typora-user-images\image-20241229223037366.png" alt="image-20241229223037366"></p><p>题目数据 <strong>保证</strong> 整个链式结构中不存在环。</p><p><strong>注意</strong>，函数返回结果后，链表必须 <strong>保持其原始结构</strong> 。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>{</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) { <span class="comment">// 求链表A的长度</span></span><br><span class="line">            lenA++;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">while</span> (curB != <span class="literal">NULL</span>) { <span class="comment">// 求链表B的长度</span></span><br><span class="line">            lenB++;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">// 让curA为最长链表的头，lenA为其长度</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) {</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 求长度差</span></span><br><span class="line">        <span class="type">int</span> gap = lenA - lenB;</span><br><span class="line">        <span class="comment">// 让curA和curB在同一起点上（末尾位置对齐）</span></span><br><span class="line">        <span class="keyword">while</span> (gap--) {</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 遍历curA 和 curB，遇到相同则直接返回</span></span><br><span class="line">        <span class="keyword">while</span> (curA != <span class="literal">NULL</span>) {</span><br><span class="line">            <span class="keyword">if</span> (curA == curB) {</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            }</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></strong>(中等)</p><p>这题有点绕，可以看代码随想录的动画演示视频：</p><blockquote><p><a href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF">https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E6%80%9D%E8%B7%AF</a></p></blockquote><p>给定一个链表的头节点  <code>head</code> ，返回链表开始入环的第一个节点。 <em>如果链表无环，则返回 <code>null</code>。</em></p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（<strong>索引从 0 开始</strong>）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p><strong>不允许修改</strong> 链表。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p><blockquote><p>输入：head = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。</p></blockquote><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>{</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) {</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">// 快慢指针相遇，此时从head 和 相遇点，同时查找直至相遇</span></span><br><span class="line">            <span class="keyword">if</span> (slow == fast) {</span><br><span class="line">                ListNode* index1 = fast;</span><br><span class="line">                ListNode* index2 = head;</span><br><span class="line">                <span class="keyword">while</span> (index1 != index2) {</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">return</span> index2; <span class="comment">// 返回环的入口</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++篇：纯虚函数与抽象类</title>
      <link href="/2024/12/29/c-pian-chun-xu-han-shu-yu-chou-xiang-lei/"/>
      <url>/2024/12/29/c-pian-chun-xu-han-shu-yu-chou-xiang-lei/</url>
      
        <content type="html"><![CDATA[<h1 id="C-：纯虚函数与抽象类"><a href="#C-：纯虚函数与抽象类" class="headerlink" title="C++：纯虚函数与抽象类"></a>C++：纯虚函数与抽象类</h1><h2 id="1-纯虚函数与抽象类"><a href="#1-纯虚函数与抽象类" class="headerlink" title="1.纯虚函数与抽象类"></a>1.纯虚函数与抽象类</h2><p>C++中的纯虚函数(或抽象函数)是我们没有实现的虚函数！我们只需声明它! 通过声明中赋值0来声明纯虚函数！</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line">Class A {</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="comment">/* Other members */</span></span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure><ul><li>纯虚函数：没有函数体的虚函数</li><li>抽象类：包含纯虚函数的类</li></ul><p>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象,抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file abstreact_base.cpp</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> * C++中的纯虚函数(或抽象函数)是我们没有实现的虚函数！我们只需声明它!通过声明中赋值0来声明纯虚函数！</span></span><br><span class="line"><span class="comment"> * 纯虚函数：没有函数体的虚函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AbstractBase</span> {</span><br><span class="line">  <span class="comment">// Data members of class</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Pure Virtual Function</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Other members */</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file pure_virtual.cpp</span></span><br><span class="line"><span class="comment"> * @brief 纯虚函数：没有函数体的虚函数</span></span><br><span class="line"><span class="comment"> * 抽象类：包含纯虚函数的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 说明抽象类不能定义对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 1. 抽象类只能作为基类来派生新类使用</span></span><br><span class="line"><span class="comment">   * 2. 抽象类的指针和引用-&gt;由抽象类派生出来的类的对象！</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  A a; <span class="comment">// error 抽象类，不能创建对象</span></span><br><span class="line"></span><br><span class="line">  A *a1; <span class="comment">// ok 可以定义抽象类的指针</span></span><br><span class="line"></span><br><span class="line">  A *a2 = <span class="keyword">new</span> <span class="built_in">A</span>(); <span class="comment">// error, A是抽象类，不能创建对象</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-实现抽象类"><a href="#2-实现抽象类" class="headerlink" title="2.实现抽象类"></a>2.实现抽象类</h2><p>抽象类中：在成员函数内可以调用纯虚函数，在构造函数/析构函数内部不能使用纯虚函数。</p><p>如果一个类从抽象类派生而来，它必须实现了基类中的所有纯虚函数，才能成为非抽象类。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// A为抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>{ <span class="keyword">this</span>-&gt;<span class="built_in">f</span>(); }</span><br><span class="line">    <span class="built_in">A</span>(){}  <span class="comment">// 构造函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>{ cout&lt;&lt;<span class="string">"B:f()"</span>&lt;&lt;endl;}  <span class="comment">// 实现了抽象类的纯虚函数</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h2 id="3-重要点"><a href="#3-重要点" class="headerlink" title="3.重要点"></a>3.重要点</h2><ul><li>纯虚函数使一个类变成抽象类</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file interesting_facts1.cpp</span></span><br><span class="line"><span class="comment"> * @brief 纯虚函数使一个类变成抽象类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  Test t; <span class="comment">// error! 不能创建抽象类的对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; } <span class="comment">// 普通成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     <span class="type">int</span> x; </span><br><span class="line">}; </span><br></pre></td></tr></tbody></table></figure><ul><li>抽象类类型的指针和引用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file interesting_facts2.cpp</span></span><br><span class="line"><span class="comment"> * @brief 抽象类类型的指针和引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 抽象类至少包含一个纯虚函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"In Derived \n"</span>; }</span><br><span class="line">  <span class="built_in">Derived</span>() {}</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  <span class="comment">// Base b;  //error! 不能创建抽象类的对象</span></span><br><span class="line">  <span class="comment">// Base *b = new Base(); error!</span></span><br><span class="line">  Base *bp = <span class="keyword">new</span> <span class="built_in">Derived</span>(); <span class="comment">// 抽象类的指针和引用 -&gt; 由抽象类派生出来的类的对象</span></span><br><span class="line">  bp-&gt;<span class="built_in">show</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file interesting_facts3.cpp</span></span><br><span class="line"><span class="comment"> * @brief 如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">//    void show() { }</span></span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  Derived</span><br><span class="line">      d; <span class="comment">// error!</span></span><br><span class="line">         <span class="comment">// 派生类没有实现纯虚函数，那么派生类也会变为抽象类，不能创建抽象类的对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>抽象类可以有构造函数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file interesting_facts4.cpp</span></span><br><span class="line"><span class="comment"> * @brief 抽象类可以有构造函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An abstract class with constructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">Base</span>(<span class="type">int</span> i) { x = i; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line">  <span class="type">int</span> y;</span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">当创建 Derived 类的对象时，会按照如下顺序执行：</span></span><br><span class="line"><span class="comment">调用基类构造函数：Base(i) 用 i 初始化 x。</span></span><br><span class="line"><span class="comment">初始化派生类成员变量：y 被赋值为 j。</span></span><br><span class="line"><span class="comment">执行派生类的构造函数体（如果有）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">Base</span>(i) { y = j; }</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"x = "</span> &lt;&lt; x &lt;&lt; <span class="string">", y = "</span> &lt;&lt; y; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>{</span><br><span class="line">  <span class="function">Derived <span class="title">d</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">  d.<span class="built_in">fun</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>构造函数不能是虚函数，而析构函数可以是虚析构函数</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file interesting_facts5.cpp</span></span><br><span class="line"><span class="comment"> * @brief 构造函数不能是虚函数，而析构函数可以是虚析构函数。</span></span><br><span class="line"><span class="comment"> * 例如：当基类指针指向派生类对象并删除对象时，我们可能希望调用适当的析构函数。如果析构函数不是虚拟的，则只能调用基类析构函数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在 C++ 中，当 基类指针 指向 派生类对象 时，如果通过基类指针删除对象，我们需要调用派生类的析构函数以正确释放派生类的资源。然而，如果基类的析构函数 不是虚函数，那么通过基类指针调用 delete 时，只会执行基类的析构函数，而 派生类的析构函数不会被调用，这可能导致资源泄漏或行为未定义。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Base</span>() { cout &lt;&lt; <span class="string">"Constructor: Base"</span> &lt;&lt; endl; }</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() { cout &lt;&lt; <span class="string">"Destructor : Base"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Derived</span>() { cout &lt;&lt; <span class="string">"Constructor: Derived"</span> &lt;&lt; endl; }</span><br><span class="line">  ~<span class="built_in">Derived</span>() { cout &lt;&lt; <span class="string">"Destructor : Derived"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">  Base *Var = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">  <span class="keyword">delete</span> Var;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++篇：const与static关键字（含两个面试问题）</title>
      <link href="/2024/12/29/c-pian-const-yu-static-guan-jian-zi-han-liang-ge-mian-shi-wen-ti/"/>
      <url>/2024/12/29/c-pian-const-yu-static-guan-jian-zi-han-liang-ge-mian-shi-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="C-篇：const与static关键字（含两个面试问题）"><a href="#C-篇：const与static关键字（含两个面试问题）" class="headerlink" title="C++篇：const与static关键字（含两个面试问题）"></a>C++篇：const与static关键字（含两个面试问题）</h1><h1 id="const与static关键字"><a href="#const与static关键字" class="headerlink" title="const与static关键字"></a>const与static关键字</h1><h2 id="1-const含义"><a href="#1-const含义" class="headerlink" title="1.const含义"></a>1.const含义</h2><p>常类型是指使用类型修饰符<strong>const</strong>说明的类型，常类型的变量或对象的值<strong>是不能被更新的。</strong></p><h2 id="2-const作用"><a href="#2-const作用" class="headerlink" title="2.const作用"></a>2.const作用</h2><ul><li>可以定义常量</li></ul><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a=<span class="number">100</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>类型检查</p><ul><li><p>const常量与<code>#define</code>宏定义常量的区别：</p><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 定义的宏常量（假设它不是花括号初始化器列表）同样存在类型。</span></span><br><span class="line">例如若写 <span class="meta">#<span class="keyword">define</span> FOURTY_TWO 42 ，则 FOURTY_TWO 的类型是 int 。具体的类型和各种字面量（整数、浮点、用户定义等）和运算符的结果类型有关。</span></span><br><span class="line"></span><br><span class="line">最后是遗漏的一点：</span><br><span class="line"><span class="type">const</span> 定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。其他情况下它只是一个 <span class="type">const</span> 限定的变量，不要将与常量混淆。</span><br></pre></td></tr></tbody></table></figure></li><li><p>const常量支持所有类型。</p></li><li><p>其他情况下它只是一个 <code>const</code> 限定的变量，不要将与常量混淆。</p></li></ul></li><li><p>防止修改，起保护作用，增加程序健壮性</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span>{</span><br><span class="line">    i++; <span class="comment">// error!</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>可以节省空间，避免不必要的内存分配</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">若用 <span class="type">const</span> 定义常量（类型为整数或枚举，必须以常量表达式初始化），则这种常量在非 odr 式使用（粗略来说是只使用其值）时不需要依赖其身为变量的身份，一定场合下甚至可以不需要定义（譬如作为类的 <span class="type">static</span> 成员对象）。</span><br><span class="line">编译器在作为常量处理它时，不会依赖“一份定义”，而是像是立即数一样使用它，它本身可能在机器码中被“拷贝”到多个地方，和 <span class="meta">#<span class="keyword">define</span> 定义的宏常量的结果相同。</span></span><br><span class="line">另一方面， <span class="type">const</span> 定义的常量由于是整数或枚举，所以直接变成机器码上的立即数往往性能更好。</span><br></pre></td></tr></tbody></table></figure><h2 id="3-const对象默认为文件局部变量"><a href="#3-const对象默认为文件局部变量" class="headerlink" title="3.const对象默认为文件局部变量"></a>3.const对象默认为文件局部变量</h2><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p><p>未被const修饰的变量在不同文件的访问</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">int</span> ext;</span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    std::cout&lt;&lt;(ext<span class="number">+10</span>)&lt;&lt;std::endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>const常量在不同文件的访问</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// extern_file1.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext=<span class="number">12</span>;</span><br><span class="line"><span class="comment">// extern_file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> ext;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ext&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>小结：<br>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p></blockquote><h2 id="4-定义常量"><a href="#4-定义常量" class="headerlink" title="4.定义常量"></a>4.定义常量</h2><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>; <span class="comment">// error: assignment of read-only variable ‘b’</span></span><br><span class="line"><span class="type">const</span> <span class="built_in">string</span> s = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i,j=<span class="number">0</span> <span class="comment">// error: uninitialized const ‘i’</span></span><br></pre></td></tr></tbody></table></figure><p>上述有两个错误：</p><ul><li>b 为常量，不可更改！</li><li>i 为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</li></ul><h2 id="5-指针与const"><a href="#5-指针与const" class="headerlink" title="5.指针与const"></a>5.指针与const</h2><p>与指针相关的const有四种：</p><figure class="highlight arduino"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> * a; <span class="comment">// 指向const对象的指针或者说指向常量的指针。</span></span><br><span class="line"><span class="type">char</span> <span class="type">const</span> * a; <span class="comment">// 同上</span></span><br><span class="line"><span class="type">char</span> * <span class="type">const</span> a; <span class="comment">// 指向类型对象的const指针。或者说常指针、const指针。</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> a; <span class="comment">// 指向const对象的const指针。</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>小结：</strong><br>如果<em>const</em>位于<code>*</code>的左侧，则const就是用来<strong>修饰指针所指向的变量，即指针指向为常量；</strong><br>如果const位于<code>*</code>的右侧，<strong><em>const</em>就是修饰指针本身，即指针本身是常量。</strong></p></blockquote><p>当指针被加上const特性，则指针不可改变指向的地址<br>当指向的目标特性为char，则内容可以透过指针被修改，如: *char=’y’;<br>当指向的目标特性为const char，则内容不可透过指针修改</p><p>具体使用如下：</p><p>（1） <strong>指向常量的指针</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line">*ptr = <span class="number">10</span>; <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p>ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</p><p>除此之外，也不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">void</span> * vp = &amp;p;</span><br><span class="line"><span class="type">void</span> *vp = &amp;p; <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p>另外一个重点是：<strong>允许把非const对象的地址赋给指向const对象的指针</strong>。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *ptr;</span><br><span class="line"><span class="type">int</span> val = <span class="number">3</span>;</span><br><span class="line">ptr = &amp;val; <span class="comment">// ok</span></span><br></pre></td></tr></tbody></table></figure><p>我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</p><p>我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *ptr1 = &amp;val;</span><br><span class="line">*ptr1=<span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><blockquote><p>小结：<br>1.对于指向常量的指针，不能通过指针来修改对象的值。<br>2.不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p></blockquote><p>（2） <strong>常指针</strong></p><p>const指针必须进行初始化，且const指针指向的值能修改，但指向不能修改。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>, num1=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">// const指针必须初始化！且const指针的指向不能修改</span></span><br><span class="line">    ptr = &amp;num1; <span class="comment">// error! const指针不能修改指向！</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码出现编译错误：const指针不能修改指向。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> num=<span class="number">0</span>, num1=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">// const指针必须初始化！且const指针的指向不能修改</span></span><br><span class="line">    *ptr = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码无事发生，正常输出1。</p><p>最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int<code>*</code> -&gt; int <code>*</code>错误！</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> * <span class="type">const</span> ptr=&amp;num; <span class="comment">// error! const int* -&gt; int*</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述若改为 const int <code>*</code>ptr或者改为const int <code>*</code>const ptr，都可以正常！</p><p>（3）<strong>指向常量的常指针</strong></p><p>理解完前两种情况，下面这个情况就比较好理解了：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">3</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> ptr = &amp;p; </span><br></pre></td></tr></tbody></table></figure><p>ptr是一个const指针，然后指向了一个int 类型的const对象。</p><h2 id="6-函数中使用const"><a href="#6-函数中使用const" class="headerlink" title="6.函数中使用const"></a>6.函数中使用const</h2><p><strong><u>const修饰函数返回值</u></strong></p><p>这个跟const修饰普通变量以及指针的含义基本相同：</p><p>（1）<strong>const int</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> <span class="title function_">func1</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure><p>这个本身无意义，因为参数返回本身就是赋值给其他的变量！</p><p>（2）<strong>const int*</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* <span class="title function_">func2</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure><p>指针指向的内容不变。</p><p>（3）<strong>int *const</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="type">const</span> <span class="title function_">func2</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure><p>指针本身不可变。</p><p><strong><u>const修饰函数参数</u></strong></p><p>（1）<strong>传递过来的参数及指针本身在函数内不可变，无意义！</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> var)</span>; <span class="comment">// 传递过来的参数不可变</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> *<span class="type">const</span> var)</span>; <span class="comment">// 指针本身不可变</span></span><br></pre></td></tr></tbody></table></figure><p>表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</p><p>输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</p><p>（2）<strong>参数指针所指内容为常量不可变</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">StringCopy</span><span class="params">(<span class="type">char</span> *dst, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></tbody></table></figure><p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p><p>（3）<strong>参数为引用，为了增加效率同时防止修改。(重要)</strong></p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">const</span> A &amp;a)</span></span><br></pre></td></tr></tbody></table></figure><p>对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p><p>为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。</p><blockquote><p>但是函数void func(A &amp;a) 存在一个缺点：</p><p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p></blockquote><p><strong>以此类推，是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</strong></p><blockquote><p>小结：<br>1.对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。</p><p>2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</p></blockquote><p><strong>以上解决了两个面试问题：</strong></p><ul><li>如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；</li><li>如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。</li></ul><h2 id="7-类中使用const"><a href="#7-类中使用const" class="headerlink" title="7.类中使用const"></a>7.类中使用const</h2><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p><p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。</p><p>对于类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i):<span class="built_in">apple_number</span>(i)</span><br><span class="line">{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.</p><p>例如：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// apple.cpp</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> people[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Apple</span>(<span class="type">int</span> i); </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> apple_number;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">};</span><br><span class="line"><span class="comment">// apple.cpp</span></span><br><span class="line">Apple::<span class="built_in">Apple</span>(<span class="type">int</span> i) : <span class="built_in">apple_number</span>(i)</span><br><span class="line">{</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Apple::add</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">take</span>(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Apple::add</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">take</span>(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Apple::take</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"take func "</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Apple::getCount</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">take</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//    add(); // error</span></span><br><span class="line">    <span class="keyword">return</span> apple_number;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">Apple <span class="title">a</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">getCount</span>() &lt;&lt; endl;</span><br><span class="line">    a.<span class="built_in">add</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="function"><span class="type">const</span> Apple <span class="title">b</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    b.<span class="built_in">add</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// main.cpp</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>编译：bazel run basic_content/const/class_const/first_example:main</p><p>主要 add() 没有const修饰</p></blockquote><p>此时报错，上面getCount()方法中调用了一个add方法，而add方法并非const修饰，所以运行报错。也就是说const成员函数只能访问const成员函数。</p><p>当调用改为：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> Apple <span class="title function_">b</span><span class="params">(<span class="number">3</span>)</span>;</span><br><span class="line">b.add(); <span class="comment">// error</span></span><br></pre></td></tr></tbody></table></figure><p>此时，可以证明的是const对象只能访问const成员函数。</p><p>我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：</p><p>第一：将常量定义与static结合，也就是：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number</span><br></pre></td></tr></tbody></table></figure><p>第二：在外面初始化：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> Apple::apple_number=<span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><p>当然，如果你使用c++11进行编译，直接可以在定义出初始化，可以直接写成：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> apple_number=<span class="number">10</span>;</span><br></pre></td></tr></tbody></table></figure><p>这两种都在c++11中支持！</p><p>编译的时候加上<code>-std=c++11</code>即可！</p><p>这里提到了static，下面简单的说一下：</p><p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</p><p>在类中声明：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> ap;</span><br></pre></td></tr></tbody></table></figure><p>在类实现文件中使用：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> Apple::ap=<span class="number">666</span></span><br></pre></td></tr></tbody></table></figure><p>对于此项，c++11不能进行声明并初始化，也就是上述使用方法。</p><h2 id="8-static的含义"><a href="#8-static的含义" class="headerlink" title="8.static的含义"></a>8.static的含义</h2><p>当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：</p><p><strong>静态变量：</strong> 函数中的变量，类中的变量</p><p><strong>静态类的成员：</strong> 类对象和类中的函数</p><p>现在让我们详细看一下静态的这些用法：</p><p><strong>静态变量</strong></p><ul><li>函数中的静态变量</li></ul><p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在C / C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">demo</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="comment">// static variable </span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line">cout &lt;&lt; count &lt;&lt; <span class="string">" "</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// value is updated and </span></span><br><span class="line"><span class="comment">// will be carried to next </span></span><br><span class="line"><span class="comment">// function calls </span></span><br><span class="line">count++; </span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) </span><br><span class="line"><span class="built_in">demo</span>(); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight basic"><table><tbody><tr><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br></pre></td></tr></tbody></table></figure><p>您可以在上面的程序中看到变量count被声明为static。因此，它的<strong>值通过函数调用来传递</strong>。每次调用函数时，都不会对变量计数进行初始化。</p><ul><li>类中的静态变量</li></ul><p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">{ </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line"><span class="built_in">Apple</span>() </span><br><span class="line">{ </span><br><span class="line"><span class="comment">// Do nothing </span></span><br><span class="line">}; </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">Apple obj1; </span><br><span class="line">Apple obj2; </span><br><span class="line">obj<span class="number">1.</span>i =<span class="number">2</span>; </span><br><span class="line">obj<span class="number">2.</span>i = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// prints value of i </span></span><br><span class="line">cout &lt;&lt; obj<span class="number">1.</span>i&lt;&lt;<span class="string">" "</span>&lt;&lt;obj<span class="number">2.</span>i; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>您可以在上面的程序中看到我们已经尝试为多个对象创建静态变量i的多个副本。但这并没有发生。因此，类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，如下所示：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">{ </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="type">static</span> <span class="type">int</span> i; </span><br><span class="line"></span><br><span class="line"><span class="built_in">Apple</span>() </span><br><span class="line">{ </span><br><span class="line"><span class="comment">// Do nothing </span></span><br><span class="line">}; </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Apple::i = <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">Apple obj; </span><br><span class="line"><span class="comment">// prints value of i </span></span><br><span class="line">cout &lt;&lt; obj.i; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>静态成员</strong></p><ul><li>类对象为静态</li></ul><p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p><p>考虑以下程序，其中对象是非静态的。</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> </span></span><br><span class="line"><span class="class">{</span> </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line">public: </span><br><span class="line">Apple() </span><br><span class="line">{ </span><br><span class="line">i = <span class="number">0</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside Constructor\n"</span>; </span><br><span class="line">} </span><br><span class="line">~Apple() </span><br><span class="line">{ </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Inside Destructor\n"</span>; </span><br><span class="line">} </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">{ </span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">{ </span><br><span class="line">Apple obj; </span><br><span class="line">} </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"End of main\n"</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">Inside Constructor</span><br><span class="line">Inside Destructor</span><br><span class="line">End of main</span><br></pre></td></tr></tbody></table></figure><p>在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。 如果我们将对象声明为静态，现在让我们看看输出的变化。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">{ </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line"><span class="built_in">Apple</span>() </span><br><span class="line">{ </span><br><span class="line">i = <span class="number">0</span>; </span><br><span class="line">cout &lt;&lt; <span class="string">"Inside Constructor\n"</span>; </span><br><span class="line">} </span><br><span class="line">~<span class="built_in">Apple</span>() </span><br><span class="line">{ </span><br><span class="line">cout &lt;&lt; <span class="string">"Inside Destructor\n"</span>; </span><br><span class="line">} </span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">if</span> (x==<span class="number">0</span>) </span><br><span class="line">{ </span><br><span class="line"><span class="type">static</span> Apple obj; </span><br><span class="line">} </span><br><span class="line">cout &lt;&lt; <span class="string">"End of main\n"</span>; </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight delphi"><table><tbody><tr><td class="code"><pre><span class="line">Inside <span class="function"><span class="keyword">Constructor</span></span></span><br><span class="line"><span class="function"><span class="title">End</span> <span class="title">of</span> <span class="title">main</span></span></span><br><span class="line"><span class="function"><span class="title">Inside</span> <span class="title">Destructor</span></span></span><br></pre></td></tr></tbody></table></figure><p>您可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p><blockquote><p>第一个例子，对象的范围只在if块内，所以函数的周期子在if块内已经结束，</p><p>而第二个例子，使用static进行修饰，对象的生命周期为整个main函数，因此在最终才进行析构函数</p></blockquote><ul><li>类中的静态函数</li></ul><p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但<strong>建议使用类名和范围解析运算符调用静态成员</strong>。</p><p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Apple</span> </span><br><span class="line">{ </span><br><span class="line">    <span class="keyword">public</span>: </span><br><span class="line">        <span class="comment">// static member function </span></span><br><span class="line">        <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">printMsg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>{</span><br><span class="line">            cout&lt;&lt;<span class="string">"Welcome to Apple!"</span>; </span><br><span class="line">        }</span><br><span class="line">}; </span><br><span class="line"></span><br><span class="line"><span class="comment">// main function </span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">    <span class="comment">// invoking a static member function </span></span><br><span class="line">    Apple::<span class="built_in">printMsg</span>(); </span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight applescript"><table><tbody><tr><td class="code"><pre><span class="line">Welcome <span class="keyword">to</span> Apple!</span><br></pre></td></tr></tbody></table></figure><p><strong>限定访问范围</strong> static还有限定访问范围的作用（类似于匿名名字空间）</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// source1.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* msg = <span class="string">"Hello World!\n"</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// source2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span>* msg;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, msg);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>g++对于上面两个代码文件是可以正常编译并且打印Hello World!，但如果给source1.cpp中的msg加上static，则会导致undefined reference to ‘msg’的编译错误：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// source1.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* msg = <span class="string">"Hello World!\n"</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">sayHello</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++篇：一篇文章搞懂inline关键字</title>
      <link href="/2024/12/28/c-pian-yi-pian-wen-zhang-gao-dong-inline-guan-jian-zi/"/>
      <url>/2024/12/28/c-pian-yi-pian-wen-zhang-gao-dong-inline-guan-jian-zi/</url>
      
        <content type="html"><![CDATA[<h1 id="C-篇：一篇文章搞懂inline关键字"><a href="#C-篇：一篇文章搞懂inline关键字" class="headerlink" title="C++篇：一篇文章搞懂inline关键字"></a>C++篇：一篇文章搞懂inline关键字</h1><h1 id="inline"><a href="#inline" class="headerlink" title="inline"></a>inline</h1><h2 id="1-类中内联"><a href="#1-类中内联" class="headerlink" title="1.类中内联"></a>1.类中内联</h2><p>头文件中声明方法</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">int</span> x)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * brief 类中定义了的函数是隐式内联函数,声明要想成为内联函数，必须在实现处(定义处)加inline关键字。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * param x</span></span><br><span class="line"><span class="comment">     * param y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">///&lt; 定义即隐式内联函数！</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">    </span><br><span class="line">    };</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">int</span> x)</span></span>; <span class="comment">///&lt; 声明后，要想成为内联函数，必须在定义处加inline关键字。  </span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><p>实现文件中定义内联函数：</p><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"inline.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * brief inline要起作用,inline要与函数定义放在一起,inline是一种“用于实现的关键字,而不是用于声明的关键字”</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * param x</span></span><br><span class="line"><span class="comment"> * param y</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>;  <span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> <span class="comment">// 函数定义</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义处加inline关键字，推荐这种写法！</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">A::f1</span><span class="params">(<span class="type">int</span> x)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="built_in">Foo</span>(<span class="number">1</span>,<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译器对 inline 函数的处理步骤</span></span><br><span class="line"><span class="comment"> * 将 inline 函数体复制到 inline 函数调用点处；</span></span><br><span class="line"><span class="comment"> * 为所用 inline 函数中的局部变量分配内存空间；</span></span><br><span class="line"><span class="comment"> * 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</span></span><br><span class="line"><span class="comment"> * 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></tbody></table></figure><p>内联能提高函数效率，但并不是所有的函数都定义成内联函数！内联是以代码膨胀(复制)为代价，<strong>仅仅省去了函数调用的开销</strong>，从而提高函数的执行效率。</p><ul><li>如果执行函数体内代码的时间相比于函数调用的开销较大，那么效率的收获会更少！</li><li>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</li></ul><p>以下情况不宜用内联：</p><p>（1）如果函数体内的代码比较长，使得内联将导致内存消耗代价比较高。</p><p>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。</p><h2 id="2-虚函数（virtual）可以是内联函数（inline）吗？"><a href="#2-虚函数（virtual）可以是内联函数（inline）吗？" class="headerlink" title="2.虚函数（virtual）可以是内联函数（inline）吗？"></a>2.虚函数（virtual）可以是内联函数（inline）吗？</h2><ul><li>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。</li><li>内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。</li><li><code>inline virtual</code> 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 <code>Base::who()</code>），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。</li></ul><figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">virtual</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"I am Base\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">who</span><span class="params">()</span>  <span class="comment">// 不写inline时隐式内联</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"I am Derived\n"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 </span></span><br><span class="line">    Base b;</span><br><span class="line">    b.<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  </span></span><br><span class="line">    Base *ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    ptr-&gt;<span class="built_in">who</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">} </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cplus </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
