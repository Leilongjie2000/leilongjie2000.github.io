<!DOCTYPE html>
<html lang=zh-CN data-theme="light">
	
<script src="/js/plugins/toggleTheme.js"></script>

	<script>
		setTheme();
	</script>
	<head>
		
<title>C++篇：const与static关键字（含两个面试问题） | </title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/images/icon/head.jpg">
<link href="/css/plugins/print.css" media="print" rel="stylesheet" />

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="Cplus,">
<meta name="description" content="">



<script src="/js/plugins/jquery.min.js"></script>


<script src="/js/plugins/hljs.min.js"></script>


<script src="/js/plugins/init.js"></script>


<script src="/js/plugins/hide.js"></script>


<script src="/js/plugins/tabs.js"></script>



    







    

	<meta name="generator" content="Hexo 7.3.0"></head>

	<body>
		<header class="sticky-header">
	<nav>
		<div class="nav-left">
			<a href="/" class="logo">
				<img no-lazy src="/images/headers_icon/雪屋.svg" alt="Quieter">
			</a>
			<ul class="breadcrumb" id="breadcrumb"></ul>
		</div>
		<div class="nav-right">
			<ul>
				
					<li>
						<a href="/">
						  主页
						</a>
					</li>
				
					<li>
						<a href="/categories">
						  类别
						</a>
					</li>
				
					<li>
						<a href="/tags">
						  标签
						</a>
					</li>
				
					<li>
						<a href="/archives">
						  归档
						</a>
					</li>
								  
			</ul>
		</div>
		<div class="nav-right-close">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
				<path fill="none" d="M0 0h24v24H0z" />
				<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
			</svg>
		</div>

		<div class="sidebar">
    <div class="topo">
        <p></p>
    </div>
    <ul>
        
        <li>
            <a href="/">
                主页
            </a>
        </li>
        
        <li>
            <a href="/categories">
                类别
            </a>
        </li>
        
        <li>
            <a href="/tags">
                标签
            </a>
        </li>
        
        <li>
            <a href="/archives">
                归档
            </a>
        </li>
        
    </ul>
    <div class="sidebar-footer">
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
        </a>
        
    </div>
</div>
<div class='shelter'>
    <script>
        $(function() {
            $('.nav-right-close > svg').click(function() {
                $('.sidebar').animate({
                    right: "0"
                }, 500);
                $('.shelter').fadeIn("slow");
            
                var element = $('.topo');
                element.addClass('custom-style');
            
                var links = null;
                if ("") {
                    links = "".split(',');
                } else {
                    links = "/images/random_top_img/1.jpg,/images/random_top_img/2.jpg,/images/random_top_img/3.jpg,/images/random_top_img/4.jpg,/images/random_top_img/5.jpg,/images/random_top_img/6.jpg,/images/random_top_img/7.jpg,/images/random_top_img/8.jpg,/images/random_top_img/9.jpg,/images/random_top_img/10.jpg,/images/random_top_img/11.jpg,/images/random_top_img/12.png,/images/random_top_img/13.png,/images/random_top_img/14.jpg,/images/random_top_img/15.jpg,/images/random_top_img/16.jpg,/images/random_top_img/17.jpg,/images/random_top_img/18.jpg,/images/random_top_img/19.jpg,/images/random_top_img/20.jpg,/images/random_top_img/21.jpg,/images/random_top_img/22.jpg,/images/random_top_img/23.jpg,/images/random_top_img/24.jpg".split(',');
                }
            
                var randomLink = links[Math.floor(Math.random() * links.length)];
                element.css('background-image', "url('" + randomLink + "')");
            });
          
            $('.shelter').click(function(e) {
                $('.sidebar').animate({
                    right: "-100%"
                }, 500);
                $('.shelter').fadeOut("slow");
            });
        });      
    </script>
</div>
	</nav>

	
		<div class="header-background"></div>
	

	<script>
		const name = 'post';
		const ul = document.querySelectorAll('.nav-right ul')[0];
		const lis = ul.querySelectorAll('li');

		if (name == 'home') {
			lis[0].classList.add('select');
		} else {
			for (let i = 0; i < lis.length; i++) {
				const li = lis[i];
				const a = li.querySelector('a');
				if (name === a.href.split('/')[3]) {
					li.classList.add('select');
				}
			}
		}
	</script>
	
	<script>
		var element = document.querySelector('.header-background');
		if(element) {
			element.classList.add('custom-style');
			var links = null;
			if("")
			{
				links = "".split(',');
			} else
			{
				links = "/images/random_top_img/1.jpg,/images/random_top_img/2.jpg,/images/random_top_img/3.jpg,/images/random_top_img/4.jpg,/images/random_top_img/5.jpg,/images/random_top_img/6.jpg,/images/random_top_img/7.jpg,/images/random_top_img/8.jpg,/images/random_top_img/9.jpg,/images/random_top_img/10.jpg,/images/random_top_img/11.jpg,/images/random_top_img/12.png,/images/random_top_img/13.png,/images/random_top_img/14.jpg,/images/random_top_img/15.jpg,/images/random_top_img/16.jpg,/images/random_top_img/17.jpg,/images/random_top_img/18.jpg,/images/random_top_img/19.jpg,/images/random_top_img/20.jpg,/images/random_top_img/21.jpg,/images/random_top_img/22.jpg,/images/random_top_img/23.jpg,/images/random_top_img/24.jpg".split(',');
			}
			var randomLink = links[Math.floor(Math.random() * links.length)];
			element.style.backgroundImage = "url('" + randomLink + "')";
		}
	</script>

	
<script src="/js/plugins/breadcrumb.js"></script>

	<script>
		var menus_title = [];
		
			menus_title.push({home: '主页'});
		
			menus_title.push({categories: '类别'});
		
			menus_title.push({tags: '标签'});
		
			menus_title.push({archives: '归档'});
		
		
			
				postsBreadcrumb(
					document.getElementById('breadcrumb'),
					"类别",
					"/categories",
					"Cplus",
					"/categories/Cplus"
				);
			
		
	</script>
</header>

<div class="main-wrapper">
    <main class="post">
        <header class="main-header">
	
		
			
				
<link rel="stylesheet" href="/css/plugins/fancybox.css">

				
<script src="/js/plugins/fancybox.umd.js"></script>

				
<script src="/js/plugins/fancybox.js"></script>

			
			<div class="post-header-background-content">
				<ul class="post-header-tag">
					
						
							<li><a href="/tags/Cplus"><span>Cplus</span></a></li>
						
					
				</ul>
				
				<h1>C++篇：const与static关键字（含两个面试问题）</h1>
		
				
		
				<div class="post-header-info">
					<svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
					xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
						<path
							d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
							p-id="2902" fill="#ffffff"></path>
					</svg>
					<div class="post-header-info-author">
						<a href="/about">LLJ</a>
					</div>
					
						<div class="post-header-info-categories">
							
								<a href="/categories/Cplus">Cplus</a>
							
						</div>
					
					<time>2024/12/29 15:25:23</time>
				</div>
		
				
					<div class="post-header-stat">
						<svg version="1.0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
						viewBox="0 0 200 200" enable-background="new 0 0 200 200" xml:space="preserve" width="20" height="20">
							<path fill="#FFFFFF" d="M187.2,165.6c0,2.6-2.1,4.7-4.7,4.7H17.5c-2.6,0-4.7-2.1-4.7-4.7s2.1-4.7,4.7-4.7h165.1
								C185.2,160.9,187.2,163,187.2,165.6z"/>
							<path fill="#FFFFFF" d="M17.5,29.7c2.6,0,4.7,2.1,4.7,4.7v131.2c0,2.6-2.1,4.7-4.7,4.7s-4.7-2.1-4.7-4.7V34.4
								C12.8,31.8,14.9,29.7,17.5,29.7z M77.9,91.5c1.8,1.8,1.8,4.8,0,6.6l-39.8,39.8c-1.9,1.8-4.9,1.7-6.6-0.2c-1.7-1.8-1.7-4.6,0-6.4
								l39.8-39.8C73.1,89.6,76,89.6,77.9,91.5z M169.9,70.2c1.6,2.1,1.1,5-0.9,6.5c0,0,0,0,0,0l-64.2,48.2c-2.1,1.5-5,1.1-6.6-0.9
								c-1.6-2.1-1.1-5,0.9-6.5c0,0,0,0,0,0l64.2-48.2C165.4,67.7,168.3,68.1,169.9,70.2L169.9,70.2z"/>
							<path fill="#FFFFFF" d="M104.6,124.5c-1.8,1.8-4.8,1.8-6.6,0L71.6,98.1c-1.8-1.8-1.8-4.8,0-6.6c1.8-1.8,4.8-1.8,6.6,0l26.3,26.3
								C106.4,119.6,106.4,122.6,104.6,124.5C104.6,124.4,104.6,124.4,104.6,124.5z"/>
						</svg>
		
						
							
<script src="/js/plugins/wordCount.js"></script>

							<p class="post-count">文字数：---</p>
						
		
						
							<p id="busuanzi_container_page_pv" style='display:none;'>阅读数：<span id="busuanzi_value_page_pv"></span></p>
						
					</div>
				
			</div>
		
	
</header>
        <div class="post-content article-container">
            <article class="post-content-info">
                <h1 id="C-篇：const与static关键字（含两个面试问题）"><a href="#C-篇：const与static关键字（含两个面试问题）" class="headerlink" title="C++篇：const与static关键字（含两个面试问题）"></a>C++篇：const与static关键字（含两个面试问题）</h1><h1 id="const与static关键字"><a href="#const与static关键字" class="headerlink" title="const与static关键字"></a>const与static关键字</h1><h2 id="1-const含义"><a href="#1-const含义" class="headerlink" title="1.const含义"></a>1.const含义</h2><p>常类型是指使用类型修饰符<strong>const</strong>说明的类型，常类型的变量或对象的值<strong>是不能被更新的。</strong></p>
<h2 id="2-const作用"><a href="#2-const作用" class="headerlink" title="2.const作用"></a>2.const作用</h2><ul>
<li>可以定义常量</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>类型检查</p>
<ul>
<li><p>const常量与<code>#define</code>宏定义常量的区别：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">#define 定义的宏常量（假设它不是花括号初始化器列表）同样存在类型。<br>例如若写 #define FOURTY_TWO 42 ，则 FOURTY_TWO 的类型是 int 。具体的类型和各种字面量（整数、浮点、用户定义等）和运算符的结果类型有关。<br><br>最后是遗漏的一点：<br>const 定义的变量只有类型为整数或枚举，且以常量表达式初始化时才能作为常量表达式。其他情况下它只是一个 const 限定的变量，不要将与常量混淆。<br></code></pre></td></tr></table></figure>
</li>
<li><p>const常量支持所有类型。</p>
</li>
<li><p>其他情况下它只是一个 <code>const</code> 限定的变量，不要将与常量混淆。</p>
</li>
</ul>
</li>
<li><p>防止修改，起保护作用，增加程序健壮性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">f</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> i)</span>&#123;<br>    i++; <span class="hljs-comment">// error!</span><br>&#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>可以节省空间，避免不必要的内存分配</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">若用 const 定义常量（类型为整数或枚举，必须以常量表达式初始化），则这种常量在非 odr 式使用（粗略来说是只使用其值）时不需要依赖其身为变量的身份，一定场合下甚至可以不需要定义（譬如作为类的 static 成员对象）。<br>编译器在作为常量处理它时，不会依赖“一份定义”，而是像是立即数一样使用它，它本身可能在机器码中被“拷贝”到多个地方，和 #define 定义的宏常量的结果相同。<br>另一方面， const 定义的常量由于是整数或枚举，所以直接变成机器码上的立即数往往性能更好。<br></code></pre></td></tr></table></figure>
<h2 id="3-const对象默认为文件局部变量"><a href="#3-const对象默认为文件局部变量" class="headerlink" title="3.const对象默认为文件局部变量"></a>3.const对象默认为文件局部变量</h2><p>注意：非const变量默认为extern。要使const变量能够在其他文件中访问，必须在文件中显式地指定它为extern。</p>
<p>未被const修饰的变量在不同文件的访问</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// file1.cpp</span><br><span class="hljs-type">int</span> ext;<br><span class="hljs-comment">// file2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> ext;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    std::cout&lt;&lt;(ext<span class="hljs-number">+10</span>)&lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>const常量在不同文件的访问</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// extern_file1.cpp</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> ext=<span class="hljs-number">12</span>;<br><span class="hljs-comment">// extern_file2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> ext;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span>&lt;&lt;ext&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>小结：<br>可以发现未被const修饰的变量不需要extern显式声明！而const常量需要显式声明extern，并且需要做初始化！因为常量在定义后就不能被修改，所以定义时必须初始化。</p>
</blockquote>
<h2 id="4-定义常量"><a href="#4-定义常量" class="headerlink" title="4.定义常量"></a>4.定义常量</h2><figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br>b = <span class="hljs-number">0</span>; <span class="hljs-comment">// error: assignment of read-only variable ‘b’</span><br><span class="hljs-type">const</span> <span class="hljs-built_in">string</span> s = <span class="hljs-string">&quot;helloworld&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> i,j=<span class="hljs-number">0</span> <span class="hljs-comment">// error: uninitialized const ‘i’</span><br></code></pre></td></tr></table></figure>
<p>上述有两个错误：</p>
<ul>
<li>b 为常量，不可更改！</li>
<li>i 为常量，必须进行初始化！(因为常量在定义后就不能被修改，所以定义时必须初始化。)</li>
</ul>
<h2 id="5-指针与const"><a href="#5-指针与const" class="headerlink" title="5.指针与const"></a>5.指针与const</h2><p>与指针相关的const有四种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">const char * a; // 指向const对象的指针或者说指向常量的指针。<br>char const * a; // 同上<br>char * const a; // 指向类型对象的const指针。或者说常指针、const指针。<br>const char * const a; // 指向const对象的const指针。<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>小结：</strong><br>如果<em>const</em>位于<code>*</code>的左侧，则const就是用来<strong>修饰指针所指向的变量，即指针指向为常量；</strong><br>如果const位于<code>*</code>的右侧，<strong><em>const</em>就是修饰指针本身，即指针本身是常量。</strong></p>
</blockquote>
<p>当指针被加上const特性，则指针不可改变指向的地址<br>当指向的目标特性为char，则内容可以透过指针被修改，如: *char=’y’;<br>当指向的目标特性为const char，则内容不可透过指针修改</p>
<p>具体使用如下：</p>
<p>（1） <strong>指向常量的指针</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr;<br>*ptr = <span class="hljs-number">10</span>; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>ptr是一个指向int类型const对象的指针，const定义的是int类型，也就是ptr所指向的对象类型，而不是ptr本身，所以ptr可以不用赋初始值。但是不能通过ptr去修改所指对象的值。</p>
<p>除此之外，也不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">void</span> * vp = &amp;p;<br><span class="hljs-type">void</span> *vp = &amp;p; <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>另外一个重点是：<strong>允许把非const对象的地址赋给指向const对象的指针</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *ptr;<br><span class="hljs-type">int</span> val = <span class="hljs-number">3</span>;<br>ptr = &amp;val; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>
<p>我们不能通过ptr指针来修改val的值，即使它指向的是非const对象!</p>
<p>我们不能使用指向const对象的指针修改基础对象，然而如果该指针指向了非const对象，可用其他方式修改其所指的对象。可以修改const指针所指向的值的，但是不能通过const对象指针来进行而已！如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *ptr1 = &amp;val;<br>*ptr1=<span class="hljs-number">4</span>;<br><span class="hljs-built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="hljs-built_in">endl</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>小结：<br>1.对于指向常量的指针，不能通过指针来修改对象的值。<br>2.不能使用void<code>*</code>指针保存const对象的地址，必须使用const void<code>*</code>类型的指针保存const对象的地址。<br>3.允许把非const对象的地址赋值给const对象的指针，如果要修改指针所指向的对象值，必须通过其他方式修改，不能直接通过当前指针直接修改。</p>
</blockquote>
<p>（2） <strong>常指针</strong></p>
<p>const指针必须进行初始化，且const指针指向的值能修改，但指向不能修改。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>, num1=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> * <span class="hljs-type">const</span> ptr=&amp;num; <span class="hljs-comment">// const指针必须初始化！且const指针的指向不能修改</span><br>    ptr = &amp;num1; <span class="hljs-comment">// error! const指针不能修改指向！</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码出现编译错误：const指针不能修改指向。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>, num1=<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> * <span class="hljs-type">const</span> ptr=&amp;num; <span class="hljs-comment">// const指针必须初始化！且const指针的指向不能修改</span><br>    *ptr = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码无事发生，正常输出1。</p>
<p>最后，当把一个const常量的地址赋值给ptr时候，由于ptr指向的是一个变量，而不是const常量，所以会报错，出现：const int<code>*</code> -&gt; int <code>*</code>错误！</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br>using namespace <span class="hljs-built_in">std</span>;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> num=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> * <span class="hljs-type">const</span> ptr=&amp;num; <span class="hljs-comment">// error! const int* -&gt; int*</span><br>    <span class="hljs-built_in">cout</span>&lt;&lt;*ptr&lt;&lt;<span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上述若改为 const int <code>*</code>ptr或者改为const int <code>*</code>const ptr，都可以正常！</p>
<p>（3）<strong>指向常量的常指针</strong></p>
<p>理解完前两种情况，下面这个情况就比较好理解了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> p = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> * <span class="hljs-type">const</span> ptr = &amp;p; <br></code></pre></td></tr></table></figure>
<p>ptr是一个const指针，然后指向了一个int 类型的const对象。</p>
<h2 id="6-函数中使用const"><a href="#6-函数中使用const" class="headerlink" title="6.函数中使用const"></a>6.函数中使用const</h2><p><strong><u>const修饰函数返回值</u></strong></p>
<p>这个跟const修饰普通变量以及指针的含义基本相同：</p>
<p>（1）<strong>const int</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>这个本身无意义，因为参数返回本身就是赋值给其他的变量！</p>
<p>（2）<strong>const int*</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span>* <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>指针指向的内容不变。</p>
<p>（3）<strong>int *const</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> *<span class="hljs-type">const</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<p>指针本身不可变。</p>
<p><strong><u>const修饰函数参数</u></strong></p>
<p>（1）<strong>传递过来的参数及指针本身在函数内不可变，无意义！</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> var)</span>; <span class="hljs-comment">// 传递过来的参数不可变</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">int</span> *<span class="hljs-type">const</span> var)</span>; <span class="hljs-comment">// 指针本身不可变</span><br></code></pre></td></tr></table></figure>
<p>表明参数在函数体内不能被修改，但此处没有任何意义，var本身就是形参，在函数内不会改变。包括传入的形参是指针也是一样。</p>
<p>输入参数采用“值传递”，由于函数将自动产生临时变量用于复制该参数，该输入参数本来就无需保护，所以不要加const 修饰。</p>
<p>（2）<strong>参数指针所指内容为常量不可变</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">StringCopy</span><span class="hljs-params">(<span class="hljs-type">char</span> *dst, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *src)</span>;<br></code></pre></td></tr></table></figure>
<p>其中src 是输入参数，dst 是输出参数。给src加上const修饰后，如果函数体内的语句试图改动src的内容，编译器将指出错误。这就是加了const的作用之一。</p>
<p>（3）<strong>参数为引用，为了增加效率同时防止修改。(重要)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">func</span><span class="hljs-params">(<span class="hljs-type">const</span> A &amp;a)</span><br></code></pre></td></tr></table></figure>
<p>对于非内部数据类型的参数而言，像void func(A a) 这样声明的函数注定效率比较低。因为函数体内将产生A 类型的临时对象用于复制参数a，而临时对象的构造、复制、析构过程都将消耗时间。</p>
<p>为了提高效率，可以将函数声明改为void func(A &amp;a)，因为“引用传递”仅借用一下参数的别名而已，不需要产生临 时对象。</p>
<blockquote>
<p>但是函数void func(A &amp;a) 存在一个缺点：</p>
<p>“引用传递”有可能改变参数a，这是我们不期望的。解决这个问题很容易，加const修饰即可，因此函数最终成为 void func(const A &amp;a)。</p>
</blockquote>
<p><strong>以此类推，是否应将void func(int x) 改写为void func(const int &amp;x)，以便提高效率？完全没有必要，因为内部数据类型的参数不存在构造、析构的过程，而复制也非常快，“值传递”和“引用传递”的效率几乎相当。</strong></p>
<blockquote>
<p>小结：<br>1.对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void func(A a) 改为void func(const A &amp;a)。</p>
<p>2.对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void func(int x) 不应该改为void func(const int &amp;x)。</p>
</blockquote>
<p><strong>以上解决了两个面试问题：</strong></p>
<ul>
<li>如果函数需要传入一个指针，是否需要为该指针加上const，把const加在指针不同的位置有什么区别；</li>
<li>如果写的函数需要传入的参数是一个复杂类型的实例，传入值参数或者引用参数有什么区别，什么时候需要为传入的引用参数加上const。</li>
</ul>
<h2 id="7-类中使用const"><a href="#7-类中使用const" class="headerlink" title="7.类中使用const"></a>7.类中使用const</h2><p>在一个类中，任何不会修改数据成员的函数都应该声明为const类型。如果在编写const成员函数时，不慎修改 数据成员，或者调用了其它非const成员函数，编译器将指出错误，这无疑会提高程序的健壮性。</p>
<p>使用const关键字进行说明的成员函数，称为常成员函数。只有常成员函数才有资格操作常量或常对象，没有使用const关键字进行说明的成员函数不能用来操作常对象。</p>
<p>对于类中的const成员变量必须通过初始化列表进行初始化，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> people[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Apple</span>(<span class="hljs-type">int</span> i); <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> apple_number;<br>&#125;;<br><br>Apple::<span class="hljs-built_in">Apple</span>(<span class="hljs-type">int</span> i):<span class="hljs-built_in">apple_number</span>(i)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.</p>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// apple.cpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> people[<span class="hljs-number">100</span>];<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Apple</span>(<span class="hljs-type">int</span> i); <br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> apple_number;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">take</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>&#125;;<br><span class="hljs-comment">// apple.cpp</span><br>Apple::<span class="hljs-built_in">Apple</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">apple_number</span>(i)<br>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Apple::add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">take</span>(num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Apple::add</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">take</span>(num);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Apple::take</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;take func &quot;</span> &lt;&lt; num &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Apple::getCount</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">take</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//    add(); // error</span><br>    <span class="hljs-keyword">return</span> apple_number;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">Apple <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;<br>    cout &lt;&lt; a.<span class="hljs-built_in">getCount</span>() &lt;&lt; endl;<br>    a.<span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-function"><span class="hljs-type">const</span> Apple <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br>    b.<span class="hljs-built_in">add</span>(<span class="hljs-number">100</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// main.cpp</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>编译：bazel run basic_content/const/class_const/first_example:main</p>
<p>主要 add() 没有const修饰</p>
</blockquote>
<p>此时报错，上面getCount()方法中调用了一个add方法，而add方法并非const修饰，所以运行报错。也就是说const成员函数只能访问const成员函数。</p>
<p>当调用改为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> Apple <span class="hljs-title function_">b</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span>;<br>b.add(); <span class="hljs-comment">// error</span><br></code></pre></td></tr></table></figure>
<p>此时，可以证明的是const对象只能访问const成员函数。</p>
<p>我们除了上述的初始化const常量用初始化列表方式外，也可以通过下面方法：</p>
<p>第一：将常量定义与static结合，也就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> apple_number<br></code></pre></td></tr></table></figure>
<p>第二：在外面初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> <span class="hljs-type">int</span> Apple::apple_number=<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>当然，如果你使用c++11进行编译，直接可以在定义出初始化，可以直接写成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> apple_number=<span class="hljs-number">10</span>;<br><span class="hljs-comment">// 或者</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> apple_number=<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>
<p>这两种都在c++11中支持！</p>
<p>编译的时候加上<code>-std=c++11</code>即可！</p>
<p>这里提到了static，下面简单的说一下：</p>
<p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。</p>
<p>在类中声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> ap;<br></code></pre></td></tr></table></figure>
<p>在类实现文件中使用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> Apple::ap=<span class="hljs-number">666</span><br></code></pre></td></tr></table></figure>
<p>对于此项，c++11不能进行声明并初始化，也就是上述使用方法。</p>
<h2 id="8-static的含义"><a href="#8-static的含义" class="headerlink" title="8.static的含义"></a>8.static的含义</h2><p>当与不同类型一起使用时，Static关键字具有不同的含义。我们可以使用static关键字：</p>
<p><strong>静态变量：</strong> 函数中的变量，类中的变量</p>
<p><strong>静态类的成员：</strong> 类对象和类中的函数</p>
<p>现在让我们详细看一下静态的这些用法：</p>
<p><strong>静态变量</strong></p>
<ul>
<li>函数中的静态变量</li>
</ul>
<p>当变量声明为static时，空间<strong>将在程序的生命周期内分配</strong>。即使多次调用该函数，静态变量的空间也<strong>只分配一次</strong>，前一次调用中的变量值通过下一次函数调用传递。这对于在C / C ++或需要存储先前函数状态的任何其他应用程序非常有用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demo</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>	<span class="hljs-comment">// static variable </span><br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; <br>	cout &lt;&lt; count &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>	<br>	<span class="hljs-comment">// value is updated and </span><br>	<span class="hljs-comment">// will be carried to next </span><br>	<span class="hljs-comment">// function calls </span><br>	count++; <br>&#125; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)	 <br>		<span class="hljs-built_in">demo</span>(); <br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">0 1 2 3 4 <br></code></pre></td></tr></table></figure>
<p>您可以在上面的程序中看到变量count被声明为static。因此，它的<strong>值通过函数调用来传递</strong>。每次调用函数时，都不会对变量计数进行初始化。</p>
<ul>
<li>类中的静态变量</li>
</ul>
<p>由于声明为static的变量只被初始化一次，因为它们在单独的静态存储中分配了空间，因此类中的静态变量<strong>由对象共享</strong>。对于不同的对象，不能有相同静态变量的多个副本。也是因为这个原因，静态变量不能使用构造函数初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <br>&#123; <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> i; <br>	<br>	<span class="hljs-built_in">Apple</span>() <br>	&#123; <br>		<span class="hljs-comment">// Do nothing </span><br>	&#125;; <br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>Apple obj1; <br>Apple obj2; <br>obj<span class="hljs-number">1.</span>i =<span class="hljs-number">2</span>; <br>obj<span class="hljs-number">2.</span>i = <span class="hljs-number">3</span>; <br>	<br><span class="hljs-comment">// prints value of i </span><br>cout &lt;&lt; obj<span class="hljs-number">1.</span>i&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;obj<span class="hljs-number">2.</span>i; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>您可以在上面的程序中看到我们已经尝试为多个对象创建静态变量i的多个副本。但这并没有发生。因此，类中的静态变量应由用户使用类外的类名和范围解析运算符显式初始化，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <br>&#123; <br><span class="hljs-keyword">public</span>: <br>	<span class="hljs-type">static</span> <span class="hljs-type">int</span> i; <br>	<br>	<span class="hljs-built_in">Apple</span>() <br>	&#123; <br>		<span class="hljs-comment">// Do nothing </span><br>	&#125;; <br>&#125;; <br><br><span class="hljs-type">int</span> Apple::i = <span class="hljs-number">1</span>; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>	Apple obj; <br>	<span class="hljs-comment">// prints value of i </span><br>	cout &lt;&lt; obj.i; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p><strong>静态成员</strong></p>
<ul>
<li>类对象为静态</li>
</ul>
<p>就像变量一样，对象也在声明为static时具有范围，直到程序的生命周期。</p>
<p>考虑以下程序，其中对象是非静态的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br>using namespace <span class="hljs-built_in">std</span>; <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span><br><span class="hljs-class">&#123;</span> <br>	<span class="hljs-type">int</span> i; <br>	public: <br>		Apple() <br>		&#123; <br>			i = <span class="hljs-number">0</span>; <br>			<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Inside Constructor\n&quot;</span>; <br>		&#125; <br>		~Apple() <br>		&#123; <br>			<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Inside Destructor\n&quot;</span>; <br>		&#125; <br>&#125;; <br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> <br>&#123; <br>	<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; <br>	<span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <br>	&#123; <br>		Apple obj; <br>	&#125; <br>	<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;End of main\n&quot;</span>; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs C">Inside Constructor<br>Inside Destructor<br>End of main<br></code></pre></td></tr></table></figure>
<p>在上面的程序中，对象在if块内声明为非静态。因此，变量的范围仅在if块内。因此，当创建对象时，将调用构造函数，并且在if块的控制权越过析构函数的同时调用，因为对象的范围仅在声明它的if块内。 如果我们将对象声明为静态，现在让我们看看输出的变化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <br>&#123; <br>	<span class="hljs-type">int</span> i; <br>	<span class="hljs-keyword">public</span>: <br>		<span class="hljs-built_in">Apple</span>() <br>		&#123; <br>			i = <span class="hljs-number">0</span>; <br>			cout &lt;&lt; <span class="hljs-string">&quot;Inside Constructor\n&quot;</span>; <br>		&#125; <br>		~<span class="hljs-built_in">Apple</span>() <br>		&#123; <br>			cout &lt;&lt; <span class="hljs-string">&quot;Inside Destructor\n&quot;</span>; <br>		&#125; <br>&#125;; <br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>	<span class="hljs-type">int</span> x = <span class="hljs-number">0</span>; <br>	<span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <br>	&#123; <br>		<span class="hljs-type">static</span> Apple obj; <br>	&#125; <br>	cout &lt;&lt; <span class="hljs-string">&quot;End of main\n&quot;</span>; <br>&#125; <br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Inside Constructor<br>End of main<br>Inside Destructor<br></code></pre></td></tr></table></figure>
<p>您可以清楚地看到输出的变化。现在，在main结束后调用析构函数。这是因为静态对象的范围是贯穿程序的生命周期。</p>
<blockquote>
<p>第一个例子，对象的范围只在if块内，所以函数的周期子在if块内已经结束，</p>
<p>而第二个例子，使用static进行修饰，对象的生命周期为整个main函数，因此在最终才进行析构函数</p>
</blockquote>
<ul>
<li>类中的静态函数</li>
</ul>
<p>就像类中的静态数据成员或静态变量一样，静态成员函数也不依赖于类的对象。我们被允许使用对象和’.’来调用静态成员函数。但<strong>建议使用类名和范围解析运算符调用静态成员</strong>。</p>
<p>允许静态成员函数仅访问静态数据成员或其他静态成员函数，它们无法访问类的非静态数据成员或成员函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span> </span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std; <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <br>&#123; <br>    <span class="hljs-keyword">public</span>: <br>        <span class="hljs-comment">// static member function </span><br>        <span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">        </span>&#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;Welcome to Apple!&quot;</span>; <br>        &#125;<br>&#125;; <br><br><span class="hljs-comment">// main function </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-comment">// invoking a static member function </span><br>    Apple::<span class="hljs-built_in">printMsg</span>(); <br>&#125; <br></code></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plaintext">Welcome to Apple!<br></code></pre></td></tr></table></figure>
<p><strong>限定访问范围</strong> static还有限定访问范围的作用（类似于匿名名字空间）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// source1.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg = <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sayHello</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// source2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span>* msg;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, msg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>g++对于上面两个代码文件是可以正常编译并且打印Hello World!，但如果给source1.cpp中的msg加上static，则会导致undefined reference to ‘msg’的编译错误：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// source1.cpp</span><br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg = <span class="hljs-string">&quot;Hello World!\n&quot;</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">sayHello</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

            </article>
            
	<aside class="rightside">
	
		<div class="rightside-button not-toc-button" id="js-aside">
			<span>
				<img no-lazy src="/images/icon/aside.png" class="rightside-button-icon" alt="Icon">
			</span>
		</div>
		<script>
			$("#js-aside").click(function () {
				onShowAsideButton();
			});
		</script>
	
	<div class="rightside-button" id="js-toggle_theme">
		<span>
			<img no-lazy src="/images/icon/toggle_theme.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	
<script src="/js/plugins/goto_position.js"></script>

	
	<div class="rightside-button" id="js-go_top">
		<span>
			<img no-lazy src="/images/icon/go_top.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>
	<div class="rightside-button" id="js-go_bottom">
		<span>
			<img no-lazy src="/images/icon/go_bottom.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	<script>
		setToggleThemeButtonListener();
	</script>
	<script>
		$('#js-go_top')
		.gotoPosition( {
			speed: 300,
			target: 'top',
		} );
		$('#js-go_bottom')
		.gotoPosition( {
			speed: 300,
			target: 'bottom',
		} );
	</script>
</aside>


<div class="post-bottom">
    
        <div class="post-paging">     
            <div class="post-paging-last">
                
                    <a href="/2024/12/29/C++%E7%AF%87%EF%BC%9A%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/">
                        上一篇：C++篇：纯虚函数与抽象类
                    </a>
                
            </div>
            <div class="post-paging-next">
                
                    <a href="/2024/12/28/C++%E7%AF%87%EF%BC%9A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E6%90%9E%E6%87%82inline%E5%85%B3%E9%94%AE%E5%AD%97/">
                        下一篇：C++篇：一篇文章搞懂inline关键字
                    </a>
                
            </div>
        </div>
    
    
    
        
    
</div>
        </div>
    </main>
    
        <aside class="main-aside">
    
<script src="/js/widgets/aside.js"></script>

    <script>
        showAside();
    </script>

    <div class="aside-top">
        <div class="aside-top-about aside-card">
            <a href="" class="aside-top-about-portrait">
                <img no-lazy src="/images/icon/head.jpg" alt="Q">
            </a>
            <div class="aside-top-about-info">
                <span class="author"> LLj</span>
                <span class="description">道阻且长 行则将至</span>
            </div>              
            <div class="aside-top-about-site">
                <a href="/categories" class="aside-top-about-site-item">
                    <span class="title">类别</span>
                    <span class="count">2</span>
                </a>
                <a href="/tags" class="aside-top-about-site-item">
                    <span class="title">标签</span>
                    <span class="count">3</span>
                </a>
                <a href="/archives" class="aside-top-about-site-item">
                    <span class="title">归档</span>
                    <span class="count">6</span>
                </a>
            </div>
            <div class="aside-top-about-contact">
                
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
                        </a>
                    
                
            </div>
        </div> 

        
    </div>

    <div class="aside-bottom">
        
    </div>
</aside>
    
</div>
		<footer>
	<div class="content">
		
			<span>©2024-2025&nbsp;By&nbsp;<a href="/about">LLJ</a>.</span>
		
		<span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> theme by <a target="_blank" rel="noopener" href="https://github.com/GZ-Metal-Cell/hexo-theme-quieter">Quieter</a>.</span>
		
	</div>

	
<script src="/js/plugins/ref.js"></script>

	
<script src="/js/plugins/highlight_tools.js"></script>

	<script>
		var copyIcon = "/images/icon/copy.png";
		var closeCodeBlockIcon = "/images/icon/close_code_block.png";
		var highlightShrink = "";
		var HighlightHeightLimit = "";
	</script>
	
	<!-- Analytics -->

    
        <!-- Busuanzi Analytics -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    


	

	

    
		
<script src="/js/plugins/replaceSpacesWithNbsp.js"></script>

	

	
	
	
		<script>
			if (typeof init === 'function') {
				init();
			}
		</script>
	

	
		
	

	

	<!--
		
<script src="/js/plugins/jquery.pjax.min.js"></script>

		<script>
			$(document).pjax('a[target!=_blank]', 'main', {
				fragment: 'main',
				timeout: 8000
			});

			$(document).on('pjax:complete', function() {
			});
		</script> 
	-->
	<script>
		console.log('\n %c Hexo-Quieter 主题 %c https://github.com/GZ-Metal-Cell/hexo-theme-quieter \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
	</script>
</footer>
	</body>

	<!-- Hexo-Quieter 主题  https://github.com/GZ-Metal-Cell/hexo-theme-quieter -->
</html>

