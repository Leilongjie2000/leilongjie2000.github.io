<!DOCTYPE html>
<html lang=zh-CN data-theme="light">
	
<script src="/js/plugins/toggleTheme.js"></script>

	<script>
		setTheme();
	</script>
	<head>
		
<title>LLVM后端-理解指令选择的的DAG图以及dump输出 | </title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/images/icon/head.jpg">
<link href="/css/plugins/print.css" media="print" rel="stylesheet" />

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="LLVM,后端,指令选择,">
<meta name="description" content="">



<script src="/js/plugins/jquery.min.js"></script>


<script src="/js/plugins/hljs.min.js"></script>


<script src="/js/plugins/init.js"></script>


<script src="/js/plugins/hide.js"></script>


<script src="/js/plugins/tabs.js"></script>



    







    

	<meta name="generator" content="Hexo 7.3.0"></head>

	<body>
		<header class="sticky-header">
	<nav>
		<div class="nav-left">
			<a href="/" class="logo">
				<img no-lazy src="/images/headers_icon/雪屋.svg" alt="Quieter">
			</a>
			<ul class="breadcrumb" id="breadcrumb"></ul>
		</div>
		<div class="nav-right">
			<ul>
				
					<li>
						<a href="/">
						  主页
						</a>
					</li>
				
					<li>
						<a href="/categories">
						  类别
						</a>
					</li>
				
					<li>
						<a href="/tags">
						  标签
						</a>
					</li>
				
					<li>
						<a href="/archives">
						  归档
						</a>
					</li>
								  
			</ul>
		</div>
		<div class="nav-right-close">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
				<path fill="none" d="M0 0h24v24H0z" />
				<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
			</svg>
		</div>

		<div class="sidebar">
    <div class="topo">
        <p></p>
    </div>
    <ul>
        
        <li>
            <a href="/">
                主页
            </a>
        </li>
        
        <li>
            <a href="/categories">
                类别
            </a>
        </li>
        
        <li>
            <a href="/tags">
                标签
            </a>
        </li>
        
        <li>
            <a href="/archives">
                归档
            </a>
        </li>
        
    </ul>
    <div class="sidebar-footer">
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
        </a>
        
        <a href="">
            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
        </a>
        
    </div>
</div>
<div class='shelter'>
    <script>
        $(function() {
            $('.nav-right-close > svg').click(function() {
                $('.sidebar').animate({
                    right: "0"
                }, 500);
                $('.shelter').fadeIn("slow");
            
                var element = $('.topo');
                element.addClass('custom-style');
            
                var links = null;
                if ("") {
                    links = "".split(',');
                } else {
                    links = "/images/random_top_img/1.jpg,/images/random_top_img/2.jpg,/images/random_top_img/3.jpg,/images/random_top_img/4.jpg,/images/random_top_img/5.jpg,/images/random_top_img/6.jpg,/images/random_top_img/7.jpg,/images/random_top_img/8.jpg,/images/random_top_img/9.jpg,/images/random_top_img/10.jpg,/images/random_top_img/11.jpg,/images/random_top_img/12.png,/images/random_top_img/13.png,/images/random_top_img/14.jpg,/images/random_top_img/15.jpg,/images/random_top_img/16.jpg,/images/random_top_img/17.jpg,/images/random_top_img/18.jpg,/images/random_top_img/19.jpg,/images/random_top_img/20.jpg,/images/random_top_img/21.jpg,/images/random_top_img/22.jpg,/images/random_top_img/23.jpg,/images/random_top_img/24.jpg".split(',');
                }
            
                var randomLink = links[Math.floor(Math.random() * links.length)];
                element.css('background-image', "url('" + randomLink + "')");
            });
          
            $('.shelter').click(function(e) {
                $('.sidebar').animate({
                    right: "-100%"
                }, 500);
                $('.shelter').fadeOut("slow");
            });
        });      
    </script>
</div>
	</nav>

	
		<div class="header-background"></div>
	

	<script>
		const name = 'post';
		const ul = document.querySelectorAll('.nav-right ul')[0];
		const lis = ul.querySelectorAll('li');

		if (name == 'home') {
			lis[0].classList.add('select');
		} else {
			for (let i = 0; i < lis.length; i++) {
				const li = lis[i];
				const a = li.querySelector('a');
				if (name === a.href.split('/')[3]) {
					li.classList.add('select');
				}
			}
		}
	</script>
	
	<script>
		var element = document.querySelector('.header-background');
		if(element) {
			element.classList.add('custom-style');
			var links = null;
			if("")
			{
				links = "".split(',');
			} else
			{
				links = "/images/random_top_img/1.jpg,/images/random_top_img/2.jpg,/images/random_top_img/3.jpg,/images/random_top_img/4.jpg,/images/random_top_img/5.jpg,/images/random_top_img/6.jpg,/images/random_top_img/7.jpg,/images/random_top_img/8.jpg,/images/random_top_img/9.jpg,/images/random_top_img/10.jpg,/images/random_top_img/11.jpg,/images/random_top_img/12.png,/images/random_top_img/13.png,/images/random_top_img/14.jpg,/images/random_top_img/15.jpg,/images/random_top_img/16.jpg,/images/random_top_img/17.jpg,/images/random_top_img/18.jpg,/images/random_top_img/19.jpg,/images/random_top_img/20.jpg,/images/random_top_img/21.jpg,/images/random_top_img/22.jpg,/images/random_top_img/23.jpg,/images/random_top_img/24.jpg".split(',');
			}
			var randomLink = links[Math.floor(Math.random() * links.length)];
			element.style.backgroundImage = "url('" + randomLink + "')";
		}
	</script>

	
<script src="/js/plugins/breadcrumb.js"></script>

	<script>
		var menus_title = [];
		
			menus_title.push({home: '主页'});
		
			menus_title.push({categories: '类别'});
		
			menus_title.push({tags: '标签'});
		
			menus_title.push({archives: '归档'});
		
		
			
				postsBreadcrumb(
					document.getElementById('breadcrumb'),
					"类别",
					"/categories",
					"LLVM",
					"/categories/LLVM"
				);
			
		
	</script>
</header>

<div class="main-wrapper">
    <main class="post">
        <header class="main-header">
	
		
			
				
<link rel="stylesheet" href="/css/plugins/fancybox.css">

				
<script src="/js/plugins/fancybox.umd.js"></script>

				
<script src="/js/plugins/fancybox.js"></script>

			
			<div class="post-header-background-content">
				<ul class="post-header-tag">
					
						
							<li><a href="/tags/LLVM"><span>LLVM</span></a></li>
						
							<li><a href="/tags/后端"><span>后端</span></a></li>
						
							<li><a href="/tags/指令选择"><span>指令选择</span></a></li>
						
					
				</ul>
				
				<h1>LLVM后端-理解指令选择的的DAG图以及dump输出</h1>
		
				
		
				<div class="post-header-info">
					<svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
					xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
						<path
							d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
							p-id="2902" fill="#ffffff"></path>
					</svg>
					<div class="post-header-info-author">
						<a href="/about">LLJ</a>
					</div>
					
						<div class="post-header-info-categories">
							
								<a href="/categories/LLVM">LLVM</a>
							
						</div>
					
					<time>2025/03/10 21:35:23</time>
				</div>
		
				
					<div class="post-header-stat">
						<svg version="1.0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
						viewBox="0 0 200 200" enable-background="new 0 0 200 200" xml:space="preserve" width="20" height="20">
							<path fill="#FFFFFF" d="M187.2,165.6c0,2.6-2.1,4.7-4.7,4.7H17.5c-2.6,0-4.7-2.1-4.7-4.7s2.1-4.7,4.7-4.7h165.1
								C185.2,160.9,187.2,163,187.2,165.6z"/>
							<path fill="#FFFFFF" d="M17.5,29.7c2.6,0,4.7,2.1,4.7,4.7v131.2c0,2.6-2.1,4.7-4.7,4.7s-4.7-2.1-4.7-4.7V34.4
								C12.8,31.8,14.9,29.7,17.5,29.7z M77.9,91.5c1.8,1.8,1.8,4.8,0,6.6l-39.8,39.8c-1.9,1.8-4.9,1.7-6.6-0.2c-1.7-1.8-1.7-4.6,0-6.4
								l39.8-39.8C73.1,89.6,76,89.6,77.9,91.5z M169.9,70.2c1.6,2.1,1.1,5-0.9,6.5c0,0,0,0,0,0l-64.2,48.2c-2.1,1.5-5,1.1-6.6-0.9
								c-1.6-2.1-1.1-5,0.9-6.5c0,0,0,0,0,0l64.2-48.2C165.4,67.7,168.3,68.1,169.9,70.2L169.9,70.2z"/>
							<path fill="#FFFFFF" d="M104.6,124.5c-1.8,1.8-4.8,1.8-6.6,0L71.6,98.1c-1.8-1.8-1.8-4.8,0-6.6c1.8-1.8,4.8-1.8,6.6,0l26.3,26.3
								C106.4,119.6,106.4,122.6,104.6,124.5C104.6,124.4,104.6,124.4,104.6,124.5z"/>
						</svg>
		
						
							
<script src="/js/plugins/wordCount.js"></script>

							<p class="post-count">文字数：---</p>
						
		
						
							<p id="busuanzi_container_page_pv" style='display:none;'>阅读数：<span id="busuanzi_value_page_pv"></span></p>
						
					</div>
				
			</div>
		
	
</header>
        <div class="post-content article-container">
            <article class="post-content-info">
                <h1 id="LLVM后端-理解指令选择的的DAG图以及dump输出"><a href="#LLVM后端-理解指令选择的的DAG图以及dump输出" class="headerlink" title="LLVM后端-理解指令选择的的DAG图以及dump输出"></a>LLVM后端-理解指令选择的的DAG图以及dump输出</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文以release/19.1.0版本的LLVM源码为基础，阐述了指令选择的整体流程以及llc里常用SelectionDAG命令选项和各流程间的对应关系。另外，借助一个简单的示例呈现了指令选择的dump输出及其意义。进而，掌握指令选择的常见调试分析方法，且有助于深入探究指令选择的内部原理 。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在进行性能调优时发现了一个非常有意思的现象，两条相似的赋值语句最终产生的汇编却截然不同，在进行分析时学到了指令选择的一些相关知识，写下此文进一步加深理解与思考。</p>
<blockquote>
<p>目标平台: AMD Ryzen 9 7950X 16-Core Processor</p>
<p>编译器：LLVM19.1.0</p>
</blockquote>
<p>kernel1:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> solve(n, l, u, i, j)<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: row, col, row1, col1, x<br>  <span class="hljs-keyword">integer</span> ,<span class="hljs-keyword">intent</span>(<span class="hljs-keyword">in</span>):: n<br>  <span class="hljs-keyword">integer</span> :: <span class="hljs-keyword">block</span>(n, n) <br>  <span class="hljs-keyword">integer</span> ,<span class="hljs-keyword">intent</span>(<span class="hljs-keyword">in</span>):: l(n), u(n), i, j<br><br>  <span class="hljs-keyword">do</span> row = l(i), u(i)<br>    <span class="hljs-keyword">do</span> col = l(j), u(j)<br>      <span class="hljs-keyword">block</span>(col,row) = <span class="hljs-keyword">block</span>(col,row) - <span class="hljs-number">10</span>  <br>      <span class="hljs-keyword">block</span>(col,row+<span class="hljs-number">1</span>) = <span class="hljs-keyword">block</span>(col,row+<span class="hljs-number">1</span>) - <span class="hljs-number">20</span><br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">return</span>  <br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span><br></code></pre></td></tr></table></figure>
<p>kernel1生成的汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">movslq	%r8d, %r8<br>addl	$-10, -4(%rcx,%r8,4)<br>addl	$-20, -4(%rdx,%r8,4)<br>incl	%r8d<br>decq	%rax<br>cmpq	$1, %rax<br>ja	.LBB0_13<br></code></pre></td></tr></table></figure>
<p>kernel2:</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">subroutine</span></span> solve(n, l, u, i, j)<br>  <span class="hljs-keyword">implicit</span> <span class="hljs-keyword">none</span><br>  <span class="hljs-keyword">integer</span> :: row, col, row1, col1<br>  <span class="hljs-keyword">integer</span> ,<span class="hljs-keyword">intent</span>(<span class="hljs-keyword">in</span>):: n<br>  <span class="hljs-keyword">integer</span> :: <span class="hljs-keyword">block</span>(n, n) <br>  <span class="hljs-keyword">integer</span> ,<span class="hljs-keyword">intent</span>(<span class="hljs-keyword">in</span>):: l(n), u(n), i, j<br>  <br>  <span class="hljs-keyword">do</span> row = l(i), u(i)<br>    <span class="hljs-keyword">do</span> col = l(j), u(j)<br>      <span class="hljs-keyword">block</span>(col,row) = <span class="hljs-keyword">block</span>(col,row) - <span class="hljs-number">10</span>  <br>      <span class="hljs-keyword">block</span>(col+<span class="hljs-number">1</span>,row) = <span class="hljs-keyword">block</span>(col+<span class="hljs-number">1</span>,row) - <span class="hljs-number">20</span> <br>    <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">return</span>  <br>  <span class="hljs-keyword">end</span> <span class="hljs-keyword">do</span><br><span class="hljs-keyword">end</span> <span class="hljs-function"><span class="hljs-keyword">subroutine</span></span><br></code></pre></td></tr></table></figure>
<p>kernel2生成的部分汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">	decq	%r10<br>	imulq	%rdi, %r10<br>	leaq	(%r9,%r10,4), %rdx<br>	movl	-4(%rdx,%rsi,4), %esi<br>	addq	$2, %rcx<br>	.p2align	4, 0x90<br>.LBB0_3:<br>	cltq<br>	addl	$-10, %esi<br>	movl	%esi, -4(%rdx,%rax,4)<br>	incl	%eax<br>	movslq	%eax, %rdi<br>	movl	-4(%rdx,%rdi,4), %esi<br>	addl	$-20, %esi<br>	movl	%esi, -4(%rdx,%rdi,4)<br>	decq	%rcx<br>	cmpq	$1, %rcx<br>	ja	.LBB0_3<br></code></pre></td></tr></table></figure>
<p>重点对block赋值语句生成的汇编可以发现kernel1生成的汇编是一条addl的形式，而kernel2生成汇编的是mov-addl-mov的形式，并且关注kernel2生成的这一部分可以发现这三条指令是完全可以写成addl的形式的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs asm">movl	-4(%rdx,%rdi,4), %esi<br>addl	$-20, %esi<br>movl	%esi, -4(%rdx,%rdi,4)<br></code></pre></td></tr></table></figure>
<p>因此对llvm指令选择的机制产生了怀疑，其实最终的解释原因非常简单，甚至和指令选择并无太大的关系，归根结底，是寄存器复用优化与折叠优化的矛盾所致。感兴趣的同学可以分析一下。</p>
<p>好了，由于本篇的重点在于指令选择的整体流程以及llc里常用SelectionDAG命令选项和各流程间的对应关系，因此不会在上述例子进行过多的阐述，那么我们正片开始！</p>
<h2 id="指令选择的整体输出"><a href="#指令选择的整体输出" class="headerlink" title="指令选择的整体输出"></a>指令选择的整体输出</h2><p>指令选择是将LLVM IR转换为代表目标指令的SelectDAG节点-SDNode.它是由一些较小的阶段组成，这些阶段如下图所示：</p>
<p><img src="C:\Users\llj\AppData\Roaming\Typora\typora-user-images\image-20250307223609552.png" alt="image-20250307223609552"></p>
<p>为了直观地展示<code>llc</code>中常用 SelectionDAG 命令选项与各阶段之间的对应关系，图中除了指令选择阶段<code>(1)~(10)</code>以外，还包括了指令调度阶段<code>(11)</code>。</p>
<p>查看各阶段输出结果的常见方式有以下两种：</p>
<ul>
<li>通过<code>-debug-only=isel</code>命令选项查看所有阶段的文本输出（对应图中绿色字体）。比如：<code>Initial selection DAG:</code>后面的 SelectionDAG 对应阶段<code>(1)</code>的文本输出结果。</li>
<li>通过<code>-view-dag-combine1-dags</code>、<code>-view-legalize-dags</code>等命令选项（对应图中紫色字体）查看指定阶段的可视化输出。比如：<code>-view-dag-combine1-dags</code>用于查看阶段<code>(1)</code>的可视化输出结果。另外，可以通过<code>-filter-view-dags</code>命令选项指定允许可视化的基本块。比如：<code>-filter-view-dags=if_else -view-sched-dags</code>表示只可视化基本块<code>if_else</code>在阶段<code>(10)</code>的输出结果。</li>
</ul>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>如果阶段<code>(3)</code>——<code>Type Legalization</code>未修改 SelectionDAG，那么<code>-view-dag-combine-lt-dags</code>命令选项不会输出其可视化结果。并且，阶段<code>(4)</code>——<code>DAG Combining</code>也不会执行。相应地，<code>Optimized type-legalized selection DAG:</code>不会出现在文本输出结果中。</li>
<li>如果阶段<code>(5)</code>——<code>Vector Legalization</code>未修改 SelectionDAG，那么阶段<code>(6)</code>——<code>Type Legalization 2</code>和阶段<code>(7)</code>——<code>DAG Combining</code>都不会执行。并且，<code>Vector-legalized selection DAG:</code>、<code>Vector/type-legalized selection DAG:</code>、<code>Optimized vector-legalized selection DAG:</code>都不会出现在文本输出结果中。除此之外，<code>-view-dag-combine-lt-dags</code>命令选项也不会输出阶段<code>(6)</code>的可视化结果。然而，<code>-view-legalize-dags</code>命令选项总是可用的。</li>
<li><code>-filter-view-dags</code>命令选项指定允许可视化的基本块,这里的基本块指的是IR的基本块的名称，并且在大型程序中受编译选项如：内联的影响，部分基本块的名称是无法通过<code>-filter-view-dags</code>所识别的,遇到一个复杂的工程问题，最好抽象成一个小例子来进行解决，否则DAG将会异常复杂难懂。</li>
</ul>
<p><em>注：</em></p>
<ul>
<li><p>指令选择的整体流程见<code>SelectionDAGISel::CodeGenAndEmitDAG()</code>函数的实现（定义在 llvm/lib/CodeGen/SelectionDAG/SelectionDAGISel.cpp 文件中）。</p>
</li>
<li><p><code>llc</code>中所有的 SelectionDAG 命令选项可以通过<code>llc --help-list-hidden | grep dags</code>命令进行查看。其输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">--help-list-hidden | grep dags<br> --filter-view-dags=&lt;string&gt;                                                - Only display the basic block whose name matches this for all view-*-dags options<br> --misched-print-dags                                                       - Print schedule DAGs<br> --view-block-freq-propagation-dags=&lt;value&gt;                                 - Pop up a window to show a dag displaying how block frequencies propagation through the CFG.<br> --view-dag-combine-lt-dags                                                 - Pop up a window to show dags before the post legalize types dag combine pass<br> --view-dag-combine1-dags                                                   - Pop up a window to show dags before the first dag combine pass<br> --view-dag-combine2-dags                                                   - Pop up a window to show dags before the second dag combine pass<br> --view-isel-dags                                                           - Pop up a window to show isel dags as they are selected<br> --view-legalize-dags                                                       - Pop up a window to show dags before legalize<br> --view-legalize-types-dags                                                 - Pop up a window to show dags before legalize types<br> --view-machine-block-freq-propagation-dags=&lt;value&gt;                         - Pop up a window to show a dag displaying how machine block frequencies propagate through the CFG.<br> --view-misched-dags                                                        - Pop up a window to show MISched dags after they are processed<br> --view-sched-dags                                                          - Pop up a window to show sched dags as they are processed<br> --view-sunit-dags                                                          - Pop up a window to show SUnit dags after they are processed<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="查看指令选择的输出结果"><a href="#查看指令选择的输出结果" class="headerlink" title="查看指令选择的输出结果"></a>查看指令选择的输出结果</h2><h3 id="以一段IR作为示例程序："><a href="#以一段IR作为示例程序：" class="headerlink" title="以一段IR作为示例程序："></a>以一段IR作为示例程序：</h3><p>test.ll</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">; ModuleID = &#x27;FIRModule&#x27;<br>source_filename = &quot;FIRModule&quot;<br>target datalayout = &quot;e-m:e-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128&quot;<br>target triple = &quot;x86_64-unknown-linux-gnu&quot;<br><br>; Function Attrs: nofree norecurse nosync nounwind memory(argmem: read)<br>define void @solve_(ptr nocapture readonly %0, ptr nocapture readonly %1, ptr nocapture readonly %2, ptr nocapture readonly %3, ptr nocapture readonly %4) local_unnamed_addr #0 &#123;<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">6 = load i32, ptr %0, align 4, !tbaa !3</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">7 = <span class="hljs-built_in">tail</span> call i32 @llvm.smax.i32(i32 %6, i32 0)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">8 = zext nneg i32 %7 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">9 = mul nuw nsw i64 %8, %8</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">10 = alloca i32, i64 %9, align 4</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">11 = load i32, ptr %3, align 4, !tbaa !9</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">12 = sext i32 %11 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">13 = add nsw i64 %12, -1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">14 = getelementptr i32, ptr %1, i64 %13</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">15 = load i32, ptr %14, align 4, !tbaa !11</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">16 = sext i32 %15 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">17 = getelementptr i32, ptr %2, i64 %13</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">18 = load i32, ptr %17, align 4, !tbaa !13</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">19 = sext i32 %18 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">reass.sub = sub nsw i64 %19, %16</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">20 = icmp sgt i64 %reass.sub, -1</span><br>  br i1 %20, label %.lr.ph56, label %._crit_edge57<br><br>.lr.ph56:                                         ; preds = %5<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">21 = load i32, ptr %4, align 4, !tbaa !15</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">22 = sext i32 %21 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">23 = add nsw i64 %22, -1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">24 = getelementptr i32, ptr %1, i64 %23</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">25 = load i32, ptr %24, align 4, !tbaa !11</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">26 = sext i32 %25 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">27 = getelementptr i32, ptr %2, i64 %23</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">28 = load i32, ptr %27, align 4, !tbaa !13</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">29 = sext i32 %28 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">reass.sub58 = sub nsw i64 %29, %26</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">30 = add nsw i64 %reass.sub58, 1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">31 = icmp sgt i64 %reass.sub58, -1</span><br>  br i1 %31, label %.lr.ph.us.preheader, label %._crit_edge57<br><br>.lr.ph.us.preheader:                              ; preds = %.lr.ph56<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">32 = add nuw nsw i64 %reass.sub, 1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">invariant.gep = getelementptr i8, ptr %10, i64 -4</span><br>  br label %.lr.ph.us<br><br>.lr.ph.us:                                        ; preds = %.lr.ph.us.preheader, %._crit_edge.us<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">33 = phi i64 [ %51, %._crit_edge.us ], [ %32, %.lr.ph.us.preheader ]</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">34 = phi i32 [ %50, %._crit_edge.us ], [ %15, %.lr.ph.us.preheader ]</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">35 = sext i32 %34 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">36 = add nsw i64 %35, -1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">37 = mul nsw i64 %36, %8</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">gep = getelementptr i32, ptr %invariant.gep, i64 %37</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">gep.us.phi.trans.insert = getelementptr i32, ptr %gep, i64 %26</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">.pre = load i32, ptr %gep.us.phi.trans.insert, align 4, !tbaa !17</span><br>  br label %38<br><br>38:                                               ; preds = %.lr.ph.us, %38<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">39 = phi i32 [ %.pre, %.lr.ph.us ], [ %47, %38 ]</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">40 = phi i64 [ %30, %.lr.ph.us ], [ %48, %38 ]</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">41 = phi i32 [ %25, %.lr.ph.us ], [ %44, %38 ]</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">42 = sext i32 %41 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">gep.us = getelementptr i32, ptr %gep, i64 %42</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">43 = add i32 %39, -10</span><br>  store i32 %43, ptr %gep.us, align 4, !tbaa !17<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">44 = add i32 %41, 1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">45 = sext i32 %44 to i64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">gep54.us = getelementptr i32, ptr %gep, i64 %45</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">46 = load i32, ptr %gep54.us, align 4, !tbaa !21</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">47 = add i32 %46, -20</span><br>  store i32 %47, ptr %gep54.us, align 4, !tbaa !21<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">48 = add nsw i64 %40, -1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">49 = icmp sgt i64 %40, 1</span><br>  br i1 %49, label %38, label %._crit_edge.us<br><br>._crit_edge.us:                                   ; preds = %38<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">50 = add i32 %34, 1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">51 = add nsw i64 %33, -1</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">52 = icmp sgt i64 %33, 1</span><br>  br i1 %52, label %.lr.ph.us, label %._crit_edge57<br><br>._crit_edge57:                                    ; preds = %._crit_edge.us, %.lr.ph56, %5<br>  ret void<br>&#125;<br><br>; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)<br>declare i32 @llvm.smax.i32(i32, i32) #1<br><br>attributes #0 = &#123; nofree norecurse nosync nounwind memory(argmem: read) &quot;target-cpu&quot;=&quot;x86-64&quot; &#125;<br>attributes #1 = &#123; nocallback nofree nosync nounwind speculatable willreturn memory(none) &#125;<br><br>!llvm.module.flags = !&#123;!0, !1, !2&#125;<br><br>!0 = !&#123;i32 2, !&quot;Debug Info Version&quot;, i32 3&#125;<br>!1 = !&#123;i32 8, !&quot;PIC Level&quot;, i32 2&#125;<br>!2 = !&#123;i32 7, !&quot;PIE Level&quot;, i32 2&#125;<br>!3 = !&#123;!4, !4, i64 0&#125;<br>!4 = !&#123;!&quot;dummy arg data/_QFsolveEn&quot;, !5, i64 0&#125;<br>!5 = !&#123;!&quot;dummy arg data&quot;, !6, i64 0&#125;<br>!6 = !&#123;!&quot;any data access&quot;, !7, i64 0&#125;<br>!7 = !&#123;!&quot;any access&quot;, !8, i64 0&#125;<br>!8 = !&#123;!&quot;Flang function root _QPsolve&quot;&#125;<br>!9 = !&#123;!10, !10, i64 0&#125;<br>!10 = !&#123;!&quot;dummy arg data/_QFsolveEi&quot;, !5, i64 0&#125;<br>!11 = !&#123;!12, !12, i64 0&#125;<br>!12 = !&#123;!&quot;dummy arg data/_QFsolveEl&quot;, !5, i64 0&#125;<br>!13 = !&#123;!14, !14, i64 0&#125;<br>!14 = !&#123;!&quot;dummy arg data/_QFsolveEu&quot;, !5, i64 0&#125;<br>!15 = !&#123;!16, !16, i64 0&#125;<br>!16 = !&#123;!&quot;dummy arg data/_QFsolveEj&quot;, !5, i64 0&#125;<br>!17 = !&#123;!18, !18, i64 0&#125;<br>!18 = !&#123;!&quot;any data access&quot;, !19, i64 0&#125;<br>!19 = !&#123;!&quot;any access&quot;, !20, i64 0&#125;<br>!20 = !&#123;!&quot;Flang function root _QFsolvePfunc_current&quot;&#125;<br>!21 = !&#123;!22, !22, i64 0&#125;<br>!22 = !&#123;!&quot;any data access&quot;, !23, i64 0&#125;<br>!23 = !&#123;!&quot;any access&quot;, !24, i64 0&#125;<br>!24 = !&#123;!&quot;Flang function root _QFsolvePfunc_next&quot;&#125;<br></code></pre></td></tr></table></figure>
<h3 id="查看指令选择的文本输出："><a href="#查看指令选择的文本输出：" class="headerlink" title="查看指令选择的文本输出："></a>查看指令选择的文本输出：</h3><p>执行如下命令，将指令选择输出到指定文件里：</p>
<p><code>llc  test.ll --debug-only=isel &gt; test.log 2&gt;&amp;1</code></p>
<p>我这里的是x86架构，针对不同的架构你可以添加选项-march-x86/riscv32等</p>
<p>输出结果详见附录.</p>
<h3 id="查看执行选择的可视化输出："><a href="#查看执行选择的可视化输出：" class="headerlink" title="查看执行选择的可视化输出："></a>查看执行选择的可视化输出：</h3><p>1.z准备可视化数据，比如打印指令选择前的DAG图</p>
<p><code>llc -view-dag-isel-dags  test.ll -o test.s</code></p>
<p>输出结果如下所示：</p>
<p><img src="C:\Users\llj\AppData\Roaming\Typora\typora-user-images\image-20250310210733379.png" alt="image-20250310210733379"></p>
<p>可以发现，可视化数据保存在/tep/dagxxx文件中</p>
<p>2.可视化输出结果</p>
<p>可以使用dot命令，dot支持多种可视化格式（需安装graphviz）</p>
<p>dot -Tpng /tep/dagxxx.dot -o test.png</p>
<p>当然也可以写个py脚本来直接生成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">render_dot_with_system</span>(<span class="hljs-params">dot_file, output_file, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;png&#x27;</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    使用系统安装的 Graphviz 渲染</span><br><span class="hljs-string">    需要提前安装 Graphviz (apt install graphviz / brew install graphviz)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(dot_file):<br>        <span class="hljs-keyword">raise</span> FileNotFoundError(<span class="hljs-string">f&quot;DOT 文件不存在: <span class="hljs-subst">&#123;dot_file&#125;</span>&quot;</span>)<br>    <br>    cmd = [<span class="hljs-string">&#x27;dot&#x27;</span>, <span class="hljs-string">&#x27;-T&#x27;</span>, <span class="hljs-built_in">format</span>, dot_file, <span class="hljs-string">&#x27;-o&#x27;</span>, output_file]<br>    <span class="hljs-keyword">try</span>:<br>        subprocess.run(cmd, check=<span class="hljs-literal">True</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;成功生成: <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> subprocess.CalledProcessError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;渲染失败: <span class="hljs-subst">&#123;e&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">except</span> FileNotFoundError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;未找到 &#x27;dot&#x27; 命令，请先安装 Graphviz&quot;</span>)<br><br><span class="hljs-comment"># 使用示例</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    dot_path = <span class="hljs-string">&quot;/nosche.dot&quot;</span>    <span class="hljs-comment"># 输入 .dot 文件路径</span><br>    output_path = <span class="hljs-string">&quot;nosche.png&quot;</span> <span class="hljs-comment"># 输出图片路径</span><br>    render_dot_with_system(dot_path, output_path, <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;png&#x27;</span>)<br></code></pre></td></tr></table></figure>
<h2 id="理解指令选择的文本输出"><a href="#理解指令选择的文本输出" class="headerlink" title="理解指令选择的文本输出"></a>理解指令选择的文本输出</h2><p>指令选择中各阶段的文本输出都是由<code>llvm::SelectionDAG::dump()</code>函数打印的。该函数的声明位于 llvm/include/llvm/CodeGen/SelectionDAG.h 文件，其定义位于 llvm/lib/CodeGen/SelectionDAG/SelectionDAGDumper.cpp 文件。</p>
<p>类<code>llvm::SelectionDAG</code>是一个有向无环图（Directed-Acyclic-Graph，DAG），用于表示每个基本块。DAG 的节点为<code>llvm::SDNode</code>类（定义在 llvm/include/llvm/CodeGen/SelectionDAGNodes.h 文件中）的实例，每个节点对应一条指令或一个操作数。DAG 的边为<code>llvm::SDValue</code>类的实例，作为节点的操作数（即节点的每个操作数都是一条指向其它节点的边）；每条边由一个<code>&lt;SDNode, unsigned&gt;</code>键值对构成，Key 表示所指向的节点（即定义操作数的节点，不妨称为<code>Def-SDNode</code>），Value 是一个索引（从 0 开始）表示使用<code>Def-SDNode</code>所定义的哪个值；每条边决定了两个节点在指令调度后必须满足何种（在基本块内的）先后出现顺序。</p>
<p>DAG 的节点既可以同时定义多个值，也可以同时包含多个操作数。DAG 节点所定义的每个值都关联一个<code>MVT</code>（Machine Value Type），用于表示该值的类型。常见的类型有如下三种（定义在 llvm/include/llvm/Support/MachineValueType.h 文件中）：</p>
<ul>
<li><code>Concrete Value</code>类型，表示具体的数据类型。比如：<code>llvm::MVT::i8</code>、<code>llvm::MVT::f16</code>、<code>llvm::MVT::v1i1</code>等，对应文本输出和 DAG 中的<code>i8</code>、<code>f16</code>等。</li>
<li><code>Other</code>类型，对应的枚举值为<code>llvm::MVT::Other</code>，对应文本输出和 DAG 中的<code>ch</code>。</li>
<li><code>Glue</code>类型，对应的枚举值为<code>llvm::MVT::Glue</code>，对应文本输出和 DAG 中的<code>glue</code>。</li>
</ul>
<p>DAG 的边用于表示两个节点之间的依赖关系：数据依赖或控制依赖。如果节点<code>A</code>依赖于节点<code>B</code>记作<code>A-&gt;B</code>（意味着节点<code>B</code>必须位于节点<code>A</code>的前面）；那么边的含义可以分为如下三种：</p>
<ul>
<li>表示数据依赖，称为<code>regular-edge</code>。对应 DAG 中的<code>从节点A指向节点B的黑色实线</code>。并且，箭头所指向的值（由节点<code>B</code>定义）的<code>MVT</code>类型一定是<code>Concrete Value</code>。</li>
<li>表示控制依赖并且节点<code>A</code>与<code>B</code>之间允许插入其它节点，称为<code>chain-edge</code>。对应 DAG 中的<code>从节点A指向节点B的蓝色虚线</code>。并且，箭头所指向的值（由节点<code>B</code>定义）的<code>MVT</code>类型一定是<code>Other</code>。</li>
<li>表示控制依赖并且节点<code>A</code>与<code>B</code>之间不允许插入其它节点（即节点<code>B</code>后面的第一个节点必须是<code>A</code>），称为<code>glue-edge</code>。对应 DAG 中的<code>从节点A指向节点B的红色实线</code>。并且，箭头所指向的值（由节点<code>B</code>定义）的<code>MVT</code>类型一定是<code>Glue</code>。</li>
</ul>
<p>接下来，以阶段<code>(10)</code>——<code>Instruction Selection</code>为例，说明指令选择的文本输出所表示的含义。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">114 Selected selection DAG: %bb.0 &#x27;test:&#x27;<br>115 SelectionDAG has 9 nodes:<br>116   t0: ch = EntryToken<br>117       t2: i32,ch = CopyFromReg t0, Register:i32 %0<br>118       t4: i32,ch = CopyFromReg t0, Register:i32 %1<br>119     t5: i32 = ADD t2, t4<br>120   t7: ch,glue = CopyToReg t0, Register:i32 $x10, t5<br>121   t8: ch = PseudoRET Register:i32 $x10, t7, t7:1<br></code></pre></td></tr></table></figure>
<ul>
<li><p>第 114 行，<code>%bb.0</code>是由 LLVM 内部为该基本块定义的标签名。<code>&#39;test:&#39;</code>表示该基本块对应的<code>函数名:标签名</code>，这里的函数名和标签名都是在 IR 代码中定义的。</p>
</li>
<li><p>第 115 行，表示该基本块所对应的 DAG 中包含<code>t0~t8</code> 9 个节点。这些节点的节点 ID（即<code>llvm::SDNode::PersistentId</code>字段）值为<code>0~8</code>。比如：<code>t0</code>表示节点 ID 为 0 的节点。</p>
</li>
<li><p>第 116 行，<code>t0:</code>表示该节点的节点 ID 为 0 （这里的节点 ID 对应源代码中的<code>SDNode::PersistentId</code>）。</p>
<ul>
<li>等号左侧的<code>ch</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::Other</code>，该值的索引为 0。</li>
<li>等号右侧的<code>EntryToken</code>表示该节点是一个特殊的标记节点（对应的操作码为<code>llvm::ISD::EntryToken</code>）。</li>
</ul>
</li>
<li><p>第 117 行， <code>t2:</code>表示该节点的节点 ID 为 2 。</p>
<ul>
<li><p>等号左侧的<code>i32,ch</code>表示该节点定义了两个值，索引为 0 的值的<code>MVT</code>类型为<code>llvm::MVT::i32</code>；索引为 1 的值的<code>MVT</code>类型为<code>llvm::MVT::Other</code>。</p>
</li>
<li><p>等号右侧的<code>CopyFromReg</code>表示该节点是读寄存器操作（对应的操作码为<code>llvm::ISD::CopyFromReg</code>）。</p>
</li>
<li><p>等号右侧的<code>t0, Register:i32 %0</code>表示该节点包含两个操作数，索引为 0 的操作数表示一条指向<code>t0</code>节点所定义的索引为 0 的值的<code>chain-edge</code>（即省略了<code>t0:0</code>中的<code>:0</code>）；索引为 1 的操作数表示一条指向<code>t1</code>节点所定义的索引为 0 的值的<code>regular-edge</code>。</p>
<p>实际上，<code>Register:i32 %0</code>是 DAG 中的<code>t1</code>节点，其中冒号左侧的<code>Register</code>表示该节点是寄存器（对应的操作码为<code>llvm::ISD::Register</code>）；冒号右侧的<code>i32</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::i32</code>；<code>%0</code>以<code>%</code>开头表示虚拟寄存器<code>%0</code>，该节点在文本输出时被折叠打印了。如果不折叠打印，那么该行的输出结果应该为<code>t2: i32,ch = CopyFromReg t0, t1</code>。</p>
</li>
<li><p>相比于节点<code>t5</code>，节点<code>t2</code>缩进了两个空格，表示节点<code>t2</code>仅被节点<code>t5</code>使用了（即节点<code>t2</code>的使用者只有节点<code>t5</code>，意味着节点<code>t2</code>必须位于节点<code>t5</code>的前面）。<strong>如果节点<code>t2</code>的使用者有多个，那么该节点不会进行缩进打印</strong>。</p>
</li>
</ul>
</li>
<li><p>第 118 行，<code>t4:</code>表示该节点的节点 ID 为 4 。同样地，节点<code>t4</code>也仅被节点<code>t5</code>使用了。</p>
</li>
<li><p>第 119 行，<code>t5:</code>表示该节点的节点 ID 为 5 。</p>
<ul>
<li>等号左侧的<code>i32</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::i32</code>，该值的索引为 0。</li>
<li>等号右侧的<code>ADD</code>表示该节点是机器指令<code>add</code>（对应的操作码为<code>llvm::RISCV::ADD</code>）。</li>
<li>等号右侧的<code>t2, t4</code>表示该节点包含两个操作数，索引为 0 的操作数表示一条指向<code>t2</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（省略了<code>t2:0</code>中的<code>:0</code>）；索引为 1 的操作数表示一条指向<code>t4</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（省略了<code>t4:0</code>中的<code>:0</code>）。</li>
<li>同样地，节点<code>t5</code>仅被节点<code>t7</code>使用了。</li>
</ul>
</li>
<li><p>第 120 行，<code>t7:</code>表示该节点的节点 ID 为 7 。</p>
<ul>
<li><p>等号左侧的<code>ch,glue</code>表示该节点定义了两个值，索引为 0 的值的<code>MVT</code>类型为<code>llvm::MVT::Other</code>；索引为 1 的值的<code>MVT</code>类型为<code>llvm::MVT::Glue</code>。</p>
</li>
<li><p>等号右侧的<code>CopyToReg</code>表示该节点是写寄存器操作（对应的操作码为<code>llvm::ISD::CopyToReg</code>）。</p>
</li>
<li><p>等号右侧的<code>t0, Register:i32 $x10, t5</code>表示该节点包含三个操作数，索引为 0 的操作数表示一条指向<code>t0</code>节点所定义的索引为 0 的值的<code>chain-edge</code>（省略了<code>t0:0</code>中的<code>:0</code>）；索引为 1 的操作数表示一条指向<code>t6</code>节点所定义的索引为 0 的值的<code>regular-edge</code>；索引为 2 的操作数表示一条指向<code>t5</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（省略了<code>t5:0</code>中的<code>:0</code>）。</p>
<p>实际上，<code>Register:i32 $x10</code>是 DAG 中的<code>t6</code>节点，其中冒号左侧的<code>Register</code>表示该节点是寄存器（对应的操作码为<code>llvm::ISD::Register</code>）；冒号右侧的<code>i32</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::i32</code>；<script type="math/tex">x10`以`</script>开头表示物理寄存器<code>x10</code>，该节点在文本输出时被折叠打印了。如果不折叠打印，那么该行的输出结果应该为<code>t7: ch,glue = CopyToReg t0, t6, t5</code>。</p>
</li>
</ul>
</li>
<li><p>第 121 行，<code>t8:</code>表示该节点的节点 ID 为 8 。</p>
<ul>
<li>等号左侧的<code>ch</code>表示该节点仅定义了一个值，其<code>MVT</code>类型为<code>llvm::MVT::Other</code>，该值的索引为 0。</li>
<li>等号右侧的<code>PseudoRET</code>表示该节点是伪机器指令<code>ret</code>（对应的操作码为<code>llvm::RISCV::PseudoRET</code>）。</li>
<li>等号右侧的<code>Register:i32 $x10, t7, t7:1</code>表示该节点包含三个操作数，索引为 0 的操作数表示一条指向<code>t6</code>节点所定义的索引为 0 的值的<code>regular-edge</code>（被折叠打印了）；索引为 1 的操作数表示一条指向<code>t7</code>节点所定义的索引为 0 的值的<code>chain-edge</code>（省略了<code>t7:0</code>中的<code>:0</code>）；索引为 2 的操作数表示一条指向<code>t7</code>节点所定义的索引为 1 的值的<code>glue-edge</code>。</li>
</ul>
</li>
</ul>
<h2 id="理解指令选择的可视化输出"><a href="#理解指令选择的可视化输出" class="headerlink" title="理解指令选择的可视化输出"></a>理解指令选择的可视化输出</h2><p>指令选择中各阶段的可视化输出都是由<code>llvm::SelectionDAG::viewGraph()</code>函数打印的。该函数的声明位于 llvm/include/llvm/CodeGen/SelectionDAG.h 文件，其定义位于 llvm/lib/CodeGen/SelectionDAG/SelectionDAGPrinter.cpp 文件。</p>
<p>接下来，以阶段<code>(10)</code>——<code>Instruction Selection</code>为例，说明指令选择的可视化输出所表示的含义。</p>
<p><img src="D:\Desktop\after\yessche.png" alt="yessche"></p>
<ul>
<li>根节点<code>GraphRoot</code>，实际上 DAG 中不存在该节点（用椭圆形表示）。该节点与节点<code>t8</code>之间有一条<code>chain-edge</code>，表示节点<code>t40</code>必须作为基本块内的最后一条指令。</li>
<li>节点<code>t40</code>，DAG 中实际存在该节点（用圆角矩形表示）。该节点分为四部分，从上到下依次为：操作数的索引、操作码、节点 ID、节点所定义值的<code>MVT</code>类型。每部分的含义大家顺下来文本输出这里应该更加直观的理解，这里不在叙述</li>
</ul>
<h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><p>执行debug-only=isel的输出文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">	FastISel is disabled<br><br><br><br>=== solve_<br><br>Initial selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 55 nodes:<br>  t0: ch,glue = EntryToken<br>  t10: i64,ch = CopyFromReg t0, Register:i64 %26<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>    t15: i32 = smax t13, Constant:i32&lt;0&gt;<br>  t16: i64 = zero_extend nneg t15<br>          t19: i64 = mul nuw nsw t16, t16<br>        t21: i64 = mul t19, Constant:i64&lt;4&gt;<br>      t23: i64 = add nuw t21, Constant:i64&lt;15&gt;<br>    t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;<br>          t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>        t29: i32,ch = load&lt;(load (s32) from %ir.3, !tbaa !9)&gt; t26:1, t8, undef:i64<br>      t30: i64 = sign_extend t29<br>    t32: i64 = add nsw t30, Constant:i64&lt;-1&gt;<br>  t34: i64 = shl t32, Constant:i64&lt;2&gt;<br>      t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t35: i64 = add t4, t34<br>  t36: i32,ch = load&lt;(load (s32) from %ir.14, !tbaa !11)&gt; t26:1, t35, undef:i64<br>          t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>        t40: i64 = add t6, t34<br>      t41: i32,ch = load&lt;(load (s32) from %ir.17, !tbaa !13)&gt; t26:1, t40, undef:i64<br>    t42: i64 = sign_extend t41<br>    t39: i64 = sign_extend t36<br>  t43: i64 = sub nsw t42, t39<br>        t18: ch = CopyToReg t0, Register:i64 %0, t16<br>        t28: ch = CopyToReg t0, Register:i64 %1, t26<br>        t38: ch = CopyToReg t0, Register:i32 %2, t36<br>        t45: ch = CopyToReg t0, Register:i64 %3, t43<br>      t51: ch = TokenFactor t18, t28, t38, t45, t26:1<br>        t47: i1 = setcc t43, Constant:i64&lt;-1&gt;, setgt:ch<br>      t49: i1 = xor t47, Constant:i1&lt;-1&gt;<br>    t52: ch = brcond t51, t49, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t54: ch = br t52, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br><br><br><br>Optimized lowered selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 49 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>    t15: i32 = smax t13, Constant:i32&lt;0&gt;<br>  t16: i64 = zero_extend nneg t15<br>          t19: i64 = mul nuw nsw t16, t16<br>        t68: i64 = shl t19, Constant:i8&lt;2&gt;<br>      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;<br>    t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;<br>        t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>      t40: i64 = add t6, t65<br>    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t26:1, t40, undef:i64<br>  t43: i64 = sub nsw t60, t61<br>      t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t35: i64 = add t4, t65<br>  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t26:1, t35, undef:i64<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t26:1, t8, undef:i64<br>    t64: i64 = shl t66, Constant:i64&lt;2&gt;<br>  t65: i64 = add t64, Constant:i64&lt;-4&gt;<br>        t18: ch = CopyToReg t0, Register:i64 %0, t16<br>        t28: ch = CopyToReg t0, Register:i64 %1, t26<br>          t62: i32 = truncate t61<br>        t38: ch = CopyToReg t0, Register:i32 %2, t62<br>        t45: ch = CopyToReg t0, Register:i64 %3, t43<br>      t51: ch = TokenFactor t18, t28, t38, t45, t26:1<br>      t59: i1 = setcc t43, Constant:i64&lt;0&gt;, setlt:ch<br>    t57: ch = brcond t51, t59, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t54: ch = br t57, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br><br><br><br>Type-legalized selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 51 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>    t15: i32 = smax t13, Constant:i32&lt;0&gt;<br>  t16: i64 = zero_extend nneg t15<br>          t19: i64 = mul nuw nsw t16, t16<br>        t68: i64 = shl t19, Constant:i8&lt;2&gt;<br>      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;<br>    t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;<br>        t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>      t40: i64 = add t6, t65<br>    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t26:1, t40, undef:i64<br>  t43: i64 = sub nsw t60, t61<br>      t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t35: i64 = add t4, t65<br>  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t26:1, t35, undef:i64<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t26:1, t8, undef:i64<br>    t64: i64 = shl t66, Constant:i64&lt;2&gt;<br>  t65: i64 = add t64, Constant:i64&lt;-4&gt;<br>        t18: ch = CopyToReg t0, Register:i64 %0, t16<br>        t28: ch = CopyToReg t0, Register:i64 %1, t26<br>          t62: i32 = truncate t61<br>        t38: ch = CopyToReg t0, Register:i32 %2, t62<br>        t45: ch = CopyToReg t0, Register:i64 %3, t43<br>      t51: ch = TokenFactor t18, t28, t38, t45, t26:1<br>        t69: i8 = setcc t43, Constant:i64&lt;0&gt;, setlt:ch<br>      t72: i8 = and t69, Constant:i8&lt;1&gt;<br>    t57: ch = brcond t51, t72, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t54: ch = br t57, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br><br><br><br>Optimized type-legalized selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 49 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>    t15: i32 = smax t13, Constant:i32&lt;0&gt;<br>  t16: i64 = zero_extend nneg t15<br>          t19: i64 = mul nuw nsw t16, t16<br>        t68: i64 = shl t19, Constant:i8&lt;2&gt;<br>      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;<br>    t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>  t26: i64,ch = dynamic_stackalloc t13:1, t25, Constant:i64&lt;0&gt;<br>        t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>      t40: i64 = add t6, t65<br>    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t26:1, t40, undef:i64<br>  t43: i64 = sub nsw t60, t61<br>      t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t35: i64 = add t4, t65<br>  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t26:1, t35, undef:i64<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t26:1, t8, undef:i64<br>    t64: i64 = shl t66, Constant:i64&lt;2&gt;<br>  t65: i64 = add t64, Constant:i64&lt;-4&gt;<br>        t18: ch = CopyToReg t0, Register:i64 %0, t16<br>        t28: ch = CopyToReg t0, Register:i64 %1, t26<br>          t62: i32 = truncate t61<br>        t38: ch = CopyToReg t0, Register:i32 %2, t62<br>        t45: ch = CopyToReg t0, Register:i64 %3, t43<br>      t51: ch = TokenFactor t18, t28, t38, t45, t26:1<br>      t69: i8 = setcc t43, Constant:i64&lt;0&gt;, setlt:ch<br>    t57: ch = brcond t51, t69, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t54: ch = br t57, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br><br><br><br>Legalized selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 54 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>      t88: i32 = X86ISD::CMP t13, Constant:i32&lt;0&gt;<br>    t91: i32 = X86ISD::CMOV Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t88<br>  t16: i64 = zero_extend nneg t91<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t82, t8, undef:i64<br>    t64: i64 = shl t66, Constant:i8&lt;2&gt;<br>  t65: i64 = add t64, Constant:i64&lt;-4&gt;<br>      t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t35: i64 = add t4, t65<br>  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t82, t35, undef:i64<br>        t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>      t40: i64 = add t6, t65<br>    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t82, t40, undef:i64<br>  t73: i64,i32 = X86ISD::SUB t60, t61<br>    t77: ch,glue = callseq_start t13:1, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;<br>  t79: i64,ch = CopyFromReg t77, Register:i64 $rsp<br>          t19: i64 = mul nuw nsw t16, t16<br>        t68: i64 = shl t19, Constant:i8&lt;2&gt;<br>      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;<br>    t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>  t80: i64 = sub t79, t25<br>    t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80<br>  t82: ch,glue = callseq_end t81, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;<br>        t18: ch = CopyToReg t0, Register:i64 %0, t16<br>        t28: ch = CopyToReg t0, Register:i64 %1, t80<br>          t62: i32 = truncate t61<br>        t38: ch = CopyToReg t0, Register:i32 %2, t62<br>        t45: ch = CopyToReg t0, Register:i64 %3, t73<br>      t51: ch = TokenFactor t18, t28, t38, t45, t82<br>    t75: ch = X86ISD::BRCOND t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t73:1<br>  t54: ch = br t75, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br><br><br><br>Optimized legalized selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 54 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>      t88: i32 = X86ISD::CMP t13, Constant:i32&lt;0&gt;<br>    t91: i32 = X86ISD::CMOV Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t88<br>  t16: i64 = zero_extend nneg t91<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>      t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t82, t8, undef:i64<br>    t64: i64 = shl t66, Constant:i8&lt;2&gt;<br>  t65: i64 = add t64, Constant:i64&lt;-4&gt;<br>      t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t35: i64 = add t4, t65<br>  t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t82, t35, undef:i64<br>        t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>      t40: i64 = add t6, t65<br>    t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t82, t40, undef:i64<br>  t73: i64,i32 = X86ISD::SUB t60, t61<br>    t77: ch,glue = callseq_start t13:1, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;<br>  t79: i64,ch = CopyFromReg t77, Register:i64 $rsp<br>          t19: i64 = mul nuw nsw t16, t16<br>        t68: i64 = shl t19, Constant:i8&lt;2&gt;<br>      t23: i64 = add nuw t68, Constant:i64&lt;15&gt;<br>    t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>  t80: i64 = sub t79, t25<br>    t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80<br>  t82: ch,glue = callseq_end t81, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;<br>        t18: ch = CopyToReg t0, Register:i64 %0, t16<br>        t28: ch = CopyToReg t0, Register:i64 %1, t80<br>          t62: i32 = truncate t61<br>        t38: ch = CopyToReg t0, Register:i32 %2, t62<br>        t45: ch = CopyToReg t0, Register:i64 %3, t73<br>      t51: ch = TokenFactor t18, t28, t38, t45, t82<br>    t75: ch = X86ISD::BRCOND t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t73:1<br>  t54: ch = br t75, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br><br><br>===== Instruction selection begins: %bb.0 &#x27;&#x27;<br><br>ISEL: Starting selection on root node: t54: ch = br t75, BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;<br>ISEL: Starting pattern match<br>  Morphed node: t54: ch = JMP_1 BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;, t75<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t75: ch = X86ISD::BRCOND t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t73:1<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135091<br>  Morphed node: t75: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t93, t93:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t51: ch = TokenFactor t18, t28, t38, t45, t82<br><br>ISEL: Starting selection on root node: t45: ch = CopyToReg t0, Register:i64 %3, t73<br><br>ISEL: Starting selection on root node: t38: ch = CopyToReg t0, Register:i32 %2, t62<br><br>ISEL: Starting selection on root node: t73: i64,i32 = X86ISD::SUB t60, t61<br>ISEL: Starting pattern match<br>  Initial Opcode index to 114065<br>  Match failed at index 114078<br>  Continuing at 114269<br>  Match failed at index 114270<br>  Continuing at 114372<br>  Match failed at index 114373<br>  Continuing at 114475<br>  Continuing at 114476<br>  Match failed at index 114477<br>  Continuing at 114578<br>  Skipped scope entry (due to false predicate) at index 114589, continuing at 114720<br>  Match failed at index 114724<br>  Continuing at 114738<br>  Match failed at index 114742<br>  Continuing at 114756<br>  Match failed at index 114760<br>  Continuing at 114773<br>  Match failed at index 114774<br>  Continuing at 114792<br>  Match failed at index 114796<br>  Continuing at 114810<br>  Match failed at index 114814<br>  Continuing at 114828<br>  Match failed at index 114832<br>  Continuing at 114845<br>  Match failed at index 114846<br>  Continuing at 114864<br>  Continuing at 114865<br>  Match failed at index 114866<br>  Continuing at 114892<br>  Match failed at index 114893<br>  Continuing at 114919<br>  Match failed at index 114920<br>  Continuing at 114945<br>  Morphed node: t73: i64,i32 = SUB64rr t60, t61<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t62: i32 = truncate t61<br>ISEL: Starting pattern match<br>  Initial Opcode index to 131882<br>  Match failed at index 131885<br>  Continuing at 131993<br>  TypeSwitch[i32] from 131996 to 132025<br>  Morphed node: t62: i32 = EXTRACT_SUBREG t61, TargetConstant:i32&lt;6&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t60: i64,ch = load&lt;(load (s32) from %ir.17, !tbaa !13), sext from i32&gt; t82, t40, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164<br>  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183<br>  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201<br>  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218<br>  Match failed at index 122221<br>  Continuing at 122258<br>  Match failed at index 122259<br>  Continuing at 122298<br>  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320<br>  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337<br>  Morphed node: t60: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.17, !tbaa !13)&gt; t6, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t61: i64,ch = load&lt;(load (s32) from %ir.14, !tbaa !11), sext from i32&gt; t82, t35, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164<br>  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183<br>  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201<br>  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218<br>  Match failed at index 122221<br>  Continuing at 122258<br>  Match failed at index 122259<br>  Continuing at 122298<br>  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320<br>  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337<br>  Morphed node: t61: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.14, !tbaa !11)&gt; t4, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t66: i64,ch = load&lt;(load (s32) from %ir.3, !tbaa !9), sext from i32&gt; t82, t8, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164<br>  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183<br>  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201<br>  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218<br>  Match failed at index 122221<br>  Continuing at 122258<br>  Match failed at index 122259<br>  Continuing at 122298<br>  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320<br>  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337<br>  Morphed node: t66: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.3, !tbaa !9)&gt; t8, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t82<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t82: ch,glue = callseq_end t81, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 134948<br>  Skipped scope entry (due to false predicate) at index 134963, continuing at 134974<br>  Morphed node: t82: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, t81<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80<br><br>ISEL: Starting selection on root node: t28: ch = CopyToReg t0, Register:i64 %1, t80<br><br>ISEL: Starting selection on root node: t80: i64 = sub t79, t25<br>ISEL: Starting pattern match<br>  Initial Opcode index to 56806<br>  Skipped scope entry (due to false predicate) at index 56808, continuing at 56910<br>  Match failed at index 56913<br>  Continuing at 57259<br>  Match failed at index 57263<br>  Continuing at 57459<br>  TypeSwitch[i64] from 57461 to 57498<br>  Match failed at index 57498<br>  Continuing at 57511<br>  Match failed at index 57513<br>  Continuing at 57654<br>  Match failed at index 57664<br>  Continuing at 57788<br>  Match failed at index 57789<br>  Continuing at 57815<br>  Match failed at index 57816<br>  Continuing at 57842<br>  Match failed at index 57843<br>  Continuing at 57868<br>  Morphed node: t80: i64,i32 = SUB64rr t79, t25<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t25: i64 = and t23, Constant:i64&lt;-16&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 64496<br>  Match failed at index 64500<br>  Continuing at 64964<br>  Match failed at index 64973<br>  Continuing at 65005<br>  Match failed at index 65009<br>  Continuing at 65041<br>  Match failed at index 65045<br>  Continuing at 65076<br>  Match failed at index 65077<br>  Continuing at 65113<br>  Continuing at 65114<br>  Match failed at index 65117<br>  Continuing at 65354<br>  Match failed at index 65358<br>  Continuing at 65554<br>  OpcodeSwitch from 65557 to 65836<br>  Skipped scope entry (due to false predicate) at index 65839, continuing at 65874<br>  Skipped scope entry (due to false predicate) at index 65875, continuing at 65910<br>  Match failed at index 65837<br>  Continuing at 65912<br>  Match failed at index 65915<br>  Continuing at 66022<br>  Match failed at index 66024<br>  Continuing at 66134<br>  Match failed at index 66135<br>  Continuing at 66198<br>  Match failed at index 66201<br>  Continuing at 66323<br>  Match failed at index 66324<br>  Continuing at 66354<br>  OpcodeSwitch from 66356 to 66360<br>  Match failed at index 66361<br>  Continuing at 66480<br>  Match failed at index 66483<br>  Continuing at 66515<br>  Match failed at index 66521<br>  Continuing at 66550<br>  Match failed at index 66553<br>  Continuing at 66639<br>  Match failed at index 66641<br>  Continuing at 66728<br>  Match failed at index 66729<br>  Continuing at 66750<br>  Match failed at index 66751<br>  Continuing at 66800<br>  Match failed at index 66801<br>  Continuing at 66836<br>  Match failed at index 66837<br>  Continuing at 66870<br>  Match failed at index 66871<br>  Continuing at 66903<br>  Skipped scope entry (due to false predicate) at index 66913, continuing at 66931<br>  Skipped scope entry (due to false predicate) at index 66932, continuing at 67010<br>  Skipped scope entry (due to false predicate) at index 67011, continuing at 67029<br>  Morphed node: t25: i64,i32 = AND64ri32 t23, TargetConstant:i64&lt;-16&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t23: i64 = add nuw t68, Constant:i64&lt;15&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Morphed node: t23: i64 = LEA64r nuw Register:i64 $noreg, TargetConstant:i8&lt;4&gt;, t19, TargetConstant:i32&lt;15&gt;, Register:i16 $noreg<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t18: ch = CopyToReg t0, Register:i64 %0, t16<br><br>ISEL: Starting selection on root node: t19: i64 = mul nuw nsw t16, t16<br>ISEL: Starting pattern match<br>  Initial Opcode index to 95377<br>  Match failed at index 95380<br>  Continuing at 95473<br>  Match failed at index 95477<br>  Continuing at 95648<br>  Match failed at index 95651<br>  Continuing at 95805<br>  TypeSwitch[i64] from 95807 to 95844<br>  Match failed at index 95844<br>  Continuing at 95857<br>  Match failed at index 95867<br>  Continuing at 95912<br>  Match failed at index 95913<br>  Continuing at 95924<br>  Match failed at index 95925<br>  Continuing at 95951<br>  Match failed at index 95952<br>  Continuing at 95977<br>  Morphed node: t19: i64,i32 = IMUL64rr nuw nsw t16, t16<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t16: i64 = zero_extend nneg t91<br>ISEL: Starting pattern match<br>  Initial Opcode index to 133343<br>  Match failed at index 133347<br>  Continuing at 133490<br>  Morphed node: t16: i64 = SUBREG_TO_REG nneg TargetConstant:i64&lt;0&gt;, t91, TargetConstant:i32&lt;6&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t79: i64,ch = CopyFromReg t77, Register:i64 $rsp<br><br>ISEL: Starting selection on root node: t91: i32 = X86ISD::CMOV Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t88<br>ISEL: Starting pattern match<br>  Initial Opcode index to 97695<br>  Match failed at index 97705<br>  Continuing at 97896<br>  Match failed at index 97899<br>  Continuing at 98125<br>  TypeSwitch[i32] from 98136 to 98152<br>  Match failed at index 98152<br>  Continuing at 98177<br>  Skipped scope entry (due to false predicate) at index 98182, continuing at 98241<br>  TypeSwitch[i32] from 98254 to 98300<br>  Morphed node: t91: i32 = CMOV32rr Constant:i32&lt;0&gt;, t13, TargetConstant:i8&lt;15&gt;, t104:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t77: ch,glue = callseq_start t13:1, TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 134990<br>  Skipped scope entry (due to false predicate) at index 135004, continuing at 135018<br>  Morphed node: t77: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t13:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t88: i32 = X86ISD::CMP t13, Constant:i32&lt;0&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 21254<br>  OpcodeSwitch from 21258 to 21707<br>  Match failed at index 21709<br>  Continuing at 21932<br>  Skipped scope entry (due to false predicate) at index 21936, continuing at 21965<br>  Skipped scope entry (due to false predicate) at index 21966, continuing at 21995<br>  Match failed at index 21998<br>  Continuing at 22024<br>  Match failed at index 22025<br>  Continuing at 22052<br>  Continuing at 22053<br>  OpcodeSwitch from 22056 to 22060<br>  Match failed at index 22062<br>  Continuing at 22405<br>  Skipped scope entry (due to false predicate) at index 22410, continuing at 22468<br>  Skipped scope entry (due to false predicate) at index 22469, continuing at 22527<br>  Morphed node: t88: i32 = TEST32rr t13, t13<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t13: i32,ch = load&lt;(load (s32) from %ir.0, !tbaa !3)&gt; t0, t2, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Match failed at index 122148<br>  Continuing at 122164<br>  Match failed at index 122167<br>  Continuing at 122183<br>  Morphed node: t13: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.0, !tbaa !3)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %25<br><br>ISEL: Starting selection on root node: t6: i64,ch = CopyFromReg t0, Register:i64 %24<br><br>ISEL: Starting selection on root node: t4: i64,ch = CopyFromReg t0, Register:i64 %23<br><br>ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %22<br><br>ISEL: Starting selection on root node: t89: i8 = TargetConstant&lt;15&gt;<br><br>ISEL: Starting selection on root node: t78: i64 = Register $rsp<br><br>ISEL: Starting selection on root node: t76: i64 = TargetConstant&lt;0&gt;<br><br>ISEL: Starting selection on root node: t74: i8 = TargetConstant&lt;8&gt;<br><br>ISEL: Starting selection on root node: t53: ch = BasicBlock&lt;.lr.ph56 0x60c587dbab30&gt;<br><br>ISEL: Starting selection on root node: t50: ch = BasicBlock&lt;._crit_edge57 0x60c587dbb238&gt;<br><br>ISEL: Starting selection on root node: t44: i64 = Register %3<br><br>ISEL: Starting selection on root node: t37: i32 = Register %2<br><br>ISEL: Starting selection on root node: t27: i64 = Register %1<br><br>ISEL: Starting selection on root node: t17: i64 = Register %0<br><br>ISEL: Starting selection on root node: t14: i32 = Constant&lt;0&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 131651<br>  TypeSwitch[i32] from 131655 to 131658<br>  Morphed node: t14: i32,i32 = MOV32r0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t7: i64 = Register %25<br><br>ISEL: Starting selection on root node: t5: i64 = Register %24<br><br>ISEL: Starting selection on root node: t3: i64 = Register %23<br><br>ISEL: Starting selection on root node: t1: i64 = Register %22<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.0 &#x27;solve_:&#x27;<br>SelectionDAG has 57 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %22<br>  t13: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.0, !tbaa !3)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0<br>    t77: i64,ch,glue = ADJCALLSTACKDOWN64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, TargetConstant:i32&lt;0&gt;, t13:1<br>  t79: i64,ch = CopyFromReg t77:1, Register:i64 $rsp<br>        t88: i32 = TEST32rr t13, t13<br>      t104: ch,glue = CopyToReg t0, Register:i32 $eflags, t88<br>    t91: i32 = CMOV32rr MOV32r0:i32,i32, t13, TargetConstant:i8&lt;15&gt;, t104:1<br>  t16: i64 = SUBREG_TO_REG nneg TargetConstant:i64&lt;0&gt;, t91, TargetConstant:i32&lt;6&gt;<br>        t19: i64,i32 = IMUL64rr nuw nsw t16, t16<br>      t23: i64 = LEA64r nuw Register:i64 $noreg, TargetConstant:i8&lt;4&gt;, t19, TargetConstant:i32&lt;15&gt;, Register:i16 $noreg<br>    t25: i64,i32 = AND64ri32 t23, TargetConstant:i64&lt;-16&gt;<br>  t80: i64,i32 = SUB64rr t79, t25<br>    t81: ch = CopyToReg t79:1, Register:i64 $rsp, t80<br>  t82: i64,ch,glue = ADJCALLSTACKUP64 TargetConstant:i64&lt;0&gt;, TargetConstant:i64&lt;0&gt;, t81<br>    t8: i64,ch = CopyFromReg t0, Register:i64 %25<br>  t66: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.3, !tbaa !9)&gt; t8, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t82:1<br>    t4: i64,ch = CopyFromReg t0, Register:i64 %23<br>  t61: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.14, !tbaa !11)&gt; t4, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82:1<br>      t6: i64,ch = CopyFromReg t0, Register:i64 %24<br>    t60: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.17, !tbaa !13)&gt; t6, TargetConstant:i8&lt;4&gt;, t66, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t82:1<br>  t73: i64,i32 = SUB64rr t60, t61<br>      t18: ch = CopyToReg t0, Register:i64 %0, t16<br>      t28: ch = CopyToReg t0, Register:i64 %1, t80<br>        t62: i32 = EXTRACT_SUBREG t61, TargetConstant:i32&lt;6&gt;<br>      t38: ch = CopyToReg t0, Register:i32 %2, t62<br>      t45: ch = CopyToReg t0, Register:i64 %3, t73<br>    t51: ch = TokenFactor t18, t28, t38, t45, t82:1<br>  t93: ch,glue = CopyToReg t51, Register:i32 $eflags, t73:1<br>  t101: i32 = Register $noreg<br>    t75: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t93, t93:1<br>  t54: ch = JMP_1 BasicBlock:ch&lt;.lr.ph56 0x60c587dbab30&gt;, t75<br><br><br>Total amount of phi nodes to update: 0<br><br>Initial selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 37 nodes:<br>  t0: ch,glue = EntryToken<br>  t3: i64 = Constant&lt;0&gt;<br>          t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>        t5: i32,ch = load&lt;(load (s32) from %ir.4, !tbaa !15)&gt; t0, t2, undef:i64<br>      t6: i64 = sign_extend t5<br>    t8: i64 = add nsw t6, Constant:i64&lt;-1&gt;<br>  t12: i64 = shl t8, Constant:i64&lt;2&gt;<br>      t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t13: i64 = add t10, t12<br>  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>  t17: i64 = sign_extend t14<br>        t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>      t22: i64 = add t21, t12<br>    t23: i32,ch = load&lt;(load (s32) from %ir.27, !tbaa !13)&gt; t0, t22, undef:i64<br>  t24: i64 = sign_extend t23<br>        t16: ch = CopyToReg t0, Register:i32 %4, t14<br>        t19: ch = CopyToReg t0, Register:i64 %5, t17<br>        t26: ch = CopyToReg t0, Register:i64 %6, t24<br>      t33: ch = TokenFactor t16, t19, t26<br>          t27: i64 = sub nsw t24, t17<br>        t29: i1 = setcc t27, Constant:i64&lt;-1&gt;, setgt:ch<br>      t31: i1 = xor t29, Constant:i1&lt;-1&gt;<br>    t34: ch = brcond t33, t31, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t36: ch = br t34, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br><br><br>Optimized lowered selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 33 nodes:<br>  t0: ch,glue = EntryToken<br>      t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t13: i64 = add t10, t46<br>  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>  t17: i64 = sign_extend t14<br>      t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>    t22: i64 = add t21, t46<br>  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64<br>    t45: i64 = shl t47, Constant:i64&lt;2&gt;<br>  t46: i64 = add t45, Constant:i64&lt;-4&gt;<br>        t16: ch = CopyToReg t0, Register:i32 %4, t14<br>        t19: ch = CopyToReg t0, Register:i64 %5, t17<br>        t26: ch = CopyToReg t0, Register:i64 %6, t43<br>      t33: ch = TokenFactor t16, t19, t26<br>        t27: i64 = sub nsw t43, t17<br>      t42: i1 = setcc t27, Constant:i64&lt;0&gt;, setlt:ch<br>    t39: ch = brcond t33, t42, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t36: ch = br t39, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br><br><br>Type-legalized selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 35 nodes:<br>  t0: ch,glue = EntryToken<br>      t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t13: i64 = add t10, t46<br>  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>  t17: i64 = sign_extend t14<br>      t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>    t22: i64 = add t21, t46<br>  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64<br>    t45: i64 = shl t47, Constant:i64&lt;2&gt;<br>  t46: i64 = add t45, Constant:i64&lt;-4&gt;<br>        t16: ch = CopyToReg t0, Register:i32 %4, t14<br>        t19: ch = CopyToReg t0, Register:i64 %5, t17<br>        t26: ch = CopyToReg t0, Register:i64 %6, t43<br>      t33: ch = TokenFactor t16, t19, t26<br>          t27: i64 = sub nsw t43, t17<br>        t48: i8 = setcc t27, Constant:i64&lt;0&gt;, setlt:ch<br>      t51: i8 = and t48, Constant:i8&lt;1&gt;<br>    t39: ch = brcond t33, t51, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t36: ch = br t39, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br><br><br>Optimized type-legalized selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 33 nodes:<br>  t0: ch,glue = EntryToken<br>      t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t13: i64 = add t10, t46<br>  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>  t17: i64 = sign_extend t14<br>      t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>    t22: i64 = add t21, t46<br>  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64<br>    t45: i64 = shl t47, Constant:i64&lt;2&gt;<br>  t46: i64 = add t45, Constant:i64&lt;-4&gt;<br>        t16: ch = CopyToReg t0, Register:i32 %4, t14<br>        t19: ch = CopyToReg t0, Register:i64 %5, t17<br>        t26: ch = CopyToReg t0, Register:i64 %6, t43<br>      t33: ch = TokenFactor t16, t19, t26<br>        t27: i64 = sub nsw t43, t17<br>      t48: i8 = setcc t27, Constant:i64&lt;0&gt;, setlt:ch<br>    t39: ch = brcond t33, t48, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>  t36: ch = br t39, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br><br><br>Legalized selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 31 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64<br>    t45: i64 = shl t47, Constant:i8&lt;2&gt;<br>  t46: i64 = add t45, Constant:i64&lt;-4&gt;<br>      t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t13: i64 = add t10, t46<br>  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>      t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>    t22: i64 = add t21, t46<br>  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64<br>  t17: i64 = sign_extend t14<br>        t16: ch = CopyToReg t0, Register:i32 %4, t14<br>        t19: ch = CopyToReg t0, Register:i64 %5, t17<br>        t26: ch = CopyToReg t0, Register:i64 %6, t43<br>      t33: ch = TokenFactor t16, t19, t26<br>      t52: i64,i32 = X86ISD::SUB t43, t17<br>    t54: ch = X86ISD::BRCOND t33, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t52:1<br>  t36: ch = br t54, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br><br><br>Optimized legalized selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 31 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>      t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64<br>    t45: i64 = shl t47, Constant:i8&lt;2&gt;<br>  t46: i64 = add t45, Constant:i64&lt;-4&gt;<br>      t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>    t13: i64 = add t10, t46<br>  t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>      t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>    t22: i64 = add t21, t46<br>  t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64<br>  t17: i64 = sign_extend t14<br>        t16: ch = CopyToReg t0, Register:i32 %4, t14<br>        t19: ch = CopyToReg t0, Register:i64 %5, t17<br>        t26: ch = CopyToReg t0, Register:i64 %6, t43<br>      t33: ch = TokenFactor t16, t19, t26<br>      t52: i64,i32 = X86ISD::SUB t43, t17<br>    t54: ch = X86ISD::BRCOND t33, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t52:1<br>  t36: ch = br t54, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br><br>===== Instruction selection begins: %bb.1 &#x27;.lr.ph56&#x27;<br><br>ISEL: Starting selection on root node: t36: ch = br t54, BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 136351<br>  Morphed node: t36: ch = JMP_1 BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;, t54<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t54: ch = X86ISD::BRCOND t33, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t52:1<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135091<br>  Morphed node: t54: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t57, t57:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t33: ch = TokenFactor t16, t19, t26<br><br>ISEL: Starting selection on root node: t19: ch = CopyToReg t0, Register:i64 %5, t17<br><br>ISEL: Starting selection on root node: t52: i64,i32 = X86ISD::SUB t43, t17<br>ISEL: Starting pattern match<br>  Initial Opcode index to 114065<br>  Match failed at index 114073<br>  Continuing at 114269<br>  Match failed at index 114270<br>  Continuing at 114372<br>  Match failed at index 114373<br>  Continuing at 114475<br>  Continuing at 114476<br>  Match failed at index 114477<br>  Continuing at 114578<br>  Skipped scope entry (due to false predicate) at index 114589, continuing at 114720<br>  Match failed at index 114724<br>  Continuing at 114738<br>  Match failed at index 114742<br>  Continuing at 114756<br>  Match failed at index 114760<br>  Continuing at 114773<br>  Match failed at index 114774<br>  Continuing at 114792<br>  Match failed at index 114796<br>  Continuing at 114810<br>  Match failed at index 114814<br>  Continuing at 114828<br>  Match failed at index 114832<br>  Continuing at 114845<br>  Match failed at index 114846<br>  Continuing at 114864<br>  Continuing at 114865<br>  Match failed at index 114866<br>  Continuing at 114892<br>  Match failed at index 114893<br>  Continuing at 114919<br>  Match failed at index 114920<br>  Continuing at 114945<br>  Morphed node: t52: i64,i32 = SUB64rr t43, t17<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t26: ch = CopyToReg t0, Register:i64 %6, t43<br><br>ISEL: Starting selection on root node: t16: ch = CopyToReg t0, Register:i32 %4, t14<br><br>ISEL: Starting selection on root node: t17: i64 = sign_extend t14<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135712<br>  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737<br>  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758<br>  Morphed node: t17: i64 = MOVSX64rr32 t14<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t43: i64,ch = load&lt;(load (s32) from %ir.27, !tbaa !13), sext from i32&gt; t0, t22, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164<br>  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183<br>  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201<br>  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218<br>  Match failed at index 122221<br>  Continuing at 122258<br>  Match failed at index 122259<br>  Continuing at 122298<br>  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320<br>  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337<br>  Morphed node: t43: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.27, !tbaa !13)&gt; t21, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t14: i32,ch = load&lt;(load (s32) from %ir.24, !tbaa !11)&gt; t0, t13, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Match failed at index 122148<br>  Continuing at 122164<br>  Match failed at index 122167<br>  Continuing at 122183<br>  Morphed node: t14: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.24, !tbaa !11)&gt; t10, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t47: i64,ch = load&lt;(load (s32) from %ir.4, !tbaa !15), sext from i32&gt; t0, t2, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Skipped scope entry (due to false predicate) at index 122146, continuing at 122164<br>  Skipped scope entry (due to false predicate) at index 122165, continuing at 122183<br>  Skipped scope entry (due to false predicate) at index 122184, continuing at 122201<br>  Skipped scope entry (due to false predicate) at index 122202, continuing at 122218<br>  Match failed at index 122221<br>  Continuing at 122258<br>  Match failed at index 122259<br>  Continuing at 122298<br>  Skipped scope entry (due to false predicate) at index 122304, continuing at 122320<br>  Skipped scope entry (due to false predicate) at index 122321, continuing at 122337<br>  Morphed node: t47: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.4, !tbaa !15)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t21: i64,ch = CopyFromReg t0, Register:i64 %24<br><br>ISEL: Starting selection on root node: t10: i64,ch = CopyFromReg t0, Register:i64 %23<br><br>ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %26<br><br>ISEL: Starting selection on root node: t53: i8 = TargetConstant&lt;8&gt;<br><br>ISEL: Starting selection on root node: t35: ch = BasicBlock&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;<br><br>ISEL: Starting selection on root node: t32: ch = BasicBlock&lt;._crit_edge57 0x60c587dbb238&gt;<br><br>ISEL: Starting selection on root node: t25: i64 = Register %6<br><br>ISEL: Starting selection on root node: t20: i64 = Register %24<br><br>ISEL: Starting selection on root node: t18: i64 = Register %5<br><br>ISEL: Starting selection on root node: t15: i32 = Register %4<br><br>ISEL: Starting selection on root node: t9: i64 = Register %23<br><br>ISEL: Starting selection on root node: t1: i64 = Register %26<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.1 &#x27;solve_:.lr.ph56&#x27;<br>SelectionDAG has 32 nodes:<br>  t0: ch,glue = EntryToken<br>    t2: i64,ch = CopyFromReg t0, Register:i64 %26<br>  t47: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.4, !tbaa !15)&gt; t2, TargetConstant:i8&lt;1&gt;, Register:i64 $noreg, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0<br>    t10: i64,ch = CopyFromReg t0, Register:i64 %23<br>  t14: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.24, !tbaa !11)&gt; t10, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0<br>    t21: i64,ch = CopyFromReg t0, Register:i64 %24<br>  t43: i64,ch = MOVSX64rm32&lt;Mem:(load (s32) from %ir.27, !tbaa !13)&gt; t21, TargetConstant:i8&lt;4&gt;, t47, TargetConstant:i32&lt;-4&gt;, Register:i16 $noreg, t0<br>  t17: i64 = MOVSX64rr32 t14<br>      t16: ch = CopyToReg t0, Register:i32 %4, t14<br>      t19: ch = CopyToReg t0, Register:i64 %5, t17<br>      t26: ch = CopyToReg t0, Register:i64 %6, t43<br>    t33: ch = TokenFactor t16, t19, t26<br>    t52: i64,i32 = SUB64rr t43, t17<br>  t57: ch,glue = CopyToReg t33, Register:i32 $eflags, t52:1<br>    t54: ch = JCC_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, TargetConstant:i8&lt;8&gt;, t57, t57:1<br>  t36: ch = JMP_1 BasicBlock:ch&lt;.lr.ph.us.preheader 0x60c587dbac30&gt;, t54<br><br><br>Total amount of phi nodes to update: 0<br><br>Initial selection DAG: %bb.2 &#x27;solve_:.lr.ph.us.preheader&#x27;<br>SelectionDAG has 26 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %3<br>      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;<br>    t6: ch = CopyToReg t0, Register:i64 %7, t4<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %1<br>      t10: i64 = add t8, Constant:i64&lt;-4&gt;<br>    t12: ch = CopyToReg t0, Register:i64 %8, t10<br>            t14: i64,ch = CopyFromReg t0, Register:i64 %6<br>          t16: i64 = AssertSext t14, ValueType:ch:i32<br>        t18: i64 = add t16, Constant:i64&lt;2&gt;<br>          t20: i64,ch = CopyFromReg t0, Register:i64 %5<br>        t21: i64 = AssertSext t20, ValueType:ch:i32<br>      t22: i64 = sub t18, t21<br>    t24: ch = CopyToReg t0, Register:i64 %9, t22<br>  t25: ch = TokenFactor t6, t12, t24<br><br><br><br>Optimized lowered selection DAG: %bb.2 &#x27;solve_:.lr.ph.us.preheader&#x27;<br>SelectionDAG has 26 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %3<br>      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;<br>    t6: ch = CopyToReg t0, Register:i64 %7, t4<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %1<br>      t10: i64 = add t8, Constant:i64&lt;-4&gt;<br>    t12: ch = CopyToReg t0, Register:i64 %8, t10<br>            t14: i64,ch = CopyFromReg t0, Register:i64 %6<br>          t16: i64 = AssertSext t14, ValueType:ch:i32<br>            t20: i64,ch = CopyFromReg t0, Register:i64 %5<br>          t21: i64 = AssertSext t20, ValueType:ch:i32<br>        t26: i64 = sub t16, t21<br>      t27: i64 = add t26, Constant:i64&lt;2&gt;<br>    t24: ch = CopyToReg t0, Register:i64 %9, t27<br>  t25: ch = TokenFactor t6, t12, t24<br><br><br><br>Type-legalized selection DAG: %bb.2 &#x27;solve_:.lr.ph.us.preheader&#x27;<br>SelectionDAG has 26 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %3<br>      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;<br>    t6: ch = CopyToReg t0, Register:i64 %7, t4<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %1<br>      t10: i64 = add t8, Constant:i64&lt;-4&gt;<br>    t12: ch = CopyToReg t0, Register:i64 %8, t10<br>            t14: i64,ch = CopyFromReg t0, Register:i64 %6<br>          t16: i64 = AssertSext t14, ValueType:ch:i32<br>            t20: i64,ch = CopyFromReg t0, Register:i64 %5<br>          t21: i64 = AssertSext t20, ValueType:ch:i32<br>        t26: i64 = sub t16, t21<br>      t27: i64 = add t26, Constant:i64&lt;2&gt;<br>    t24: ch = CopyToReg t0, Register:i64 %9, t27<br>  t25: ch = TokenFactor t6, t12, t24<br><br><br><br>Legalized selection DAG: %bb.2 &#x27;solve_:.lr.ph.us.preheader&#x27;<br>SelectionDAG has 26 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %3<br>      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;<br>    t6: ch = CopyToReg t0, Register:i64 %7, t4<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %1<br>      t10: i64 = add t8, Constant:i64&lt;-4&gt;<br>    t12: ch = CopyToReg t0, Register:i64 %8, t10<br>            t14: i64,ch = CopyFromReg t0, Register:i64 %6<br>          t16: i64 = AssertSext t14, ValueType:ch:i32<br>            t20: i64,ch = CopyFromReg t0, Register:i64 %5<br>          t21: i64 = AssertSext t20, ValueType:ch:i32<br>        t26: i64 = sub t16, t21<br>      t27: i64 = add t26, Constant:i64&lt;2&gt;<br>    t24: ch = CopyToReg t0, Register:i64 %9, t27<br>  t25: ch = TokenFactor t6, t12, t24<br><br><br><br>Optimized legalized selection DAG: %bb.2 &#x27;solve_:.lr.ph.us.preheader&#x27;<br>SelectionDAG has 26 nodes:<br>  t0: ch,glue = EntryToken<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %3<br>      t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;<br>    t6: ch = CopyToReg t0, Register:i64 %7, t4<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %1<br>      t10: i64 = add t8, Constant:i64&lt;-4&gt;<br>    t12: ch = CopyToReg t0, Register:i64 %8, t10<br>            t14: i64,ch = CopyFromReg t0, Register:i64 %6<br>          t16: i64 = AssertSext t14, ValueType:ch:i32<br>            t20: i64,ch = CopyFromReg t0, Register:i64 %5<br>          t21: i64 = AssertSext t20, ValueType:ch:i32<br>        t26: i64 = sub t16, t21<br>      t27: i64 = add t26, Constant:i64&lt;2&gt;<br>    t24: ch = CopyToReg t0, Register:i64 %9, t27<br>  t25: ch = TokenFactor t6, t12, t24<br><br><br>===== Instruction selection begins: %bb.2 &#x27;.lr.ph.us.preheader&#x27;<br><br>ISEL: Starting selection on root node: t25: ch = TokenFactor t6, t12, t24<br><br>ISEL: Starting selection on root node: t24: ch = CopyToReg t0, Register:i64 %9, t27<br><br>ISEL: Starting selection on root node: t27: i64 = add t26, Constant:i64&lt;2&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Match failed at index 53496<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905<br>  Morphed node: t27: i64,i32 = ADD64ri32 t26, TargetConstant:i64&lt;2&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t26: i64 = sub t16, t21<br>ISEL: Starting pattern match<br>  Initial Opcode index to 56806<br>  Skipped scope entry (due to false predicate) at index 56808, continuing at 56910<br>  Match failed at index 56913<br>  Continuing at 57259<br>  Match failed at index 57263<br>  Continuing at 57459<br>  TypeSwitch[i64] from 57461 to 57498<br>  Match failed at index 57498<br>  Continuing at 57511<br>  Match failed at index 57513<br>  Continuing at 57654<br>  Match failed at index 57664<br>  Continuing at 57788<br>  Match failed at index 57789<br>  Continuing at 57815<br>  Match failed at index 57816<br>  Continuing at 57842<br>  Match failed at index 57843<br>  Continuing at 57868<br>  Morphed node: t26: i64,i32 = SUB64rr t16, t21<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i64 %8, t10<br><br>ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:i64 %7, t4<br><br>ISEL: Starting selection on root node: t21: i64 = AssertSext t20, ValueType:ch:i32<br><br>ISEL: Starting selection on root node: t16: i64 = AssertSext t14, ValueType:ch:i32<br><br>ISEL: Starting selection on root node: t10: i64 = add t8, Constant:i64&lt;-4&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Match failed at index 53496<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905<br>  Morphed node: t10: i64,i32 = ADD64ri32 t8, TargetConstant:i64&lt;-4&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t4: i64 = add nuw nsw t2, Constant:i64&lt;1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Match failed at index 53496<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  TypeSwitch[i64] from 53706 to 53781<br>  Morphed node: t4: i64,i32 = INC64r nuw nsw t2<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t20: i64,ch = CopyFromReg t0, Register:i64 %5<br><br>ISEL: Starting selection on root node: t14: i64,ch = CopyFromReg t0, Register:i64 %6<br><br>ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %1<br><br>ISEL: Starting selection on root node: t2: i64,ch = CopyFromReg t0, Register:i64 %3<br><br>ISEL: Starting selection on root node: t23: i64 = Register %9<br><br>ISEL: Starting selection on root node: t19: i64 = Register %5<br><br>ISEL: Starting selection on root node: t13: i64 = Register %6<br><br>ISEL: Starting selection on root node: t11: i64 = Register %8<br><br>ISEL: Starting selection on root node: t7: i64 = Register %1<br><br>ISEL: Starting selection on root node: t5: i64 = Register %7<br><br>ISEL: Starting selection on root node: t1: i64 = Register %3<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.2 &#x27;solve_:.lr.ph.us.preheader&#x27;<br>SelectionDAG has 23 nodes:<br>  t0: ch,glue = EntryToken<br>  t28: i32 = Register $noreg<br>        t2: i64,ch = CopyFromReg t0, Register:i64 %3<br>      t4: i64,i32 = INC64r nuw nsw t2<br>    t6: ch = CopyToReg t0, Register:i64 %7, t4<br>        t8: i64,ch = CopyFromReg t0, Register:i64 %1<br>      t10: i64,i32 = ADD64ri32 t8, TargetConstant:i64&lt;-4&gt;<br>    t12: ch = CopyToReg t0, Register:i64 %8, t10<br>          t14: i64,ch = CopyFromReg t0, Register:i64 %6<br>          t20: i64,ch = CopyFromReg t0, Register:i64 %5<br>        t26: i64,i32 = SUB64rr t14, t20<br>      t27: i64,i32 = ADD64ri32 t26, TargetConstant:i64&lt;2&gt;<br>    t24: ch = CopyToReg t0, Register:i64 %9, t27<br>  t25: ch = TokenFactor t6, t12, t24<br><br><br>Total amount of phi nodes to update: 2<br>Node 0 : (0x60c587dbae30, 2147483655)<br>Node 1 : (0x60c587dbae98, 2147483650)<br><br>Initial selection DAG: %bb.3 &#x27;solve_:.lr.ph.us&#x27;<br>SelectionDAG has 29 nodes:<br>  t0: ch,glue = EntryToken<br>    t12: i64,ch = CopyFromReg t0, Register:i64 %8<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t3: i64 = sign_extend t2<br>        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;<br>          t7: i64,ch = CopyFromReg t0, Register:i64 %0<br>        t9: i64 = AssertZext t7, ValueType:ch:i32<br>      t10: i64 = mul nsw t5, t9<br>    t14: i64 = shl t10, Constant:i64&lt;2&gt;<br>  t15: i64 = add t12, t14<br>  t23: i64 = Constant&lt;0&gt;<br>    t17: ch = CopyToReg t0, Register:i64 %12, t15<br>              t19: i64,ch = CopyFromReg t0, Register:i64 %5<br>            t20: i64 = AssertSext t19, ValueType:ch:i32<br>          t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>        t22: i64 = add t15, t21<br>      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64<br>    t27: ch = CopyToReg t0, Register:i32 %13, t25<br>  t28: ch = TokenFactor t17, t27<br><br><br><br>Optimized lowered selection DAG: %bb.3 &#x27;solve_:.lr.ph.us&#x27;<br>SelectionDAG has 28 nodes:<br>  t0: ch,glue = EntryToken<br>    t12: i64,ch = CopyFromReg t0, Register:i64 %8<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t3: i64 = sign_extend t2<br>        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;<br>          t7: i64,ch = CopyFromReg t0, Register:i64 %0<br>        t9: i64 = AssertZext t7, ValueType:ch:i32<br>      t10: i64 = mul nsw t5, t9<br>    t14: i64 = shl t10, Constant:i64&lt;2&gt;<br>  t15: i64 = add t12, t14<br>    t17: ch = CopyToReg t0, Register:i64 %12, t15<br>              t19: i64,ch = CopyFromReg t0, Register:i64 %5<br>            t20: i64 = AssertSext t19, ValueType:ch:i32<br>          t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>        t22: i64 = add t15, t21<br>      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64<br>    t27: ch = CopyToReg t0, Register:i32 %13, t25<br>  t28: ch = TokenFactor t17, t27<br><br><br><br>Type-legalized selection DAG: %bb.3 &#x27;solve_:.lr.ph.us&#x27;<br>SelectionDAG has 28 nodes:<br>  t0: ch,glue = EntryToken<br>    t12: i64,ch = CopyFromReg t0, Register:i64 %8<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t3: i64 = sign_extend t2<br>        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;<br>          t7: i64,ch = CopyFromReg t0, Register:i64 %0<br>        t9: i64 = AssertZext t7, ValueType:ch:i32<br>      t10: i64 = mul nsw t5, t9<br>    t14: i64 = shl t10, Constant:i64&lt;2&gt;<br>  t15: i64 = add t12, t14<br>    t17: ch = CopyToReg t0, Register:i64 %12, t15<br>              t19: i64,ch = CopyFromReg t0, Register:i64 %5<br>            t20: i64 = AssertSext t19, ValueType:ch:i32<br>          t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>        t22: i64 = add t15, t21<br>      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64<br>    t27: ch = CopyToReg t0, Register:i32 %13, t25<br>  t28: ch = TokenFactor t17, t27<br><br><br><br>Legalized selection DAG: %bb.3 &#x27;solve_:.lr.ph.us&#x27;<br>SelectionDAG has 28 nodes:<br>  t0: ch,glue = EntryToken<br>    t12: i64,ch = CopyFromReg t0, Register:i64 %8<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t3: i64 = sign_extend t2<br>        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;<br>          t7: i64,ch = CopyFromReg t0, Register:i64 %0<br>        t9: i64 = AssertZext t7, ValueType:ch:i32<br>      t10: i64 = mul nsw t5, t9<br>    t14: i64 = shl t10, Constant:i8&lt;2&gt;<br>  t15: i64 = add t12, t14<br>    t17: ch = CopyToReg t0, Register:i64 %12, t15<br>              t19: i64,ch = CopyFromReg t0, Register:i64 %5<br>            t20: i64 = AssertSext t19, ValueType:ch:i32<br>          t21: i64 = shl t20, Constant:i8&lt;2&gt;<br>        t22: i64 = add t15, t21<br>      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64<br>    t27: ch = CopyToReg t0, Register:i32 %13, t25<br>  t28: ch = TokenFactor t17, t27<br><br><br><br>Optimized legalized selection DAG: %bb.3 &#x27;solve_:.lr.ph.us&#x27;<br>SelectionDAG has 28 nodes:<br>  t0: ch,glue = EntryToken<br>    t12: i64,ch = CopyFromReg t0, Register:i64 %8<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t3: i64 = sign_extend t2<br>        t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;<br>          t7: i64,ch = CopyFromReg t0, Register:i64 %0<br>        t9: i64 = AssertZext t7, ValueType:ch:i32<br>      t10: i64 = mul nsw t5, t9<br>    t14: i64 = shl t10, Constant:i8&lt;2&gt;<br>  t15: i64 = add t12, t14<br>    t17: ch = CopyToReg t0, Register:i64 %12, t15<br>              t19: i64,ch = CopyFromReg t0, Register:i64 %5<br>            t20: i64 = AssertSext t19, ValueType:ch:i32<br>          t21: i64 = shl t20, Constant:i8&lt;2&gt;<br>        t22: i64 = add t15, t21<br>      t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64<br>    t27: ch = CopyToReg t0, Register:i32 %13, t25<br>  t28: ch = TokenFactor t17, t27<br><br><br>===== Instruction selection begins: %bb.3 &#x27;.lr.ph.us&#x27;<br><br>ISEL: Starting selection on root node: t28: ch = TokenFactor t17, t27<br><br>ISEL: Starting selection on root node: t27: ch = CopyToReg t0, Register:i32 %13, t25<br><br>ISEL: Starting selection on root node: t25: i32,ch = load&lt;(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t0, t22, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Match failed at index 122148<br>  Continuing at 122164<br>  Match failed at index 122167<br>  Continuing at 122183<br>  Morphed node: t25: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t15, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t17: ch = CopyToReg t0, Register:i64 %12, t15<br><br>ISEL: Starting selection on root node: t15: i64 = add t12, t14<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Morphed node: t15: i64 = LEA64r t12, TargetConstant:i8&lt;4&gt;, t10, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t10: i64 = mul nsw t5, t9<br>ISEL: Starting pattern match<br>  Initial Opcode index to 95377<br>  Match failed at index 95380<br>  Continuing at 95473<br>  Match failed at index 95477<br>  Continuing at 95648<br>  Match failed at index 95651<br>  Continuing at 95805<br>  TypeSwitch[i64] from 95807 to 95844<br>  Match failed at index 95844<br>  Continuing at 95857<br>  Match failed at index 95867<br>  Continuing at 95912<br>  Match failed at index 95913<br>  Continuing at 95924<br>  Match failed at index 95925<br>  Continuing at 95951<br>  Match failed at index 95952<br>  Continuing at 95977<br>  Morphed node: t10: i64,i32 = IMUL64rr nsw t5, t9<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t5: i64 = add nsw t3, Constant:i64&lt;-1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Match failed at index 53496<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  TypeSwitch[i64] from 53807 to 53882<br>  Morphed node: t5: i64,i32 = DEC64r nsw t3<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t20: i64 = AssertSext t19, ValueType:ch:i32<br><br>ISEL: Starting selection on root node: t9: i64 = AssertZext t7, ValueType:ch:i32<br><br>ISEL: Starting selection on root node: t3: i64 = sign_extend t2<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135712<br>  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737<br>  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758<br>  Morphed node: t3: i64 = MOVSX64rr32 t2<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t19: i64,ch = CopyFromReg t0, Register:i64 %5<br><br>ISEL: Starting selection on root node: t12: i64,ch = CopyFromReg t0, Register:i64 %8<br><br>ISEL: Starting selection on root node: t7: i64,ch = CopyFromReg t0, Register:i64 %0<br><br>ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %11<br><br>ISEL: Starting selection on root node: t26: i32 = Register %13<br><br>ISEL: Starting selection on root node: t18: i64 = Register %5<br><br>ISEL: Starting selection on root node: t16: i64 = Register %12<br><br>ISEL: Starting selection on root node: t11: i64 = Register %8<br><br>ISEL: Starting selection on root node: t6: i64 = Register %0<br><br>ISEL: Starting selection on root node: t1: i32 = Register %11<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.3 &#x27;solve_:.lr.ph.us&#x27;<br>SelectionDAG has 23 nodes:<br>  t0: ch,glue = EntryToken<br>    t12: i64,ch = CopyFromReg t0, Register:i64 %8<br>          t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>        t3: i64 = MOVSX64rr32 t2<br>      t5: i64,i32 = DEC64r nsw t3<br>      t7: i64,ch = CopyFromReg t0, Register:i64 %0<br>    t10: i64,i32 = IMUL64rr nsw t5, t7<br>  t15: i64 = LEA64r t12, TargetConstant:i8&lt;4&gt;, t10, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg<br>  t33: i32 = Register $noreg<br>    t17: ch = CopyToReg t0, Register:i64 %12, t15<br>        t19: i64,ch = CopyFromReg t0, Register:i64 %5<br>      t25: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)&gt; t15, TargetConstant:i8&lt;4&gt;, t19, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t0<br>    t27: ch = CopyToReg t0, Register:i32 %13, t25<br>  t28: ch = TokenFactor t17, t27<br><br><br>Total amount of phi nodes to update: 3<br>Node 0 : (0x60c587dbb000, 2147483657)<br>Node 1 : (0x60c587dbb068, 2147483661)<br>Node 2 : (0x60c587dbb0d0, 2147483652)<br><br>Initial selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 43 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t13: i64 = Constant&lt;0&gt;<br>  t17: i32 = add t2, Constant:i32&lt;1&gt;<br>      t20: i64 = sign_extend t17<br>    t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>  t22: i64 = add t5, t21<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>          t3: i64 = sign_extend t2<br>        t7: i64 = shl t3, Constant:i64&lt;2&gt;<br>      t8: i64 = add t5, t7<br>    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>  t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>        t19: ch = CopyToReg t0, Register:i32 %17, t17<br>        t27: ch = CopyToReg t0, Register:i32 %18, t25<br>        t34: ch = CopyToReg t0, Register:i64 %19, t32<br>        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>      t39: ch = TokenFactor t19, t27, t34, t28<br>      t37: i1 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch<br>    t40: ch = brcond t39, t37, BasicBlock:ch&lt; 0x60c587dbaf00&gt;<br>  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br><br><br>Optimized lowered selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 42 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t17: i32 = add t2, Constant:i32&lt;1&gt;<br>      t20: i64 = sign_extend t17<br>    t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>  t22: i64 = add t5, t21<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>          t3: i64 = sign_extend t2<br>        t7: i64 = shl t3, Constant:i64&lt;2&gt;<br>      t8: i64 = add t5, t7<br>    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>  t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>        t19: ch = CopyToReg t0, Register:i32 %17, t17<br>        t27: ch = CopyToReg t0, Register:i32 %18, t25<br>        t34: ch = CopyToReg t0, Register:i64 %19, t32<br>        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>      t39: ch = TokenFactor t19, t27, t34, t28<br>      t37: i1 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch<br>    t40: ch = brcond t39, t37, BasicBlock:ch&lt; 0x60c587dbaf00&gt;<br>  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br><br><br>Type-legalized selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 44 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t17: i32 = add t2, Constant:i32&lt;1&gt;<br>      t20: i64 = sign_extend t17<br>    t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>  t22: i64 = add t5, t21<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>          t3: i64 = sign_extend t2<br>        t7: i64 = shl t3, Constant:i64&lt;2&gt;<br>      t8: i64 = add t5, t7<br>    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>  t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>        t19: ch = CopyToReg t0, Register:i32 %17, t17<br>        t27: ch = CopyToReg t0, Register:i32 %18, t25<br>        t34: ch = CopyToReg t0, Register:i64 %19, t32<br>        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>      t39: ch = TokenFactor t19, t27, t34, t28<br>        t43: i8 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch<br>      t46: i8 = and t43, Constant:i8&lt;1&gt;<br>    t40: ch = brcond t39, t46, BasicBlock:ch&lt; 0x60c587dbaf00&gt;<br>  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br><br><br>Optimized type-legalized selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 42 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t17: i32 = add t2, Constant:i32&lt;1&gt;<br>      t20: i64 = sign_extend t17<br>    t21: i64 = shl t20, Constant:i64&lt;2&gt;<br>  t22: i64 = add t5, t21<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>          t3: i64 = sign_extend t2<br>        t7: i64 = shl t3, Constant:i64&lt;2&gt;<br>      t8: i64 = add t5, t7<br>    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>  t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>        t19: ch = CopyToReg t0, Register:i32 %17, t17<br>        t27: ch = CopyToReg t0, Register:i32 %18, t25<br>        t34: ch = CopyToReg t0, Register:i64 %19, t32<br>        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>      t39: ch = TokenFactor t19, t27, t34, t28<br>      t43: i8 = setcc t32, Constant:i64&lt;1&gt;, setgt:ch<br>    t40: ch = brcond t39, t43, BasicBlock:ch&lt; 0x60c587dbaf00&gt;<br>  t42: ch = br t40, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br><br><br>Legalized selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 42 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t17: i32 = add t2, Constant:i32&lt;1&gt;<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>      t20: i64 = sign_extend t17<br>    t21: i64 = shl t20, Constant:i8&lt;2&gt;<br>  t22: i64 = add t5, t21<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>          t3: i64 = sign_extend t2<br>        t7: i64 = shl t3, Constant:i8&lt;2&gt;<br>      t8: i64 = add t5, t7<br>    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>  t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>        t19: ch = CopyToReg t0, Register:i32 %17, t17<br>        t27: ch = CopyToReg t0, Register:i32 %18, t25<br>        t34: ch = CopyToReg t0, Register:i64 %19, t32<br>        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>      t39: ch = TokenFactor t19, t27, t34, t28<br>      t47: i64,i32 = X86ISD::SUB t32, Constant:i64&lt;1&gt;<br>    t49: ch = X86ISD::BRCOND t39, BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t47:1<br>  t42: ch = br t49, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br><br><br>Optimized legalized selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 42 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t17: i32 = add t2, Constant:i32&lt;1&gt;<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>      t20: i64 = sign_extend t17<br>    t21: i64 = shl t20, Constant:i8&lt;2&gt;<br>  t22: i64 = add t5, t21<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>          t3: i64 = sign_extend t2<br>        t7: i64 = shl t3, Constant:i8&lt;2&gt;<br>      t8: i64 = add t5, t7<br>    t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>  t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>  t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>        t19: ch = CopyToReg t0, Register:i32 %17, t17<br>        t27: ch = CopyToReg t0, Register:i32 %18, t25<br>        t34: ch = CopyToReg t0, Register:i64 %19, t32<br>        t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>      t39: ch = TokenFactor t19, t27, t34, t28<br>      t47: i64,i32 = X86ISD::SUB t32, Constant:i64&lt;1&gt;<br>    t49: ch = X86ISD::BRCOND t39, BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t47:1<br>  t42: ch = br t49, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br><br>===== Instruction selection begins: %bb.4 &#x27;&#x27;<br><br>ISEL: Starting selection on root node: t42: ch = br t49, BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 136351<br>  Morphed node: t42: ch = JMP_1 BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;, t49<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t49: ch = X86ISD::BRCOND t39, BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t47:1<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135091<br>  Morphed node: t49: ch = JCC_1 BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t52, t52:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t39: ch = TokenFactor t19, t27, t34, t28<br><br>ISEL: Starting selection on root node: t27: ch = CopyToReg t0, Register:i32 %18, t25<br><br>ISEL: Starting selection on root node: t28: ch = store&lt;(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t23:1, t25, t22, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 5<br>  Skipped scope entry (due to false predicate) at index 13, continuing at 73<br>  Skipped scope entry (due to false predicate) at index 74, continuing at 134<br>  Skipped scope entry (due to false predicate) at index 135, continuing at 178<br>  Skipped scope entry (due to false predicate) at index 179, continuing at 222<br>  Skipped scope entry (due to false predicate) at index 223, continuing at 283<br>  Skipped scope entry (due to false predicate) at index 284, continuing at 327<br>  Match failed at index 332<br>  Continuing at 350<br>  Match failed at index 351<br>  Continuing at 373<br>  Match failed at index 374<br>  Continuing at 417<br>  Match failed at index 418<br>  Continuing at 461<br>  Match failed at index 462<br>  Continuing at 486<br>  Match failed at index 487<br>  Continuing at 530<br>  Match failed at index 531<br>  Continuing at 591<br>  Match failed at index 592<br>  Continuing at 652<br>  Match failed at index 653<br>  Continuing at 697<br>  Match failed at index 698<br>  Continuing at 758<br>  Match failed at index 759<br>  Continuing at 783<br>  Match failed at index 784<br>  Continuing at 808<br>  Match failed at index 809<br>  Continuing at 833<br>  Match failed at index 834<br>  Continuing at 858<br>  Match failed at index 859<br>  Continuing at 883<br>  Match failed at index 884<br>  Continuing at 908<br>  Match failed at index 909<br>  Continuing at 942<br>  Match failed at index 943<br>  Continuing at 976<br>  Continuing at 977<br>  OpcodeSwitch from 980 to 3569<br>  Match failed at index 3578<br>  Continuing at 4244<br>  Match failed at index 4253<br>  Continuing at 4292<br>  Match failed at index 4296<br>  Continuing at 4335<br>  Match failed at index 4339<br>  Continuing at 4377<br>  Match failed at index 4378<br>  Continuing at 4421<br>  Continuing at 4422<br>  Match failed at index 4429<br>  Continuing at 4537<br>  Match failed at index 4540<br>  Continuing at 4652<br>  Continuing at 10391<br>  Match failed at index 10395<br>  Continuing at 11659<br>  Match failed at index 11662<br>  Continuing at 12194<br>  Match failed at index 12195<br>  Continuing at 12278<br>  Match failed at index 12279<br>  Continuing at 12362<br>  Skipped scope entry (due to false predicate) at index 12368, continuing at 12468<br>  Match failed at index 12471<br>  Continuing at 12493<br>  Match failed at index 12496<br>  Continuing at 12518<br>  Match failed at index 12526<br>  Continuing at 12542<br>  Match failed at index 12543<br>  Continuing at 12568<br>  Continuing at 12569<br>  Match failed at index 12572<br>  Continuing at 12704<br>  Skipped scope entry (due to false predicate) at index 12709, continuing at 12728<br>  Skipped scope entry (due to false predicate) at index 12729, continuing at 12748<br>  Morphed node: t28: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t25, t23:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t25: i32 = add t23, Constant:i32&lt;-20&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52338<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53258<br>  Continuing at 53457<br>  TypeSwitch[i32] from 53459 to 53462<br>  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478<br>  Match failed at index 53481<br>  Continuing at 53493<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905<br>  Match failed at index 53919<br>  Continuing at 53946<br>  TypeSwitch[i32] from 53948 to 54007<br>  Morphed node: t25: i32,i32 = ADD32ri t23, TargetConstant:i32&lt;-20&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t23: i32,ch = load&lt;(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t15, t22, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 122140<br>  Match failed at index 122148<br>  Continuing at 122164<br>  Match failed at index 122167<br>  Continuing at 122183<br>  Morphed node: t23: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t15<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t15: ch = store&lt;(store (s32) into %ir.gep.us, !tbaa !17)&gt; t0, t12, t8, undef:i64<br>ISEL: Starting pattern match<br>  Initial Opcode index to 5<br>  Skipped scope entry (due to false predicate) at index 13, continuing at 73<br>  Skipped scope entry (due to false predicate) at index 74, continuing at 134<br>  Skipped scope entry (due to false predicate) at index 135, continuing at 178<br>  Skipped scope entry (due to false predicate) at index 179, continuing at 222<br>  Skipped scope entry (due to false predicate) at index 223, continuing at 283<br>  Skipped scope entry (due to false predicate) at index 284, continuing at 327<br>  Match failed at index 332<br>  Continuing at 350<br>  Match failed at index 351<br>  Continuing at 373<br>  Match failed at index 374<br>  Continuing at 417<br>  Match failed at index 418<br>  Continuing at 461<br>  Match failed at index 462<br>  Continuing at 486<br>  Match failed at index 487<br>  Continuing at 530<br>  Match failed at index 531<br>  Continuing at 591<br>  Match failed at index 592<br>  Continuing at 652<br>  Match failed at index 653<br>  Continuing at 697<br>  Match failed at index 698<br>  Continuing at 758<br>  Match failed at index 759<br>  Continuing at 783<br>  Match failed at index 784<br>  Continuing at 808<br>  Match failed at index 809<br>  Continuing at 833<br>  Match failed at index 834<br>  Continuing at 858<br>  Match failed at index 859<br>  Continuing at 883<br>  Match failed at index 884<br>  Continuing at 908<br>  Match failed at index 909<br>  Continuing at 942<br>  Match failed at index 943<br>  Continuing at 976<br>  Continuing at 977<br>  OpcodeSwitch from 980 to 3569<br>  Match failed at index 3573<br>  Continuing at 4244<br>  Match failed at index 4253<br>  Continuing at 4292<br>  Match failed at index 4296<br>  Continuing at 4335<br>  Match failed at index 4339<br>  Continuing at 4377<br>  Match failed at index 4378<br>  Continuing at 4421<br>  Continuing at 4422<br>  Match failed at index 4424<br>  Continuing at 4537<br>  Match failed at index 4540<br>  Continuing at 4652<br>  Continuing at 10391<br>  Match failed at index 10395<br>  Continuing at 11659<br>  Match failed at index 11662<br>  Continuing at 12194<br>  Match failed at index 12195<br>  Continuing at 12278<br>  Match failed at index 12279<br>  Continuing at 12362<br>  Skipped scope entry (due to false predicate) at index 12368, continuing at 12468<br>  Match failed at index 12471<br>  Continuing at 12493<br>  Match failed at index 12496<br>  Continuing at 12518<br>  Match failed at index 12526<br>  Continuing at 12542<br>  Match failed at index 12543<br>  Continuing at 12568<br>  Continuing at 12569<br>  Match failed at index 12572<br>  Continuing at 12704<br>  Skipped scope entry (due to false predicate) at index 12709, continuing at 12728<br>  Skipped scope entry (due to false predicate) at index 12729, continuing at 12748<br>  Morphed node: t15: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep.us, !tbaa !17)&gt; t5, TargetConstant:i8&lt;4&gt;, t3, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t12, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t34: ch = CopyToReg t0, Register:i64 %19, t32<br><br>ISEL: Starting selection on root node: t47: i64,i32 = X86ISD::SUB t32, Constant:i64&lt;1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 114065<br>  Match failed at index 114073<br>  Continuing at 114269<br>  Match failed at index 114272<br>  Continuing at 114372<br>  Match failed at index 114373<br>  Continuing at 114475<br>  Continuing at 114476<br>  Match failed at index 114477<br>  Continuing at 114578<br>  Match failed at index 114597<br>  Continuing at 114638<br>  Morphed node: t47: i64,i32 = SUB64ri32 t32, TargetConstant:i64&lt;1&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t19: ch = CopyToReg t0, Register:i32 %17, t17<br><br>ISEL: Starting selection on root node: t20: i64 = sign_extend t17<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135712<br>  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737<br>  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758<br>  Morphed node: t20: i64 = MOVSX64rr32 t17<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t32: i64 = add t30, Constant:i64&lt;-1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Match failed at index 53496<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  TypeSwitch[i64] from 53807 to 53882<br>  Morphed node: t32: i64,i32 = DEC64r t30<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t12: i32 = add t10, Constant:i32&lt;-10&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i32] from 53459 to 53462<br>  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478<br>  Match failed at index 53481<br>  Continuing at 53493<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  Skipped scope entry (due to false predicate) at index 53805, continuing at 53905<br>  Match failed at index 53919<br>  Continuing at 53946<br>  TypeSwitch[i32] from 53948 to 54007<br>  Morphed node: t12: i32,i32 = ADD32ri t10, TargetConstant:i32&lt;-10&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t3: i64 = sign_extend t2<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135712<br>  Skipped scope entry (due to false predicate) at index 135717, continuing at 135737<br>  Skipped scope entry (due to false predicate) at index 135738, continuing at 135758<br>  Morphed node: t3: i64 = MOVSX64rr32 t2<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t17: i32 = add t2, Constant:i32&lt;1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i32] from 53459 to 53462<br>  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478<br>  Match failed at index 53481<br>  Continuing at 53493<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  TypeSwitch[i32] from 53706 to 53757<br>  Morphed node: t17: i32,i32 = INC32r t2<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t30: i64,ch = CopyFromReg t0, Register:i64 %14<br><br>ISEL: Starting selection on root node: t10: i32,ch = CopyFromReg t0, Register:i32 %15<br><br>ISEL: Starting selection on root node: t5: i64,ch = CopyFromReg t0, Register:i64 %12<br><br>ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %16<br><br>ISEL: Starting selection on root node: t48: i8 = TargetConstant&lt;15&gt;<br><br>ISEL: Starting selection on root node: t41: ch = BasicBlock&lt;._crit_edge.us 0x60c587dbb138&gt;<br><br>ISEL: Starting selection on root node: t38: ch = BasicBlock&lt; 0x60c587dbaf00&gt;<br><br>ISEL: Starting selection on root node: t33: i64 = Register %19<br><br>ISEL: Starting selection on root node: t29: i64 = Register %14<br><br>ISEL: Starting selection on root node: t26: i32 = Register %18<br><br>ISEL: Starting selection on root node: t18: i32 = Register %17<br><br>ISEL: Starting selection on root node: t9: i32 = Register %15<br><br>ISEL: Starting selection on root node: t4: i64 = Register %12<br><br>ISEL: Starting selection on root node: t1: i32 = Register %16<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.4 &#x27;solve_:&#x27;<br>SelectionDAG has 40 nodes:<br>  t0: ch,glue = EntryToken<br>  t2: i32,ch = CopyFromReg t0, Register:i32 %16<br>  t5: i64,ch = CopyFromReg t0, Register:i64 %12<br>  t17: i32,i32 = INC32r t2<br>    t30: i64,ch = CopyFromReg t0, Register:i64 %14<br>  t32: i64,i32 = DEC64r t30<br>  t20: i64 = MOVSX64rr32 t17<br>      t3: i64 = MOVSX64rr32 t2<br>        t10: i32,ch = CopyFromReg t0, Register:i32 %15<br>      t12: i32,i32 = ADD32ri t10, TargetConstant:i32&lt;-10&gt;<br>    t15: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep.us, !tbaa !17)&gt; t5, TargetConstant:i8&lt;4&gt;, t3, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t12, t0<br>  t23: i32,ch = MOV32rm&lt;Mem:(load (s32) from %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t15<br>  t25: i32,i32 = ADD32ri t23, TargetConstant:i32&lt;-20&gt;<br>      t19: ch = CopyToReg t0, Register:i32 %17, t17<br>      t27: ch = CopyToReg t0, Register:i32 %18, t25<br>      t34: ch = CopyToReg t0, Register:i64 %19, t32<br>      t28: ch = MOV32mr&lt;Mem:(store (s32) into %ir.gep54.us, !tbaa !21)&gt; t5, TargetConstant:i8&lt;4&gt;, t20, TargetConstant:i32&lt;0&gt;, Register:i16 $noreg, t25, t23:1<br>    t39: ch = TokenFactor t19, t27, t34, t28<br>    t47: i64,i32 = SUB64ri32 t32, TargetConstant:i64&lt;1&gt;<br>  t52: ch,glue = CopyToReg t39, Register:i32 $eflags, t47:1<br>  t56: i32 = Register $noreg<br>    t49: ch = JCC_1 BasicBlock:ch&lt; 0x60c587dbaf00&gt;, TargetConstant:i8&lt;15&gt;, t52, t52:1<br>  t42: ch = JMP_1 BasicBlock:ch&lt;._crit_edge.us 0x60c587dbb138&gt;, t49<br><br><br>Total amount of phi nodes to update: 3<br>Node 0 : (0x60c587dbb000, 2147483667)<br>Node 1 : (0x60c587dbb068, 2147483666)<br>Node 2 : (0x60c587dbb0d0, 2147483665)<br><br>Initial selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 21 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t4: i32 = add t2, Constant:i32&lt;1&gt;<br>        t6: ch = CopyToReg t0, Register:i32 %20, t4<br>          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>        t12: ch = CopyToReg t0, Register:i64 %21, t10<br>      t17: ch = TokenFactor t6, t12<br>      t15: i1 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch<br>    t18: ch = brcond t17, t15, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;<br>  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br><br><br><br>Optimized lowered selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 21 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t4: i32 = add t2, Constant:i32&lt;1&gt;<br>        t6: ch = CopyToReg t0, Register:i32 %20, t4<br>          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>        t12: ch = CopyToReg t0, Register:i64 %21, t10<br>      t17: ch = TokenFactor t6, t12<br>      t15: i1 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch<br>    t18: ch = brcond t17, t15, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;<br>  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br><br><br><br>Type-legalized selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 23 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t4: i32 = add t2, Constant:i32&lt;1&gt;<br>        t6: ch = CopyToReg t0, Register:i32 %20, t4<br>          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>        t12: ch = CopyToReg t0, Register:i64 %21, t10<br>      t17: ch = TokenFactor t6, t12<br>        t21: i8 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch<br>      t24: i8 = and t21, Constant:i8&lt;1&gt;<br>    t18: ch = brcond t17, t24, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;<br>  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br><br><br><br>Optimized type-legalized selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 21 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t4: i32 = add t2, Constant:i32&lt;1&gt;<br>        t6: ch = CopyToReg t0, Register:i32 %20, t4<br>          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>        t12: ch = CopyToReg t0, Register:i64 %21, t10<br>      t17: ch = TokenFactor t6, t12<br>      t21: i8 = setcc t8, Constant:i64&lt;1&gt;, setgt:ch<br>    t18: ch = brcond t17, t21, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;<br>  t20: ch = br t18, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br><br><br><br>Legalized selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 21 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t4: i32 = add t2, Constant:i32&lt;1&gt;<br>        t6: ch = CopyToReg t0, Register:i32 %20, t4<br>          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>        t12: ch = CopyToReg t0, Register:i64 %21, t10<br>      t17: ch = TokenFactor t6, t12<br>      t25: i64,i32 = X86ISD::SUB t8, Constant:i64&lt;1&gt;<br>    t27: ch = X86ISD::BRCOND t17, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t25:1<br>  t20: ch = br t27, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br><br><br><br>Optimized legalized selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 21 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>            t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>          t4: i32 = add t2, Constant:i32&lt;1&gt;<br>        t6: ch = CopyToReg t0, Register:i32 %20, t4<br>          t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>        t12: ch = CopyToReg t0, Register:i64 %21, t10<br>      t17: ch = TokenFactor t6, t12<br>      t25: i64,i32 = X86ISD::SUB t8, Constant:i64&lt;1&gt;<br>    t27: ch = X86ISD::BRCOND t17, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t25:1<br>  t20: ch = br t27, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br><br><br>===== Instruction selection begins: %bb.5 &#x27;._crit_edge.us&#x27;<br><br>ISEL: Starting selection on root node: t20: ch = br t27, BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 136351<br>  Morphed node: t20: ch = JMP_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, t27<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t27: ch = X86ISD::BRCOND t17, BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t25:1<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135091<br>  Morphed node: t27: ch = JCC_1 BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t29, t29:1<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t17: ch = TokenFactor t6, t12<br><br>ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i64 %21, t10<br><br>ISEL: Starting selection on root node: t6: ch = CopyToReg t0, Register:i32 %20, t4<br><br>ISEL: Starting selection on root node: t10: i64 = add nsw t8, Constant:i64&lt;-1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i64] from 53459 to 53496<br>  Match failed at index 53496<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  Skipped scope entry (due to false predicate) at index 53704, continuing at 53804<br>  TypeSwitch[i64] from 53807 to 53882<br>  Morphed node: t10: i64,i32 = DEC64r nsw t8<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t25: i64,i32 = X86ISD::SUB t8, Constant:i64&lt;1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 114065<br>  Match failed at index 114073<br>  Continuing at 114269<br>  Match failed at index 114272<br>  Continuing at 114372<br>  Match failed at index 114373<br>  Continuing at 114475<br>  Continuing at 114476<br>  Match failed at index 114477<br>  Continuing at 114578<br>  Match failed at index 114597<br>  Continuing at 114638<br>  Morphed node: t25: i64,i32 = SUB64ri32 t8, TargetConstant:i64&lt;1&gt;<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t4: i32 = add t2, Constant:i32&lt;1&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 52329<br>  Match failed at index 52333<br>  Continuing at 52897<br>  Match failed at index 52909<br>  Continuing at 52941<br>  Match failed at index 52945<br>  Continuing at 52977<br>  Match failed at index 52981<br>  Continuing at 53012<br>  Match failed at index 53013<br>  Continuing at 53049<br>  Continuing at 53050<br>  Match failed at index 53053<br>  Continuing at 53249<br>  Continuing at 53250<br>  Match failed at index 53253<br>  Continuing at 53457<br>  TypeSwitch[i32] from 53459 to 53462<br>  Skipped scope entry (due to false predicate) at index 53464, continuing at 53478<br>  Match failed at index 53481<br>  Continuing at 53493<br>  Continuing at 53509<br>  Match failed at index 53512<br>  Continuing at 53531<br>  Match failed at index 53533<br>  Continuing at 53553<br>  Skipped scope entry (due to false predicate) at index 53558, continuing at 53659<br>  Skipped scope entry (due to false predicate) at index 53660, continuing at 53703<br>  TypeSwitch[i32] from 53706 to 53757<br>  Morphed node: t4: i32,i32 = INC32r t2<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t8: i64,ch = CopyFromReg t0, Register:i64 %10<br><br>ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %11<br><br>ISEL: Starting selection on root node: t26: i8 = TargetConstant&lt;15&gt;<br><br>ISEL: Starting selection on root node: t19: ch = BasicBlock&lt;._crit_edge57 0x60c587dbb238&gt;<br><br>ISEL: Starting selection on root node: t16: ch = BasicBlock&lt;.lr.ph.us 0x60c587dbad30&gt;<br><br>ISEL: Starting selection on root node: t11: i64 = Register %21<br><br>ISEL: Starting selection on root node: t7: i64 = Register %10<br><br>ISEL: Starting selection on root node: t5: i32 = Register %20<br><br>ISEL: Starting selection on root node: t1: i32 = Register %11<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.5 &#x27;solve_:._crit_edge.us&#x27;<br>SelectionDAG has 22 nodes:<br>  t0: ch,glue = EntryToken<br>  t8: i64,ch = CopyFromReg t0, Register:i64 %10<br>          t2: i32,ch = CopyFromReg t0, Register:i32 %11<br>        t4: i32,i32 = INC32r t2<br>      t6: ch = CopyToReg t0, Register:i32 %20, t4<br>        t10: i64,i32 = DEC64r nsw t8<br>      t12: ch = CopyToReg t0, Register:i64 %21, t10<br>    t17: ch = TokenFactor t6, t12<br>    t25: i64,i32 = SUB64ri32 t8, TargetConstant:i64&lt;1&gt;<br>  t29: ch,glue = CopyToReg t17, Register:i32 $eflags, t25:1<br>  t30: i32 = Register $noreg<br>    t27: ch = JCC_1 BasicBlock:ch&lt;.lr.ph.us 0x60c587dbad30&gt;, TargetConstant:i8&lt;15&gt;, t29, t29:1<br>  t20: ch = JMP_1 BasicBlock:ch&lt;._crit_edge57 0x60c587dbb238&gt;, t27<br><br><br>Total amount of phi nodes to update: 2<br>Node 0 : (0x60c587dbae30, 2147483669)<br>Node 1 : (0x60c587dbae98, 2147483668)<br><br>Initial selection DAG: %bb.6 &#x27;solve_:._crit_edge57&#x27;<br>SelectionDAG has 3 nodes:<br>    t0: ch,glue = EntryToken<br>  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;<br><br><br><br>Optimized lowered selection DAG: %bb.6 &#x27;solve_:._crit_edge57&#x27;<br>SelectionDAG has 3 nodes:<br>    t0: ch,glue = EntryToken<br>  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;<br><br><br><br>Type-legalized selection DAG: %bb.6 &#x27;solve_:._crit_edge57&#x27;<br>SelectionDAG has 3 nodes:<br>    t0: ch,glue = EntryToken<br>  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;<br><br><br><br>Legalized selection DAG: %bb.6 &#x27;solve_:._crit_edge57&#x27;<br>SelectionDAG has 3 nodes:<br>    t0: ch,glue = EntryToken<br>  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;<br><br><br><br>Optimized legalized selection DAG: %bb.6 &#x27;solve_:._crit_edge57&#x27;<br>SelectionDAG has 3 nodes:<br>    t0: ch,glue = EntryToken<br>  t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;<br><br><br>===== Instruction selection begins: %bb.6 &#x27;._crit_edge57&#x27;<br><br>ISEL: Starting selection on root node: t2: ch = X86ISD::RET_GLUE t0, TargetConstant:i32&lt;0&gt;<br>ISEL: Starting pattern match<br>  Initial Opcode index to 135073<br>  Morphed node: t2: ch = RET TargetConstant:i32&lt;0&gt;, t0<br>ISEL: Match complete!<br><br>ISEL: Starting selection on root node: t1: i32 = TargetConstant&lt;0&gt;<br><br>ISEL: Starting selection on root node: t0: ch,glue = EntryToken<br><br>===== Instruction selection ends:<br><br>Selected selection DAG: %bb.6 &#x27;solve_:._crit_edge57&#x27;<br>SelectionDAG has 3 nodes:<br>    t0: ch,glue = EntryToken<br>  t2: ch = RET TargetConstant:i32&lt;0&gt;, t0<br><br><br>Total amount of phi nodes to update: 0<br>*** MachineFunction at end of ISel ***<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Machine code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> solve_: IsSSA, TracksLiveness</span><br>Frame Objects:<br><span class="hljs-meta prompt_">  fi#</span><span class="language-bash">0: variable sized, align=1, at location [SP+8]</span><br>Function Live Ins: $rdi in %22, $rsi in %23, $rdx in %24, $rcx in %25, $r8 in %26<br><br>bb.0 (%ir-block.5):<br>  successors: %bb.1(0x50000000), %bb.6(0x30000000); %bb.1(62.50%), %bb.6(37.50%)<br>  liveins: $rdi, $rsi, $rdx, $rcx, $r8<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">26:gr64 = COPY <span class="hljs-variable">$r8</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">25:gr64 = COPY <span class="hljs-variable">$rcx</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">24:gr64 = COPY <span class="hljs-variable">$rdx</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">23:gr64 = COPY <span class="hljs-variable">$rsi</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">22:gr64 = COPY <span class="hljs-variable">$rdi</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">27:gr32 = MOV32rm %22:gr64, 1, <span class="hljs-variable">$noreg</span>, 0, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.0, !tbaa !3)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">28:gr32 = MOV32r0 implicit-def dead <span class="hljs-variable">$eflags</span></span><br>  TEST32rr %27:gr32, %27:gr32, implicit-def $eflags<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">29:gr32 = CMOV32rr %28:gr32(tied-def 0), %27:gr32, 15, implicit <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">0:gr64 = SUBREG_TO_REG 0, killed %29:gr32, %subreg.sub_32bit</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">30:gr64_nosp = nuw nsw IMUL64rr %0:gr64(tied-def 0), %0:gr64, implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">31:gr64 = nuw LEA64r <span class="hljs-variable">$noreg</span>, 4, killed %30:gr64_nosp, 15, <span class="hljs-variable">$noreg</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">32:gr64 = AND64ri32 %31:gr64(tied-def 0), -16, implicit-def dead <span class="hljs-variable">$eflags</span></span><br>  ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">33:gr64 = COPY <span class="hljs-variable">$rsp</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">1:gr64 = SUB64rr %33:gr64(tied-def 0), killed %32:gr64, implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  $</span><span class="language-bash">rsp = COPY %1:gr64</span><br>  ADJCALLSTACKUP64 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">34:gr64_nosp = MOVSX64rm32 %25:gr64, 1, <span class="hljs-variable">$noreg</span>, 0, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.3, !tbaa !9)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">35:gr64 = MOVSX64rm32 %23:gr64, 4, %34:gr64_nosp, -4, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.14, !tbaa !11)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">2:gr32 = COPY %35.sub_32bit:gr64</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">36:gr64 = MOVSX64rm32 %24:gr64, 4, %34:gr64_nosp, -4, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.17, !tbaa !13)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">3:gr64 = SUB64rr %36:gr64(tied-def 0), %35:gr64, implicit-def <span class="hljs-variable">$eflags</span></span><br>  JCC_1 %bb.6, 8, implicit $eflags<br>  JMP_1 %bb.1<br><br>bb.1..lr.ph56:<br>; predecessors: %bb.0<br>  successors: %bb.2(0x50000000), %bb.6(0x30000000); %bb.2(62.50%), %bb.6(37.50%)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">37:gr64_nosp = MOVSX64rm32 %26:gr64, 1, <span class="hljs-variable">$noreg</span>, 0, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.4, !tbaa !15)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">4:gr32 = MOV32rm %23:gr64, 4, %37:gr64_nosp, -4, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.24, !tbaa !11)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">5:gr64_nosp = MOVSX64rr32 %4:gr32</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">6:gr64 = MOVSX64rm32 %24:gr64, 4, %37:gr64_nosp, -4, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.27, !tbaa !13)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">38:gr64 = SUB64rr %6:gr64(tied-def 0), %5:gr64_nosp, implicit-def <span class="hljs-variable">$eflags</span></span><br>  JCC_1 %bb.6, 8, implicit $eflags<br>  JMP_1 %bb.2<br><br>bb.2..lr.ph.us.preheader:<br>; predecessors: %bb.1<br>  successors: %bb.3(0x80000000); %bb.3(100.00%)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">7:gr64 = nuw nsw INC64r %3:gr64(tied-def 0), implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">8:gr64 = ADD64ri32 %1:gr64(tied-def 0), -4, implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">39:gr64 = SUB64rr %6:gr64(tied-def 0), %5:gr64_nosp, implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">9:gr64 = ADD64ri32 %39:gr64(tied-def 0), 2, implicit-def dead <span class="hljs-variable">$eflags</span></span><br><br>bb.3..lr.ph.us:<br>; predecessors: %bb.2, %bb.5<br>  successors: %bb.4(0x80000000); %bb.4(100.00%)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">10:gr64 = PHI %7:gr64, %bb.2, %21:gr64, %bb.5</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">11:gr32 = PHI %2:gr32, %bb.2, %20:gr32, %bb.5</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">40:gr64 = MOVSX64rr32 %11:gr32</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">41:gr64 = nsw DEC64r %40:gr64(tied-def 0), implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">42:gr64_nosp = nsw IMUL64rr %41:gr64(tied-def 0), %0:gr64, implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">12:gr64 = LEA64r %8:gr64, 4, killed %42:gr64_nosp, 0, <span class="hljs-variable">$noreg</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">13:gr32 = MOV32rm %12:gr64, 4, %5:gr64_nosp, 0, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.gep.us.phi.trans.insert, !tbaa !17)</span><br><br>bb.4 (%ir-block.39):<br>; predecessors: %bb.3, %bb.4<br>  successors: %bb.4(0x7c000000), %bb.5(0x04000000); %bb.4(96.88%), %bb.5(3.12%)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">14:gr64 = PHI %9:gr64, %bb.3, %19:gr64, %bb.4</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">15:gr32 = PHI %13:gr32, %bb.3, %18:gr32, %bb.4</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">16:gr32 = PHI %4:gr32, %bb.3, %17:gr32, %bb.4</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">43:gr64_nosp = MOVSX64rr32 %16:gr32</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">44:gr32 = ADD32ri %15:gr32(tied-def 0), -10, implicit-def dead <span class="hljs-variable">$eflags</span></span><br>  MOV32mr %12:gr64, 4, killed %43:gr64_nosp, 0, $noreg, killed %44:gr32 :: (store (s32) into %ir.gep.us, !tbaa !17)<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">17:gr32 = INC32r %16:gr32(tied-def 0), implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">45:gr64_nosp = MOVSX64rr32 %17:gr32</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">46:gr32 = MOV32rm %12:gr64, 4, %45:gr64_nosp, 0, <span class="hljs-variable">$noreg</span> :: (load (s32) from %ir.gep54.us, !tbaa !21)</span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">18:gr32 = ADD32ri %46:gr32(tied-def 0), -20, implicit-def dead <span class="hljs-variable">$eflags</span></span><br>  MOV32mr %12:gr64, 4, %45:gr64_nosp, 0, $noreg, %18:gr32 :: (store (s32) into %ir.gep54.us, !tbaa !21)<br><span class="hljs-meta prompt_">  %</span><span class="language-bash">19:gr64 = DEC64r %14:gr64(tied-def 0), implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">47:gr64 = SUB64ri32 %19:gr64(tied-def 0), 1, implicit-def <span class="hljs-variable">$eflags</span></span><br>  JCC_1 %bb.4, 15, implicit $eflags<br>  JMP_1 %bb.5<br><br>bb.5.._crit_edge.us:<br>; predecessors: %bb.4<br>  successors: %bb.3(0x7c000000), %bb.6(0x04000000); %bb.3(96.88%), %bb.6(3.12%)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">20:gr32 = INC32r %11:gr32(tied-def 0), implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">21:gr64 = nsw DEC64r %10:gr64(tied-def 0), implicit-def dead <span class="hljs-variable">$eflags</span></span><br><span class="hljs-meta prompt_">  %</span><span class="language-bash">48:gr64 = SUB64ri32 %10:gr64(tied-def 0), 1, implicit-def <span class="hljs-variable">$eflags</span></span><br>  JCC_1 %bb.3, 15, implicit $eflags<br>  JMP_1 %bb.6<br><br>bb.6.._crit_edge57:<br>; predecessors: %bb.0, %bb.1, %bb.5<br><br>  RET 0<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">End machine code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> solve_.</span><br><br><br></code></pre></td></tr></table></figure>

            </article>
            
	<aside class="rightside">
	
		<div class="rightside-button not-toc-button" id="js-aside">
			<span>
				<img no-lazy src="/images/icon/aside.png" class="rightside-button-icon" alt="Icon">
			</span>
		</div>
		<script>
			$("#js-aside").click(function () {
				onShowAsideButton();
			});
		</script>
	
	<div class="rightside-button" id="js-toggle_theme">
		<span>
			<img no-lazy src="/images/icon/toggle_theme.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	
<script src="/js/plugins/goto_position.js"></script>

	
	<div class="rightside-button" id="js-go_top">
		<span>
			<img no-lazy src="/images/icon/go_top.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>
	<div class="rightside-button" id="js-go_bottom">
		<span>
			<img no-lazy src="/images/icon/go_bottom.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	<script>
		setToggleThemeButtonListener();
	</script>
	<script>
		$('#js-go_top')
		.gotoPosition( {
			speed: 300,
			target: 'top',
		} );
		$('#js-go_bottom')
		.gotoPosition( {
			speed: 300,
			target: 'bottom',
		} );
	</script>
</aside>


<div class="post-bottom">
    
        <div class="post-paging">     
            <div class="post-paging-last">
                
            </div>
            <div class="post-paging-next">
                
                    <a href="/2024/12/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AF%87%EF%BC%9A%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8/">
                        下一篇：数据结构篇：设计链表
                    </a>
                
            </div>
        </div>
    
    
    
        
    
</div>
        </div>
    </main>
    
        <aside class="main-aside">
    
<script src="/js/widgets/aside.js"></script>

    <script>
        showAside();
    </script>

    <div class="aside-top">
        <div class="aside-top-about aside-card">
            <a href="" class="aside-top-about-portrait">
                <img no-lazy src="/images/icon/head.jpg" alt="Q">
            </a>
            <div class="aside-top-about-info">
                <span class="author"> LLj</span>
                <span class="description">道阻且长 行则将至</span>
            </div>              
            <div class="aside-top-about-site">
                <a href="/categories" class="aside-top-about-site-item">
                    <span class="title">类别</span>
                    <span class="count">3</span>
                </a>
                <a href="/tags" class="aside-top-about-site-item">
                    <span class="title">标签</span>
                    <span class="count">6</span>
                </a>
                <a href="/archives" class="aside-top-about-site-item">
                    <span class="title">归档</span>
                    <span class="count">7</span>
                </a>
            </div>
            <div class="aside-top-about-contact">
                
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
                        </a>
                    
                        <a href="">
                            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
                        </a>
                    
                
            </div>
        </div> 

        
    </div>

    <div class="aside-bottom">
        
    </div>
</aside>
    
</div>
		<footer>
	<div class="content">
		
			<span>©2024-2025&nbsp;By&nbsp;<a href="/about">LLJ</a>.</span>
		
		<span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> theme by <a target="_blank" rel="noopener" href="https://github.com/GZ-Metal-Cell/hexo-theme-quieter">Quieter</a>.</span>
		
	</div>

	
<script src="/js/plugins/ref.js"></script>

	
<script src="/js/plugins/highlight_tools.js"></script>

	<script>
		var copyIcon = "/images/icon/copy.png";
		var closeCodeBlockIcon = "/images/icon/close_code_block.png";
		var highlightShrink = "";
		var HighlightHeightLimit = "";
	</script>
	
	<!-- Analytics -->

    
        <!-- Busuanzi Analytics -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    


	

	

    
		
<script src="/js/plugins/replaceSpacesWithNbsp.js"></script>

	

	
	
	
		<script>
			if (typeof init === 'function') {
				init();
			}
		</script>
	

	
		
	

	

	<!--
		
<script src="/js/plugins/jquery.pjax.min.js"></script>

		<script>
			$(document).pjax('a[target!=_blank]', 'main', {
				fragment: 'main',
				timeout: 8000
			});

			$(document).on('pjax:complete', function() {
			});
		</script> 
	-->
	<script>
		console.log('\n %c Hexo-Quieter 主题 %c https://github.com/GZ-Metal-Cell/hexo-theme-quieter \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
	</script>
</footer>
	</body>

	<!-- Hexo-Quieter 主题  https://github.com/GZ-Metal-Cell/hexo-theme-quieter -->
</html>

